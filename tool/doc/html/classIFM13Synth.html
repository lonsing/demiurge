<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>demiurge: IFM13Synth Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classIFM13Synth-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IFM13Synth Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the SAT-based synthesis method published at IFM'13.  
 <a href="classIFM13Synth.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IFM13Synth:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classIFM13Synth.png" usemap="#IFM13Synth_map" alt=""/>
  <map id="IFM13Synth_map" name="IFM13Synth_map">
<area href="classBackEnd.html" title="An interface for the back-ends." alt="BackEnd" shape="rect" coords="0,0,80,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae01ff6a7fb118c2ebdc04818ef59726b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#ae01ff6a7fb118c2ebdc04818ef59726b">IFM13Synth</a> (<a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *impl_extractor)</td></tr>
<tr class="memdesc:ae01ff6a7fb118c2ebdc04818ef59726b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae01ff6a7fb118c2ebdc04818ef59726b"></a><br/></td></tr>
<tr class="memitem:ad042200b1639e702af49e55088a52f52"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#ad042200b1639e702af49e55088a52f52">~IFM13Synth</a> ()</td></tr>
<tr class="memdesc:ad042200b1639e702af49e55088a52f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ad042200b1639e702af49e55088a52f52"></a><br/></td></tr>
<tr class="memitem:a42adb4f76d88199d92b1bedb58a139f8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a42adb4f76d88199d92b1bedb58a139f8">run</a> ()</td></tr>
<tr class="memdesc:a42adb4f76d88199d92b1bedb58a139f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the back-end (which is implemented as described in the IFM'13 paper).  <a href="#a42adb4f76d88199d92b1bedb58a139f8"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a51c6831265e1daf7d0120c0dd954a0c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a51c6831265e1daf7d0120c0dd954a0c4">computeWinningRegion</a> ()</td></tr>
<tr class="memdesc:a51c6831265e1daf7d0120c0dd954a0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the set of states from which the specification can be fulfilled.  <a href="#a51c6831265e1daf7d0120c0dd954a0c4"></a><br/></td></tr>
<tr class="memitem:ad9262224ce1ddbda37d748fbecfe5d8e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#ad9262224ce1ddbda37d748fbecfe5d8e">propagateBlockedStates</a> (size_t max_level)</td></tr>
<tr class="memdesc:ad9262224ce1ddbda37d748fbecfe5d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates clauses forward and searches for equivalent clause sets.  <a href="#ad9262224ce1ddbda37d748fbecfe5d8e"></a><br/></td></tr>
<tr class="memitem:af46e431e089225b58148ee317d523123"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#af46e431e089225b58148ee317d523123">recBlockCube</a> (const vector&lt; int &gt; &amp;state_cube, size_t level)</td></tr>
<tr class="memdesc:af46e431e089225b58148ee317d523123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes the rank of the passed state.  <a href="#af46e431e089225b58148ee317d523123"></a><br/></td></tr>
<tr class="memitem:a0aa3bd29c1621efda5abb30dd9357214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a0aa3bd29c1621efda5abb30dd9357214">addBlockedTransition</a> (const vector&lt; int &gt; &amp;state_in_cube, size_t level)</td></tr>
<tr class="memdesc:a0aa3bd29c1621efda5abb30dd9357214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a state-input-pair as blocked.  <a href="#a0aa3bd29c1621efda5abb30dd9357214"></a><br/></td></tr>
<tr class="memitem:a31eb626e5ca0232d187e3471e8fed348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a31eb626e5ca0232d187e3471e8fed348">addBlockedState</a> (const vector&lt; int &gt; &amp;state_cube, size_t level)</td></tr>
<tr class="memdesc:a31eb626e5ca0232d187e3471e8fed348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a state(-cube) from the frame R[level].  <a href="#a31eb626e5ca0232d187e3471e8fed348"></a><br/></td></tr>
<tr class="memitem:a27c2617424cad795b9af575a85e75071"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a27c2617424cad795b9af575a85e75071">isBlocked</a> (const vector&lt; int &gt; &amp;state_cube, size_t level)</td></tr>
<tr class="memdesc:a27c2617424cad795b9af575a85e75071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a state is contained in a certain frame.  <a href="#a27c2617424cad795b9af575a85e75071"></a><br/></td></tr>
<tr class="memitem:adf319a6748eda4aa29017a561752b262"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#adf319a6748eda4aa29017a561752b262">addLose</a> (const vector&lt; int &gt; &amp;state_cube)</td></tr>
<tr class="memdesc:adf319a6748eda4aa29017a561752b262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a state(-cube) from the current over-approximation of the winning region.  <a href="#adf319a6748eda4aa29017a561752b262"></a><br/></td></tr>
<tr class="memitem:aca85bf07810f6c8cc3c3125895daf56f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#aca85bf07810f6c8cc3c3125895daf56f">isLose</a> (const vector&lt; int &gt; &amp;state_cube)</td></tr>
<tr class="memdesc:aca85bf07810f6c8cc3c3125895daf56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a state satisfies the current over-approximation of the winning region.  <a href="#aca85bf07810f6c8cc3c3125895daf56f"></a><br/></td></tr>
<tr class="memitem:a1edccb04c096bb68a6fb2a8245f3129b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a1edccb04c096bb68a6fb2a8245f3129b">genAndBlockTrans</a> (const vector&lt; int &gt; &amp;state_in_cube, const vector&lt; int &gt; &amp;ctrl_cube, size_t level)</td></tr>
<tr class="memdesc:a1edccb04c096bb68a6fb2a8245f3129b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalizes and excludes a blocked transition.  <a href="#a1edccb04c096bb68a6fb2a8245f3129b"></a><br/></td></tr>
<tr class="memitem:a050f0c3c5089ef6c5f793878bd60abc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a050f0c3c5089ef6c5f793878bd60abc9">getR</a> (size_t index)</td></tr>
<tr class="memdesc:a050f0c3c5089ef6c5f793878bd60abc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frame R[index] in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>.  <a href="#a050f0c3c5089ef6c5f793878bd60abc9"></a><br/></td></tr>
<tr class="memitem:a396e520b9db59b73a46a2315ee3123b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a396e520b9db59b73a46a2315ee3123b4">getU</a> (size_t index)</td></tr>
<tr class="memdesc:a396e520b9db59b73a46a2315ee3123b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the blocked transitions U[index] in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>.  <a href="#a396e520b9db59b73a46a2315ee3123b4"></a><br/></td></tr>
<tr class="memitem:ae97c0b41568cf25e163ab9b309f0dcaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#ae97c0b41568cf25e163ab9b309f0dcaa">getGotoNextLowerSolver</a> (size_t index)</td></tr>
<tr class="memdesc:ae97c0b41568cf25e163ab9b309f0dcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a solver with <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: U[index] &amp; T &amp; R[index-1]'.  <a href="#ae97c0b41568cf25e163ab9b309f0dcaa"></a><br/></td></tr>
<tr class="memitem:af087a4ddf9026bb48a752c03e539d9da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#af087a4ddf9026bb48a752c03e539d9da">getGenBlockTransSolver</a> (size_t index)</td></tr>
<tr class="memdesc:af087a4ddf9026bb48a752c03e539d9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a solver with <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: T &amp; R[index-1]'.  <a href="#af087a4ddf9026bb48a752c03e539d9da"></a><br/></td></tr>
<tr class="memitem:a6bd825fad36c8cd64afbc2b17fff8b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIFMProofObligation.html">IFMProofObligation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a6bd825fad36c8cd64afbc2b17fff8b69">popMin</a> (list&lt; <a class="el" href="classIFMProofObligation.html">IFMProofObligation</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:a6bd825fad36c8cd64afbc2b17fff8b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a list of proof obligations and removes the element with lowest rank.  <a href="#a6bd825fad36c8cd64afbc2b17fff8b69"></a><br/></td></tr>
<tr class="memitem:a986f63c9895b2999fe2ed27e38df4b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a986f63c9895b2999fe2ed27e38df4b84">debugPrintRs</a> () const </td></tr>
<tr class="memdesc:a986f63c9895b2999fe2ed27e38df4b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">A debugging utility to print all frames.  <a href="#a986f63c9895b2999fe2ed27e38df4b84"></a><br/></td></tr>
<tr class="memitem:a3957fbd604e2a188e924f39d62c4cab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a3957fbd604e2a188e924f39d62c4cab4">debugCheckInvariants</a> (size_t k)</td></tr>
<tr class="memdesc:a3957fbd604e2a188e924f39d62c4cab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A debugging utility check invariants of the data structures.  <a href="#a3957fbd604e2a188e924f39d62c4cab4"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a10aead75cfca1b96cdd6c17f6825a9b7"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classCNF.html">CNF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a10aead75cfca1b96cdd6c17f6825a9b7">r_</a></td></tr>
<tr class="memdesc:a10aead75cfca1b96cdd6c17f6825a9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The frames R[] of the algorithm. Each frame represents a set of states in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>.  <a href="#a10aead75cfca1b96cdd6c17f6825a9b7"></a><br/></td></tr>
<tr class="memitem:a493a9f0a3f2880597a89d48766706099"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classCNF.html">CNF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a493a9f0a3f2880597a89d48766706099">u_</a></td></tr>
<tr class="memdesc:a493a9f0a3f2880597a89d48766706099"><td class="mdescLeft">&#160;</td><td class="mdescRight">The blocked transitions U[] of the algorithm.  <a href="#a493a9f0a3f2880597a89d48766706099"></a><br/></td></tr>
<tr class="memitem:ab6b54169dc042466704a4e6ceee4e94d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#ab6b54169dc042466704a4e6ceee4e94d">win_</a></td></tr>
<tr class="memdesc:ab6b54169dc042466704a4e6ceee4e94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current over-approximation of the winning region W (for the protagonist).  <a href="#ab6b54169dc042466704a4e6ceee4e94d"></a><br/></td></tr>
<tr class="memitem:a4b964deefde7cd2cc4d81c8ea6f66976"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classSatSolver.html">SatSolver</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a4b964deefde7cd2cc4d81c8ea6f66976">goto_next_lower_solvers_</a></td></tr>
<tr class="memdesc:a4b964deefde7cd2cc4d81c8ea6f66976"><td class="mdescLeft">&#160;</td><td class="mdescRight">The solvers storing the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: U[k] &amp; T &amp; R[k-1]'.  <a href="#a4b964deefde7cd2cc4d81c8ea6f66976"></a><br/></td></tr>
<tr class="memitem:a950a68d4f0efeca411ead2d4439aed9d"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classSatSolver.html">SatSolver</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a950a68d4f0efeca411ead2d4439aed9d">gen_block_trans_solvers_</a></td></tr>
<tr class="memdesc:a950a68d4f0efeca411ead2d4439aed9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The solvers storing the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: T &amp; R[k-1]'.  <a href="#a950a68d4f0efeca411ead2d4439aed9d"></a><br/></td></tr>
<tr class="memitem:a08f52e41085966317cfc516bd52dc3b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a08f52e41085966317cfc516bd52dc3b3">goto_win_solver_</a></td></tr>
<tr class="memdesc:a08f52e41085966317cfc516bd52dc3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A solver that stores the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: T &amp; W'.  <a href="#a08f52e41085966317cfc516bd52dc3b3"></a><br/></td></tr>
<tr class="memitem:a9b05f84db78c1ac1a2a8f74212f66c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a9b05f84db78c1ac1a2a8f74212f66c64">winning_region_</a></td></tr>
<tr class="memdesc:a9b05f84db78c1ac1a2a8f74212f66c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final winning region as computed by <a class="el" href="classIFM13Synth.html#a51c6831265e1daf7d0120c0dd954a0c4">computeWinningRegion</a>.  <a href="#a9b05f84db78c1ac1a2a8f74212f66c64"></a><br/></td></tr>
<tr class="memitem:a334e8e6b638c8c57da3db0c3d161231b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a334e8e6b638c8c57da3db0c3d161231b">neg_winning_region_</a></td></tr>
<tr class="memdesc:a334e8e6b638c8c57da3db0c3d161231b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The negated winning region as computed by <a class="el" href="classIFM13Synth.html#a51c6831265e1daf7d0120c0dd954a0c4">computeWinningRegion</a>.  <a href="#a334e8e6b638c8c57da3db0c3d161231b"></a><br/></td></tr>
<tr class="memitem:ac35a6617ca45b2aa1823c99ae7c984a4"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#ac35a6617ca45b2aa1823c99ae7c984a4">sin_</a></td></tr>
<tr class="memdesc:ac35a6617ca45b2aa1823c99ae7c984a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector of present- and next-state variables, and uncontrollable inputs.  <a href="#ac35a6617ca45b2aa1823c99ae7c984a4"></a><br/></td></tr>
<tr class="memitem:abb5b5fc0fe0db0e7aff06d22547e00bd"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#abb5b5fc0fe0db0e7aff06d22547e00bd">sicn_</a></td></tr>
<tr class="memdesc:abb5b5fc0fe0db0e7aff06d22547e00bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector of present- and next-state variables, and all inputs.  <a href="#abb5b5fc0fe0db0e7aff06d22547e00bd"></a><br/></td></tr>
<tr class="memitem:a1d87a79eab422a71fdc23f70d4279cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#a1d87a79eab422a71fdc23f70d4279cbd">impl_extractor_</a></td></tr>
<tr class="memdesc:a1d87a79eab422a71fdc23f70d4279cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The engine to use for circuit extraction.  <a href="#a1d87a79eab422a71fdc23f70d4279cbd"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aaa3a0095cffcd56cc6f13ba80362a589"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#aaa3a0095cffcd56cc6f13ba80362a589">IFM13Synth</a> (const <a class="el" href="classIFM13Synth.html">IFM13Synth</a> &amp;other)</td></tr>
<tr class="memdesc:aaa3a0095cffcd56cc6f13ba80362a589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aaa3a0095cffcd56cc6f13ba80362a589"></a><br/></td></tr>
<tr class="memitem:abbce31c761c00c1fca82f93dede10931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIFM13Synth.html">IFM13Synth</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFM13Synth.html#abbce31c761c00c1fca82f93dede10931">operator=</a> (const <a class="el" href="classIFM13Synth.html">IFM13Synth</a> &amp;other)</td></tr>
<tr class="memdesc:abbce31c761c00c1fca82f93dede10931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#abbce31c761c00c1fca82f93dede10931"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implements the SAT-based synthesis method published at IFM'13. </p>
<p>This class is a re-implementation of the SAT-based synthesis method published in the paper: "Andreas Morgenstern, Manuel Gesell, Klaus Schneider: Solving Games Using
Incremental Induction, IFM 2013, pages 177-191". It is based on the description given in the paper with only a few additional optimizations following the paper "Niklas Een, Alan Mishchenko, Robert K. Brayton: Efficient implementation of property
directed reachability, FMCAD 2011, pages 125-134". All these optimizations are clearly marked in the source code. In order to understand the code in this class, you should read the IFM'13 paper first. After that, you will find a one-to-one correspondence between the functions described in the paper and the methods of this class.</p>
<p>The IFM'13 publication only describes how to determine realizability, but not how extract a winning region from this computation. Our implementation also extracts a winning region (the set R[i] such that R[i] = R[i-1]).</p>
<dl class="section note"><dt>Note</dt><dd>This is not the original implementation of the IFM'13 paper, it is a re-implementation. The re-implementation is based on the paper only. The original implementation may contain more optimizations. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.1.0 </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00065">65</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae01ff6a7fb118c2ebdc04818ef59726b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IFM13Synth::IFM13Synth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td>
          <td class="paramname"><em>impl_extractor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl_extractor</td><td>The engine to use for circuit extraction. It will be deleted by this class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00054">54</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="IFM13Synth_8h_source.html#l00333">gen_block_trans_solvers_</a>, <a class="el" href="Options_8cpp_source.html#l00470">Options::getSATSolver()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="IFM13Synth_8h_source.html#l00324">goto_next_lower_solvers_</a>, <a class="el" href="IFM13Synth_8h_source.html#l00338">goto_win_solver_</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="IFM13Synth_8h_source.html#l00298">r_</a>, <a class="el" href="IFM13Synth_8h_source.html#l00358">sicn_</a>, <a class="el" href="IFM13Synth_8h_source.html#l00353">sin_</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="IFM13Synth_8h_source.html#l00308">u_</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00313">win_</a>.</p>

</div>
</div>
<a class="anchor" id="ad042200b1639e702af49e55088a52f52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IFM13Synth::~IFM13Synth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00103">103</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8h_source.html#l00333">gen_block_trans_solvers_</a>, <a class="el" href="IFM13Synth_8h_source.html#l00324">goto_next_lower_solvers_</a>, <a class="el" href="IFM13Synth_8h_source.html#l00338">goto_win_solver_</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00365">impl_extractor_</a>.</p>

</div>
</div>
<a class="anchor" id="aaa3a0095cffcd56cc6f13ba80362a589"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IFM13Synth::IFM13Synth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIFM13Synth.html">IFM13Synth</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a31eb626e5ca0232d187e3471e8fed348"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IFM13Synth::addBlockedState </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a state(-cube) from the frame R[level]. </p>
<p>This method updates R[level] := R[level] &amp; !state_cube. state_cube is a potentially incomplete state-cube. We also update the R-sets of all smaller levels in the same way for syntactic containment reasons (as described in the paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_cube</td><td>The state-cube that should be removed from R[level]. The cube is potentially incomplete, i.e., can represent a larger set of states. </td></tr>
    <tr><td class="paramname">level</td><td>The level in which the state should be blocked (i.e., removed form the corresponding frame R[level]). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00351">351</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00463">getGenBlockTransSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00451">getGotoNextLowerSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00435">getR()</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="IFM13Synth_8h_source.html#l00298">r_</a>, and <a class="el" href="Utils_8cpp_source.html#l00209">Utils::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="a0aa3bd29c1621efda5abb30dd9357214"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IFM13Synth::addBlockedTransition </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_in_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks a state-input-pair as blocked. </p>
<p>The meaning is: we want to store the fact that a certain state-input pair is not helpful for the antagonist (the party controlling the inputs i) in trying to move from R[level] to R[level-1]. Hence, we update U[level] := U[level] &amp; !state_in_cube. We also update the U-sets of all smaller levels in the same way for syntactic containment reasons (as described in the paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_in_cube</td><td>The state-input pair as a cube over present state variables and uncontrollable inputs. The cube is potentially incomplete, i.e., can represent a larger set of state-input pairs. </td></tr>
    <tr><td class="paramname">level</td><td>The level in which the transition should be blocked (i.e., the state-input pair should by marked as useless for the antagonist). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00336">336</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00451">getGotoNextLowerSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00443">getU()</a>, and <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00422">genAndBlockTrans()</a>.</p>

</div>
</div>
<a class="anchor" id="adf319a6748eda4aa29017a561752b262"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IFM13Synth::addLose </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_cube</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a state(-cube) from the current over-approximation of the winning region. </p>
<p>This method updates W := W &amp; !state_cube. state_cube is a potentially incomplete state-cube.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_cube</td><td>The state-cube that should be removed from the current over-approximation of the winning region. The cube is potentially incomplete, i.e., </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00405">405</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="IFM13Synth_8h_source.html#l00338">goto_win_solver_</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="Utils_8cpp_source.html#l00209">Utils::swapPresentToNext()</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00313">win_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="a51c6831265e1daf7d0120c0dd954a0c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IFM13Synth::computeWinningRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the set of states from which the specification can be fulfilled. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification is realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00145">145</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8cpp_source.html#l00502">debugCheckInvariants()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00435">getR()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00045">IS_LOSE</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="Logger_8h_source.html#l00336">L_LOG</a>, <a class="el" href="IFM13Synth_8h_source.html#l00348">neg_winning_region_</a>, <a class="el" href="CNF_8cpp_source.html#l00264">CNF::negate()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00177">propagateBlockedStates()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00343">winning_region_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00121">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a3957fbd604e2a188e924f39d62c4cab4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IFM13Synth::debugCheckInvariants </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A debugging utility check invariants of the data structures. </p>
<p>The checks are only performed in debug-mode. In release-mode, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The maximum level up until which the invariants should be checked. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00502">502</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="QBFSolver_8h_source.html#l00067">QBFSolver::A</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="QBFSolver_8h_source.html#l00062">QBFSolver::E</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00435">getR()</a>, <a class="el" href="Options_8cpp_source.html#l00470">Options::getSATSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00443">getU()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="DepQBFApi_8cpp_source.html#l00059">DepQBFApi::isSat()</a>, <a class="el" href="classSatSolver.html#a82f60f60db464fbe5c66a20ad673a573">SatSolver::isSat()</a>, <a class="el" href="defines_8h_source.html#l00059">MASSERT</a>, <a class="el" href="CNF_8cpp_source.html#l00264">CNF::negate()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00313">win_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00145">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="a986f63c9895b2999fe2ed27e38df4b84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IFM13Synth::debugPrintRs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A debugging utility to print all frames. </p>
<p>Do this for small examples only. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00492">492</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00298">r_</a>.</p>

</div>
</div>
<a class="anchor" id="a1edccb04c096bb68a6fb2a8245f3129b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IFM13Synth::genAndBlockTrans </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_in_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrl_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generalizes and excludes a blocked transition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_in_cube</td><td>The state-input cube (the transition) that should be generalized and and blocked. </td></tr>
    <tr><td class="paramname">ctrl_cube</td><td>The control signals that can be chosen by the protagonist in order to avoid ending up in R[level-1]. </td></tr>
    <tr><td class="paramname">level</td><td>The frame in which the transition should be blocked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if state_cube satisfies W, true otherwise. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00422">422</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8cpp_source.html#l00336">addBlockedTransition()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00463">getGenBlockTransSolver()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, and <a class="el" href="defines_8h_source.html#l00059">MASSERT</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="af087a4ddf9026bb48a752c03e539d9da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSatSolver.html">SatSolver</a> * IFM13Synth::getGenBlockTransSolver </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a solver with <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: T &amp; R[index-1]'. </p>
<p>This solver is used to generalize blocked transitions. If the solver for this index does not yet exists, it is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the requested solver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A solver with <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: T &amp; R[index-1]'. getGenBlockTransSolver(0) returns NULL. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00463">463</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8h_source.html#l00333">gen_block_trans_solvers_</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00358">sicn_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00351">addBlockedState()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00422">genAndBlockTrans()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00177">propagateBlockedStates()</a>.</p>

</div>
</div>
<a class="anchor" id="ae97c0b41568cf25e163ab9b309f0dcaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSatSolver.html">SatSolver</a> * IFM13Synth::getGotoNextLowerSolver </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a solver with <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: U[index] &amp; T &amp; R[index-1]'. </p>
<p>This solver is used to search for moves the antagonist can make in order to reach R[index-1]. If the solver for this index does not yet exists, it is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the requested solver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A solver with <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: U[index] &amp; T &amp; R[index-1]'. getGotoNextLowerSolver(0) returns NULL. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00451">451</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8h_source.html#l00324">goto_next_lower_solvers_</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00358">sicn_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00351">addBlockedState()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00336">addBlockedTransition()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00177">propagateBlockedStates()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="a050f0c3c5089ef6c5f793878bd60abc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> &amp; IFM13Synth::getR </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the frame R[index] in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. </p>
<p>If the frame with this index does not yet exists, it is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the requested frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frame R[index] in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00435">435</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8h_source.html#l00298">r_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00351">addBlockedState()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00145">computeWinningRegion()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00502">debugCheckInvariants()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00399">isBlocked()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00177">propagateBlockedStates()</a>.</p>

</div>
</div>
<a class="anchor" id="a396e520b9db59b73a46a2315ee3123b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> &amp; IFM13Synth::getU </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the blocked transitions U[index] in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. </p>
<p>If the set of blocked transitions with this index does not yet exists, it is created. This function is actually only needed for debugging purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the requested set of blocked transitions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set U[index] of blocked transitions in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00443">443</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8h_source.html#l00308">u_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00336">addBlockedTransition()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00502">debugCheckInvariants()</a>.</p>

</div>
</div>
<a class="anchor" id="a27c2617424cad795b9af575a85e75071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IFM13Synth::isBlocked </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a state is contained in a certain frame. </p>
<p>The passed state cube is complete, i.e., contains all state variables. Hence, containment can be (and is) checked syntactically. We simply check if state_cube satisfies all clauses of R[level].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_cube</td><td>A full cube over the present state variables. </td></tr>
    <tr><td class="paramname">level</td><td>The index i of a certain frame R[i]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if state_cube satisfies R[level], true otherwise. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00399">399</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8cpp_source.html#l00435">getR()</a>, and <a class="el" href="CNF_8cpp_source.html#l00395">CNF::isSatBy()</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="aca85bf07810f6c8cc3c3125895daf56f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IFM13Synth::isLose </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_cube</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a state satisfies the current over-approximation of the winning region. </p>
<p>The passed state cube is complete, i.e., contains all state variables. Hence, containment can be (and is) checked syntactically. We simply check if state_cube satisfies all clauses of W (stored in <a class="el" href="classIFM13Synth.html#ab6b54169dc042466704a4e6ceee4e94d">win_ </a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_cube</td><td>A full cube over the present state variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if state_cube satisfies W, true otherwise. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00416">416</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00395">CNF::isSatBy()</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00313">win_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="abbce31c761c00c1fca82f93dede10931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIFM13Synth.html">IFM13Synth</a>&amp; IFM13Synth::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIFM13Synth.html">IFM13Synth</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bd825fad36c8cd64afbc2b17fff8b69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIFMProofObligation.html">IFMProofObligation</a> IFM13Synth::popMin </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classIFMProofObligation.html">IFMProofObligation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a list of proof obligations and removes the element with lowest rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A list of proof obligations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element that has been removed from the list. It is always the element (among the elements) with minimal rank. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00475">475</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="defines_8h_source.html#l00059">MASSERT</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9262224ce1ddbda37d748fbecfe5d8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t IFM13Synth::propagateBlockedStates </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Propagates clauses forward and searches for equivalent clause sets. </p>
<p>Similar to IC3, this method propagates clauses of frames forward. It also checks if two adjacent clauses sets become syntactically equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_level</td><td>The maximum frame level until which propagation should be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number N returned by this method has the following meaning: N=0 means that no equal clause sets have been found. N &gt; 0 means that R[N] = R[N-1]. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00177">177</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00346">CNF::getClauses()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00463">getGenBlockTransSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00451">getGotoNextLowerSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00435">getR()</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="CNF_8cpp_source.html#l00384">CNF::removeDuplicates()</a>, <a class="el" href="Utils_8cpp_source.html#l00209">Utils::swapPresentToNext()</a>, and <a class="el" href="CNF_8cpp_source.html#l00286">CNF::swapWith()</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00145">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="af46e431e089225b58148ee317d523123"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IFM13Synth::recBlockCube </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyzes the rank of the passed state. </p>
<p>There are two possible conclusions: (a) the rank of the state is &gt; level, (b) the rank of the state is &lt;= level. In order to analyze a certain state, this method may analyze some of its successor states first (using a queue of proof obligations internally). This method is always called for the initial state only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_cube</td><td>A full cube over the state variables, describing the state that should be analyzed. </td></tr>
    <tr><td class="paramname">level</td><td>The level for the analysis (this method checks if the rank of the state is &gt; level or &lt;= level). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IS_GREATER (an alias for true) if the rank of the state is &gt; level. IS_LOSE (an alias for false) otherwise. </dd></dl>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00229">229</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8cpp_source.html#l00351">addBlockedState()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00405">addLose()</a>, <a class="el" href="Utils_8cpp_source.html#l00041">Utils::containsInit()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Utils_8cpp_source.html#l00063">Utils::extract()</a>, <a class="el" href="Utils_8cpp_source.html#l00124">Utils::extractNextAsPresent()</a>, <a class="el" href="Utils_8cpp_source.html#l00086">Utils::extractPresIn()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00422">genAndBlockTrans()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00451">getGotoNextLowerSolver()</a>, <a class="el" href="IFMProofObligation_8cpp_source.html#l00086">IFMProofObligation::getLevel()</a>, <a class="el" href="IFMProofObligation_8cpp_source.html#l00104">IFMProofObligation::getPreCtrlCube()</a>, <a class="el" href="IFMProofObligation_8cpp_source.html#l00098">IFMProofObligation::getPreStateInCube()</a>, <a class="el" href="IFMProofObligation_8cpp_source.html#l00080">IFMProofObligation::getState()</a>, <a class="el" href="IFM13Synth_8h_source.html#l00338">goto_win_solver_</a>, <a class="el" href="IFMProofObligation_8cpp_source.html#l00092">IFMProofObligation::hasPre()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00051">IS_GREATER</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00045">IS_LOSE</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00399">isBlocked()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00416">isLose()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00475">popMin()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="IFM13Synth_8h_source.html#l00358">sicn_</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00353">sin_</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00145">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="a42adb4f76d88199d92b1bedb58a139f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IFM13Synth::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the back-end (which is implemented as described in the IFM'13 paper). </p>
<p>This method is the workhorse of this class. It implements the SAT-based synthesis method published in the paper: "Andreas Morgenstern, Manuel Gesell, Klaus Schneider: Solving
Games Using Incremental Induction, IFM 2013, pages 177-191". It is based on the description given in the paper with only a few additional optimizations following the paper "Niklas Een, Alan Mishchenko, Robert K. Brayton: Efficient implementation of
property directed reachability, FMCAD 2011, pages 125-134". All these optimizations are clearly marked in the source code. In order to understand the code in this class, you should read the IFM'13 paper first. After that, you will find a one-to-one correspondence between the functions described in the paper and the methods of this class.</p>
<p>The IFM'13 publication only describes how to determine realizability, but not how extract a winning region from this computation. Our implementation also extracts a winning region (the set R[i] such that R[i] = R[i-1]).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classBackEnd.html#a099e717dc71e9cc2d838b1ca86340590">BackEnd</a>.</p>

<p>Definition at line <a class="el" href="IFM13Synth_8cpp_source.html#l00121">121</a> of file <a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a>.</p>

<p>References <a class="el" href="IFM13Synth_8cpp_source.html#l00145">computeWinningRegion()</a>, <a class="el" href="Utils_8cpp_source.html#l00407">Utils::debugCheckWinReg()</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">CNFImplExtractor::extractCircuit()</a>, <a class="el" href="IFM13Synth_8h_source.html#l00365">impl_extractor_</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="Logger_8h_source.html#l00302">L_INF</a>, <a class="el" href="Logger_8h_source.html#l00285">L_RES</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00290">CNFImplExtractor::logStatistics()</a>, <a class="el" href="IFM13Synth_8h_source.html#l00348">neg_winning_region_</a>, and <a class="el" href="IFM13Synth_8h_source.html#l00343">winning_region_</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="a950a68d4f0efeca411ead2d4439aed9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classSatSolver.html">SatSolver</a>*&gt; IFM13Synth::gen_block_trans_solvers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The solvers storing the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: T &amp; R[k-1]'. </p>
<p>You should use <a class="el" href="classIFM13Synth.html#af087a4ddf9026bb48a752c03e539d9da">getGenBlockTransSolver() </a> to access these solvers. The reason is that this method initializes the solvers if they do not yet exist. gen_block_trans_solvers_[0] is always NULL. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00333">333</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00463">getGenBlockTransSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00103">~IFM13Synth()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b964deefde7cd2cc4d81c8ea6f66976"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classSatSolver.html">SatSolver</a>*&gt; IFM13Synth::goto_next_lower_solvers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The solvers storing the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: U[k] &amp; T &amp; R[k-1]'. </p>
<p>These solvers are used to search for moves the antagonist can make in order to reach R[k-1]. You should use <a class="el" href="classIFM13Synth.html#ae97c0b41568cf25e163ab9b309f0dcaa">getGotoNextLowerSolver() </a> to access these solvers. The reason is that this method initializes the solvers if they do not yet exist. goto_next_lower_solvers_[0] is always NULL. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00324">324</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00451">getGotoNextLowerSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00103">~IFM13Synth()</a>.</p>

</div>
</div>
<a class="anchor" id="a08f52e41085966317cfc516bd52dc3b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSatSolver.html">SatSolver</a>* IFM13Synth::goto_win_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A solver that stores the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>: T &amp; W'. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00338">338</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00405">addLose()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00103">~IFM13Synth()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d87a79eab422a71fdc23f70d4279cbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a>* IFM13Synth::impl_extractor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The engine to use for circuit extraction. </p>
<p>It will be deleted by this class (in the destructor). </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00365">365</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00121">run()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00103">~IFM13Synth()</a>.</p>

</div>
</div>
<a class="anchor" id="a334e8e6b638c8c57da3db0c3d161231b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> IFM13Synth::neg_winning_region_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The negated winning region as computed by <a class="el" href="classIFM13Synth.html#a51c6831265e1daf7d0120c0dd954a0c4">computeWinningRegion</a>. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00348">348</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00145">computeWinningRegion()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00121">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a10aead75cfca1b96cdd6c17f6825a9b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classCNF.html">CNF</a>&gt; IFM13Synth::r_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The frames R[] of the algorithm. Each frame represents a set of states in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. </p>
<p>You should use <a class="el" href="classIFM13Synth.html#a050f0c3c5089ef6c5f793878bd60abc9">getR() </a> to access the frames. The reason is that this method initializes frames if they do not yet exist. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00298">298</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00351">addBlockedState()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00492">debugPrintRs()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00435">getR()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth()</a>.</p>

</div>
</div>
<a class="anchor" id="abb5b5fc0fe0db0e7aff06d22547e00bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; IFM13Synth::sicn_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vector of present- and next-state variables, and all inputs. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00358">358</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00463">getGenBlockTransSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00451">getGotoNextLowerSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="ac35a6617ca45b2aa1823c99ae7c984a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; IFM13Synth::sin_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vector of present- and next-state variables, and uncontrollable inputs. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00353">353</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00229">recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="a493a9f0a3f2880597a89d48766706099"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classCNF.html">CNF</a>&gt; IFM13Synth::u_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The blocked transitions U[] of the algorithm. </p>
<p>These sets are maintained only in debug mode. In release-mode they are only present inside the goto_next_lower_solvers_. You should use <a class="el" href="classIFM13Synth.html#a396e520b9db59b73a46a2315ee3123b4">getU() </a> to access the frames. The reason is that this method initializes elements if they do not yet exist. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00308">308</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00443">getU()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6b54169dc042466704a4e6ceee4e94d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> IFM13Synth::win_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current over-approximation of the winning region W (for the protagonist). </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00313">313</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00405">addLose()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00502">debugCheckInvariants()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00416">isLose()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b05f84db78c1ac1a2a8f74212f66c64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> IFM13Synth::winning_region_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The final winning region as computed by <a class="el" href="classIFM13Synth.html#a51c6831265e1daf7d0120c0dd954a0c4">computeWinningRegion</a>. </p>

<p>Definition at line <a class="el" href="IFM13Synth_8h_source.html#l00343">343</a> of file <a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00145">computeWinningRegion()</a>, and <a class="el" href="IFM13Synth_8cpp_source.html#l00121">run()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="IFM13Synth_8h_source.html">IFM13Synth.h</a></li>
<li>src/<a class="el" href="IFM13Synth_8cpp_source.html">IFM13Synth.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 15 2014 12:30:21 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
