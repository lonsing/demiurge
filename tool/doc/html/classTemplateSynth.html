<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>demiurge: TemplateSynth Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classTemplateSynth-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TemplateSynth Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a template-based synthesis using a QBF solver.  
 <a href="classTemplateSynth.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TemplateSynth_8h_source.html">TemplateSynth.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TemplateSynth:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classTemplateSynth.png" usemap="#TemplateSynth_map" alt=""/>
  <map id="TemplateSynth_map" name="TemplateSynth_map">
<area href="classBackEnd.html" title="An interface for the back-ends. " alt="BackEnd" shape="rect" coords="0,0,94,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a56d5f285781e5871bf391acc38acb0aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a56d5f285781e5871bf391acc38acb0aa">TemplateSynth</a> (<a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *impl_extractor)</td></tr>
<tr class="memdesc:a56d5f285781e5871bf391acc38acb0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a56d5f285781e5871bf391acc38acb0aa">More...</a><br/></td></tr>
<tr class="separator:a56d5f285781e5871bf391acc38acb0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d540c9d4dc6696b53768a27ac74c569"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a5d540c9d4dc6696b53768a27ac74c569">~TemplateSynth</a> ()</td></tr>
<tr class="memdesc:a5d540c9d4dc6696b53768a27ac74c569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5d540c9d4dc6696b53768a27ac74c569">More...</a><br/></td></tr>
<tr class="separator:a5d540c9d4dc6696b53768a27ac74c569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad9855736c7d4dfdec08280d2424f80"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a5ad9855736c7d4dfdec08280d2424f80">run</a> ()</td></tr>
<tr class="memdesc:a5ad9855736c7d4dfdec08280d2424f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes this back-end.  <a href="#a5ad9855736c7d4dfdec08280d2424f80">More...</a><br/></td></tr>
<tr class="separator:a5ad9855736c7d4dfdec08280d2424f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae334e4a6c30a324cfd4d0c05a32b191c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#ae334e4a6c30a324cfd4d0c05a32b191c">computeWinningRegion</a> ()</td></tr>
<tr class="memdesc:ae334e4a6c30a324cfd4d0c05a32b191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region as instantiation of a generic template.  <a href="#ae334e4a6c30a324cfd4d0c05a32b191c">More...</a><br/></td></tr>
<tr class="separator:ae334e4a6c30a324cfd4d0c05a32b191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe9f11a75e689fd631692feac4031a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#affe9f11a75e689fd631692feac4031a1">computeWinningRegionCNF</a> ()</td></tr>
<tr class="memdesc:affe9f11a75e689fd631692feac4031a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region as instantiation of a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> template.  <a href="#affe9f11a75e689fd631692feac4031a1">More...</a><br/></td></tr>
<tr class="separator:affe9f11a75e689fd631692feac4031a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9197dff7678cd88a7fea3c6b4358f85d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a9197dff7678cd88a7fea3c6b4358f85d">computeWinningRegionAndNet</a> ()</td></tr>
<tr class="memdesc:a9197dff7678cd88a7fea3c6b4358f85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region as instantiation of a network of AND-Gates.  <a href="#a9197dff7678cd88a7fea3c6b4358f85d">More...</a><br/></td></tr>
<tr class="separator:a9197dff7678cd88a7fea3c6b4358f85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499d1c0069b41ce11a6c7e7679fd4ece"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a499d1c0069b41ce11a6c7e7679fd4ece">findWinRegCNFTempl</a> (size_t nr_of_clauses)</td></tr>
<tr class="memdesc:a499d1c0069b41ce11a6c7e7679fd4ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region as instantiation of a generic <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> template.  <a href="#a499d1c0069b41ce11a6c7e7679fd4ece">More...</a><br/></td></tr>
<tr class="separator:a499d1c0069b41ce11a6c7e7679fd4ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1084d7b10de86dfbbe1368c68d4c0501"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a1084d7b10de86dfbbe1368c68d4c0501">findWinRegANDNetwork</a> (size_t nr_of_gates)</td></tr>
<tr class="memdesc:a1084d7b10de86dfbbe1368c68d4c0501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region as instantiation of a generic AIGER template.  <a href="#a1084d7b10de86dfbbe1368c68d4c0501">More...</a><br/></td></tr>
<tr class="separator:a1084d7b10de86dfbbe1368c68d4c0501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01c9c2463c59f14f109e9379219535b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#ae01c9c2463c59f14f109e9379219535b">syntQBF</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_constr, int w1, int w2, vector&lt; int &gt; &amp;solution)</td></tr>
<tr class="memdesc:ae01c9c2463c59f14f109e9379219535b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves the template by calling a QBF solver.  <a href="#ae01c9c2463c59f14f109e9379219535b">More...</a><br/></td></tr>
<tr class="separator:ae01c9c2463c59f14f109e9379219535b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f140f63502de21ab260b5cae9335cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#aa0f140f63502de21ab260b5cae9335cb">syntSAT</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_constr, int w1, int w2, vector&lt; int &gt; &amp;solution)</td></tr>
<tr class="memdesc:aa0f140f63502de21ab260b5cae9335cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves the template by calling a SAT solver in a CEGIS loop.  <a href="#aa0f140f63502de21ab260b5cae9335cb">More...</a><br/></td></tr>
<tr class="separator:aa0f140f63502de21ab260b5cae9335cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55609e303daffb4d51b27380d32ddb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#af55609e303daffb4d51b27380d32ddb3">exclude</a> (const vector&lt; int &gt; &amp;ce, const <a class="el" href="classCNF.html">CNF</a> &amp;gen)</td></tr>
<tr class="memdesc:af55609e303daffb4d51b27380d32ddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for the CEGIS loop of <a class="el" href="classTemplateSynth.html#aa0f140f63502de21ab260b5cae9335cb" title="Resolves the template by calling a SAT solver in a CEGIS loop. ">syntSAT()</a>, eliminating a counterexample.  <a href="#af55609e303daffb4d51b27380d32ddb3">More...</a><br/></td></tr>
<tr class="separator:af55609e303daffb4d51b27380d32ddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e841e4eb71a5286057afbeac42c7a47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a3e841e4eb71a5286057afbeac42c7a47">check</a> (const vector&lt; int &gt; &amp;cand, const <a class="el" href="classCNF.html">CNF</a> &amp;win_constr, int w1, int w2, vector&lt; int &gt; &amp;ce)</td></tr>
<tr class="memdesc:a3e841e4eb71a5286057afbeac42c7a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for the CEGIS loop of <a class="el" href="classTemplateSynth.html#aa0f140f63502de21ab260b5cae9335cb" title="Resolves the template by calling a SAT solver in a CEGIS loop. ">syntSAT()</a>, checking if a candidate solution works.  <a href="#a3e841e4eb71a5286057afbeac42c7a47">More...</a><br/></td></tr>
<tr class="separator:a3e841e4eb71a5286057afbeac42c7a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4e147629eae6a542dd87d72902df68c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a4e147629eae6a542dd87d72902df68c8">winning_region_</a></td></tr>
<tr class="memdesc:a4e147629eae6a542dd87d72902df68c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resulting winning region.  <a href="#a4e147629eae6a542dd87d72902df68c8">More...</a><br/></td></tr>
<tr class="separator:a4e147629eae6a542dd87d72902df68c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49665461c82781b823b3da04057fdab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a49665461c82781b823b3da04057fdab2">neg_winning_region_</a></td></tr>
<tr class="memdesc:a49665461c82781b823b3da04057fdab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The negation of the resulting winning region.  <a href="#a49665461c82781b823b3da04057fdab2">More...</a><br/></td></tr>
<tr class="separator:a49665461c82781b823b3da04057fdab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ec20197bf16a10546a7e6cf3719727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQBFSolver.html">QBFSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a08ec20197bf16a10546a7e6cf3719727">qbf_solver_</a></td></tr>
<tr class="memdesc:a08ec20197bf16a10546a7e6cf3719727"><td class="mdescLeft">&#160;</td><td class="mdescRight">The QBF-solver to use for solving the queries.  <a href="#a08ec20197bf16a10546a7e6cf3719727">More...</a><br/></td></tr>
<tr class="separator:a08ec20197bf16a10546a7e6cf3719727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7844e9296d63b10e3fa96d66b932660f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#a7844e9296d63b10e3fa96d66b932660f">sat_solver_</a></td></tr>
<tr class="memdesc:a7844e9296d63b10e3fa96d66b932660f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SAT-solver to use if we resolve the template using the CEGIS loop.  <a href="#a7844e9296d63b10e3fa96d66b932660f">More...</a><br/></td></tr>
<tr class="separator:a7844e9296d63b10e3fa96d66b932660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa25deb001fb3b6d49c0261bba98347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTemplateSynth.html#acfa25deb001fb3b6d49c0261bba98347">impl_extractor_</a></td></tr>
<tr class="memdesc:acfa25deb001fb3b6d49c0261bba98347"><td class="mdescLeft">&#160;</td><td class="mdescRight">The engine to use for circuit extraction.  <a href="#acfa25deb001fb3b6d49c0261bba98347">More...</a><br/></td></tr>
<tr class="separator:acfa25deb001fb3b6d49c0261bba98347"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements a template-based synthesis using a QBF solver. </p>
<p>We are searching for a winning region W(x) such that: </p>
<ol>
<li>
I(x) =&gt; W(x): every initial state is contained in the winning region </li>
<li>
W(x) =&gt; P(x): every state of the winning region is safe </li>
<li>
forall x,i: exists c,x': W(x) =&gt; (T(x,i,c,x') &amp; W(x')): from every state in the winning region we can enforce to stay in the winning region by setting the c-signals appropriately. </li>
</ol>
<p>In this class, we encode the search for such a winning region symbolically. We define a template W(x,k) for the winning region. The variables k are template parameters. Their values define a concrete function W(x). Then we simply solve the query <br/>
 &#160; exists k: forall x,i: exists c,x': I(x) =&gt; W(x,k) &amp; W(x,k) =&gt; P(x) &amp; W(x,k) =&gt; (T(x,i,c,x') &amp; W(x',k)) <br/>
 with a single QBF-solver call. We ask the solver for a satisfying assignment to the variables k. These values define a concrete function W(x), which is our winning region. The difficult question is how to define a generic template W(x,k) for the winning region. At the moment, only two possibility is implemented: </p>
<ul>
<li>
defining W(x,k) as a parameterized <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the state variables x with parameters k. </li>
<li>
defining W(x,k) as a parameterized AIGER graph over the state variables x with parameters k </li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.2.0 </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8h_source.html#l00073">73</a> of file <a class="el" href="TemplateSynth_8h_source.html">TemplateSynth.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a56d5f285781e5871bf391acc38acb0aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TemplateSynth::TemplateSynth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td>
          <td class="paramname"><em>impl_extractor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl_extractor</td><td>The engine to use for circuit extraction. It will be deleted by this class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00044">44</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d540c9d4dc6696b53768a27ac74c569"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TemplateSynth::~TemplateSynth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00054">54</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="TemplateSynth_8h_source.html#l00290">impl_extractor_</a>, <a class="el" href="TemplateSynth_8h_source.html#l00278">qbf_solver_</a>, and <a class="el" href="TemplateSynth_8h_source.html#l00283">sat_solver_</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3e841e4eb71a5286057afbeac42c7a47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::check </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper for the CEGIS loop of <a class="el" href="classTemplateSynth.html#aa0f140f63502de21ab260b5cae9335cb" title="Resolves the template by calling a SAT solver in a CEGIS loop. ">syntSAT()</a>, checking if a candidate solution works. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cand</td><td>A canidate solution in the form of concrete values for the template parameters. </td></tr>
    <tr><td class="paramname">win_constr</td><td><a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> constraints that constitute a correct solution for the winning region using the generic template. Essentially, three constraints are encoded in this <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>: <ol>
<li>
I(x) =&gt; W(x): every initial state is contained in the winning region </li>
<li>
W(x) =&gt; P(x): every state of the winning region is safe </li>
<li>
forall x,i: exists c,x': W(x) =&gt; (T(x,i,c,x') &amp; W(x')): from every state in the winning region we can enforce to stay in the winning region by setting the c-signals appropriately. </li>
</ol>
</td></tr>
    <tr><td class="paramname">w1</td><td>The literal that represents the present-state copy of the winning region in win_constr. </td></tr>
    <tr><td class="paramname">w2</td><td>The literal that represents the next-state copy of the winning region in win_constr. </td></tr>
    <tr><td class="paramname">ce</td><td>An empty vector. If the candidate solution is incorrect, a counterexample in the form of concrete values for state and input variables for which we fall out of the winning region is stored in this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the candidate solution is correct, False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00659">659</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00169">CNF::add1LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Options_8cpp_source.html#l00510">Options::getSATSolver()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, and <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00607">syntSAT()</a>.</p>

</div>
</div>
<a class="anchor" id="ae334e4a6c30a324cfd4d0c05a32b191c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::computeWinningRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region as instantiation of a generic template. </p>
<p>This works as explained in the description of the class.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00093">93</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="TemplateSynth_8cpp_source.html#l00132">computeWinningRegionAndNet()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00102">computeWinningRegionCNF()</a>, and <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00067">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a9197dff7678cd88a7fea3c6b4358f85d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::computeWinningRegionAndNet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region as instantiation of a network of AND-Gates. </p>
<p>This works as explained in the description of the class using a AIGER graph template W(x,k) for the winning region W(x), where k are template parameters defining how the winning region really looks like. The AIGER template fixes a maximum number N of AND-gates. For the first AND-gate we have template parameters saying (a) which state variables x are an input for the AND gate, and (b) which state variables are connected in negated and unnegated form. The second AND gate is similar but has the output of the first AND gate as additional input. The third AND gate has the outputs of the previous two as inputs, and so on. One final template parameter defines whether or not the output of the last AND gate forms W(x) or the negation of W(x).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00132">132</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="TemplateSynth_8cpp_source.html#l00335">findWinRegANDNetwork()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Logger_8h_source.html#l00302">L_INF</a>, <a class="el" href="Logger_8h_source.html#l00336">L_LOG</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, and <a class="el" href="VarManager_8cpp_source.html#l00063">VarManager::resetToLastPush()</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00093">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="affe9f11a75e689fd631692feac4031a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::computeWinningRegionCNF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region as instantiation of a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> template. </p>
<p>This works as explained in the description of the class using a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> template W(x,k) for the winning region W(x), where k are template parameters defining how the winning region really looks like. The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> template fixes a maximum number N of clauses. It has three groups of parameters. </p>
<ul>
<li>
The parameters kc[i] (with 1 &lt;= i &lt;= N) define if clause i occurs in the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> or not. </li>
<li>
The parameters kv[i][j] (with 1 &lt;= i &lt;= N, 1 &lt;= j &lt;= |x|) define if state variable xj occurs in clause i or not. </li>
<li>
The parameters kn[i][j] (with 1 &lt;= i &lt;= N, 1 &lt;= j &lt;= |x|) define if state variable xj occurs in clause i only negated or unnegated. If kv[i][j]=false, then kn[i][j] is irrelevant. </li>
</ul>
<p>The union of all these parameters forms k. Concrete values for all k define a concrete <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> formula over the state variables x (i.e., a concrete winning region). We chose N in the following way: we start with N=1. On failure, we increase N (multiply by 4).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00102">102</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="TemplateSynth_8cpp_source.html#l00162">findWinRegCNFTempl()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Logger_8h_source.html#l00302">L_INF</a>, <a class="el" href="Logger_8h_source.html#l00336">L_LOG</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, and <a class="el" href="VarManager_8cpp_source.html#l00063">VarManager::resetToLastPush()</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00093">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="af55609e303daffb4d51b27380d32ddb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TemplateSynth::exclude </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper for the CEGIS loop of <a class="el" href="classTemplateSynth.html#aa0f140f63502de21ab260b5cae9335cb" title="Resolves the template by calling a SAT solver in a CEGIS loop. ">syntSAT()</a>, eliminating a counterexample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>A counterexample that has been computed previously by calling <a class="el" href="classTemplateSynth.html#a3e841e4eb71a5286057afbeac42c7a47" title="A helper for the CEGIS loop of syntSAT(), checking if a candidate solution works. ...">check()</a>. A counterexample is simply a set of values for state variables and input variables for which we fall out of the winning region. </td></tr>
    <tr><td class="paramname">gen</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> containing the constraints for a correct winning region. We simply add constraints here saying that the winning region must now also work for the counterexample. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00734">734</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00571">CNF::appendVarsTo()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00267">VarManager::getInfo()</a>, <a class="el" href="VarInfo_8cpp_source.html#l00087">VarInfo::getKind()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="CNF_8cpp_source.html#l00528">CNF::renameVars()</a>, <a class="el" href="TemplateSynth_8h_source.html#l00283">sat_solver_</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, and <a class="el" href="VarInfo_8h_source.html#l00088">VarInfo::TEMPL_PARAMS</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00607">syntSAT()</a>.</p>

</div>
</div>
<a class="anchor" id="a1084d7b10de86dfbbe1368c68d4c0501"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::findWinRegANDNetwork </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr_of_gates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region as instantiation of a generic AIGER template. </p>
<p>This works as explained in the description of <a class="el" href="classTemplateSynth.html#a9197dff7678cd88a7fea3c6b4358f85d" title="Computes the winning region as instantiation of a network of AND-Gates. ">computeWinningRegionAndNet()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr_of_gates</td><td>The number N of gates to use in the template. Choosing a good value for this parameter is difficult. If it is chosen to low, then we may not find a solution even if one exists. If it is chosen to high, then we waste computational resources. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a solution is found with the given number of clauses, false otherwise. If this method returns false, then this does not mean that the specification is unrealizable. It may be that nr_of_gates has been chosen too low. </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00335">335</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00169">CNF::add1LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00196">CNF::add4LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="VarManager_8cpp_source.html#l00235">VarManager::createFreshTemplParam()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00326">VarManager::getNextErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00320">VarManager::getPresErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="TemplateSynth_8h_source.html#l00273">neg_winning_region_</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="VarManager_8cpp_source.html#l00063">VarManager::resetToLastPush()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00575">syntQBF()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00607">syntSAT()</a>, <a class="el" href="VarInfo_8h_source.html#l00088">VarInfo::TEMPL_PARAMS</a>, and <a class="el" href="TemplateSynth_8h_source.html#l00268">winning_region_</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00132">computeWinningRegionAndNet()</a>.</p>

</div>
</div>
<a class="anchor" id="a499d1c0069b41ce11a6c7e7679fd4ece"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::findWinRegCNFTempl </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr_of_clauses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region as instantiation of a generic <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> template. </p>
<p>This works as explained in the description of <a class="el" href="classTemplateSynth.html#affe9f11a75e689fd631692feac4031a1" title="Computes the winning region as instantiation of a CNF template. ">computeWinningRegionCNF()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr_of_clauses</td><td>The number N of clauses to use in the template. Choosing a good value for this parameter is difficult. If it is chosen to low, then we may not find a solution even if one exists. If it is chosen to high, then we waste computational resources. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a solution is found with the given number of clauses, false otherwise. If this method returns false, then this does not mean that the specification is unrealizable. It may be that nr_of_clauses has been chosen too low. </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00162">162</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00169">CNF::add1LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00196">CNF::add4LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="VarManager_8cpp_source.html#l00235">VarManager::createFreshTemplParam()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00326">VarManager::getNextErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00320">VarManager::getPresErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="TemplateSynth_8h_source.html#l00273">neg_winning_region_</a>, <a class="el" href="CNF_8cpp_source.html#l00272">CNF::negate()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="VarManager_8cpp_source.html#l00063">VarManager::resetToLastPush()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00575">syntQBF()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00607">syntSAT()</a>, and <a class="el" href="TemplateSynth_8h_source.html#l00268">winning_region_</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00102">computeWinningRegionCNF()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ad9855736c7d4dfdec08280d2424f80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes this back-end. </p>
<p>The back-end works as explained in the description of the class.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classBackEnd.html#a099e717dc71e9cc2d838b1ca86340590">BackEnd</a>.</p>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00067">67</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="TemplateSynth_8cpp_source.html#l00093">computeWinningRegion()</a>, <a class="el" href="Utils_8cpp_source.html#l00645">Utils::debugCheckWinReg()</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">CNFImplExtractor::extractCircuit()</a>, <a class="el" href="TemplateSynth_8h_source.html#l00290">impl_extractor_</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="Logger_8h_source.html#l00302">L_INF</a>, <a class="el" href="Logger_8h_source.html#l00285">L_RES</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00290">CNFImplExtractor::logStatistics()</a>, <a class="el" href="TemplateSynth_8h_source.html#l00273">neg_winning_region_</a>, <a class="el" href="VarManager_8cpp_source.html#l00055">VarManager::push()</a>, and <a class="el" href="TemplateSynth_8h_source.html#l00268">winning_region_</a>.</p>

</div>
</div>
<a class="anchor" id="ae01c9c2463c59f14f109e9379219535b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::syntQBF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolves the template by calling a QBF solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_constr</td><td><a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> constraints that constitute a correct solution for the winning region using the generic template. Essentially, three constraints are encoded in this <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>: <ol>
<li>
I(x) =&gt; W(x): every initial state is contained in the winning region </li>
<li>
W(x) =&gt; P(x): every state of the winning region is safe </li>
<li>
forall x,i: exists c,x': W(x) =&gt; (T(x,i,c,x') &amp; W(x')): from every state in the winning region we can enforce to stay in the winning region by setting the c-signals appropriately. </li>
</ol>
</td></tr>
    <tr><td class="paramname">w1</td><td>The literal that represents the present-state copy of the winning region in win_constr. </td></tr>
    <tr><td class="paramname">w2</td><td>The literal that represents the next-state copy of the winning region in win_constr. </td></tr>
    <tr><td class="paramname">solution</td><td>An empty vector. If a solution exists, then the corresponding template parameter values are written into this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a solution exists, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00575">575</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="QBFSolver_8h_source.html#l00067">QBFSolver::A</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="QBFSolver_8h_source.html#l00062">QBFSolver::E</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00235">AIG2CNF::getT()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00229">AIG2CNF::getTransEqT()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="classQBFSolver.html#a76fc0c757a2c039816e3e06547f06d5c">QBFSolver::isSatModel()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="TemplateSynth_8h_source.html#l00278">qbf_solver_</a>, <a class="el" href="VarInfo_8h_source.html#l00088">VarInfo::TEMPL_PARAMS</a>, and <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00335">findWinRegANDNetwork()</a>, and <a class="el" href="TemplateSynth_8cpp_source.html#l00162">findWinRegCNFTempl()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0f140f63502de21ab260b5cae9335cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TemplateSynth::syntSAT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolves the template by calling a SAT solver in a CEGIS loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_constr</td><td><a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> constraints that constitute a correct solution for the winning region using the generic template. Essentially, three constraints are encoded in this <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>: <ol>
<li>
I(x) =&gt; W(x): every initial state is contained in the winning region </li>
<li>
W(x) =&gt; P(x): every state of the winning region is safe </li>
<li>
forall x,i: exists c,x': W(x) =&gt; (T(x,i,c,x') &amp; W(x')): from every state in the winning region we can enforce to stay in the winning region by setting the c-signals appropriately. </li>
</ol>
</td></tr>
    <tr><td class="paramname">w1</td><td>The literal that represents the present-state copy of the winning region in win_constr. </td></tr>
    <tr><td class="paramname">w2</td><td>The literal that represents the next-state copy of the winning region in win_constr. </td></tr>
    <tr><td class="paramname">solution</td><td>An empty vector. If a solution exists, then the corresponding template parameter values are written into this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a solution exists, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TemplateSynth_8cpp_source.html#l00607">607</a> of file <a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00659">check()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00734">exclude()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="TemplateSynth_8h_source.html#l00283">sat_solver_</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, and <a class="el" href="VarInfo_8h_source.html#l00088">VarInfo::TEMPL_PARAMS</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00335">findWinRegANDNetwork()</a>, and <a class="el" href="TemplateSynth_8cpp_source.html#l00162">findWinRegCNFTempl()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="acfa25deb001fb3b6d49c0261bba98347"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a>* TemplateSynth::impl_extractor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The engine to use for circuit extraction. </p>
<p>It will be deleted by this class (in the destructor). </p>

<p>Definition at line <a class="el" href="TemplateSynth_8h_source.html#l00290">290</a> of file <a class="el" href="TemplateSynth_8h_source.html">TemplateSynth.h</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00067">run()</a>, and <a class="el" href="TemplateSynth_8cpp_source.html#l00054">~TemplateSynth()</a>.</p>

</div>
</div>
<a class="anchor" id="a49665461c82781b823b3da04057fdab2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> TemplateSynth::neg_winning_region_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The negation of the resulting winning region. </p>

<p>Definition at line <a class="el" href="TemplateSynth_8h_source.html#l00273">273</a> of file <a class="el" href="TemplateSynth_8h_source.html">TemplateSynth.h</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00335">findWinRegANDNetwork()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00162">findWinRegCNFTempl()</a>, and <a class="el" href="TemplateSynth_8cpp_source.html#l00067">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a08ec20197bf16a10546a7e6cf3719727"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQBFSolver.html">QBFSolver</a>* TemplateSynth::qbf_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The QBF-solver to use for solving the queries. </p>

<p>Definition at line <a class="el" href="TemplateSynth_8h_source.html#l00278">278</a> of file <a class="el" href="TemplateSynth_8h_source.html">TemplateSynth.h</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00575">syntQBF()</a>, and <a class="el" href="TemplateSynth_8cpp_source.html#l00054">~TemplateSynth()</a>.</p>

</div>
</div>
<a class="anchor" id="a7844e9296d63b10e3fa96d66b932660f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSatSolver.html">SatSolver</a>* TemplateSynth::sat_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The SAT-solver to use if we resolve the template using the CEGIS loop. </p>

<p>Definition at line <a class="el" href="TemplateSynth_8h_source.html#l00283">283</a> of file <a class="el" href="TemplateSynth_8h_source.html">TemplateSynth.h</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00734">exclude()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00607">syntSAT()</a>, and <a class="el" href="TemplateSynth_8cpp_source.html#l00054">~TemplateSynth()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e147629eae6a542dd87d72902df68c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> TemplateSynth::winning_region_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The resulting winning region. </p>

<p>Definition at line <a class="el" href="TemplateSynth_8h_source.html#l00268">268</a> of file <a class="el" href="TemplateSynth_8h_source.html">TemplateSynth.h</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00335">findWinRegANDNetwork()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00162">findWinRegCNFTempl()</a>, and <a class="el" href="TemplateSynth_8cpp_source.html#l00067">run()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="TemplateSynth_8h_source.html">TemplateSynth.h</a></li>
<li>src/<a class="el" href="TemplateSynth_8cpp_source.html">TemplateSynth.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 26 2015 08:54:58 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
