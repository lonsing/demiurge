<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>demiurge: UnivExpander Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classUnivExpander-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UnivExpander Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A utility class that can do universal expansion of given CNFs.  
 <a href="classUnivExpander.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abebd87adfae7bb247f6239b3fc0a838e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#abebd87adfae7bb247f6239b3fc0a838e">UnivExpander</a> ()</td></tr>
<tr class="memdesc:abebd87adfae7bb247f6239b3fc0a838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#abebd87adfae7bb247f6239b3fc0a838e">More...</a><br/></td></tr>
<tr class="separator:abebd87adfae7bb247f6239b3fc0a838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b79688ebb811fe8088f9cd762404cfc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a5b79688ebb811fe8088f9cd762404cfc">~UnivExpander</a> ()</td></tr>
<tr class="memdesc:a5b79688ebb811fe8088f9cd762404cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5b79688ebb811fe8088f9cd762404cfc">More...</a><br/></td></tr>
<tr class="separator:a5b79688ebb811fe8088f9cd762404cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6935778cefc0b441db0d7f16933a48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48">resetSolverIExp</a> (<a class="el" href="classCNF.html">CNF</a> &amp;win_reg, <a class="el" href="classSatSolver.html">SatSolver</a> *solver_i, bool limit_size=false)</td></tr>
<tr class="memdesc:a1d6935778cefc0b441db0d7f16933a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the reset of solver_i in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>.  <a href="#a1d6935778cefc0b441db0d7f16933a48">More...</a><br/></td></tr>
<tr class="separator:a1d6935778cefc0b441db0d7f16933a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08608ee328b1c0503fb49eec8654e005"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a08608ee328b1c0503fb49eec8654e005">resetSolverIExp</a> (<a class="el" href="classCNF.html">CNF</a> &amp;win_reg, vector&lt; <a class="el" href="classSatSolver.html">SatSolver</a> * &gt; solvers, bool limit_size=false)</td></tr>
<tr class="memdesc:a08608ee328b1c0503fb49eec8654e005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the previous function but resets multiple solvers simultaneously.  <a href="#a08608ee328b1c0503fb49eec8654e005">More...</a><br/></td></tr>
<tr class="separator:a08608ee328b1c0503fb49eec8654e005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909bf44bb238afe91f4bf20416491771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a909bf44bb238afe91f4bf20416491771">initSolverCExp</a> (<a class="el" href="classSatSolver.html">SatSolver</a> *solver_c, const vector&lt; int &gt; &amp;keep, size_t max_nr_of_signals_to_expand=1)</td></tr>
<tr class="memdesc:a909bf44bb238afe91f4bf20416491771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes solver_c in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>.  <a href="#a909bf44bb238afe91f4bf20416491771">More...</a><br/></td></tr>
<tr class="separator:a909bf44bb238afe91f4bf20416491771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7798c75e574c747502af62a6b2e16ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a7798c75e574c747502af62a6b2e16ce4">addExpNxtClauseToC</a> (const vector&lt; int &gt; &amp;clause, <a class="el" href="classSatSolver.html">SatSolver</a> *solver_c)</td></tr>
<tr class="memdesc:a7798c75e574c747502af62a6b2e16ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds next-state clauses to solver_c after initialization with <a class="el" href="classUnivExpander.html#a909bf44bb238afe91f4bf20416491771" title="Initializes solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">initSolverCExp()</a>.  <a href="#a7798c75e574c747502af62a6b2e16ce4">More...</a><br/></td></tr>
<tr class="separator:a7798c75e574c747502af62a6b2e16ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bb05f7f6a31a700d7407c45aebb6e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a27bb05f7f6a31a700d7407c45aebb6e8">resetSolverCExp</a> (<a class="el" href="classSatSolver.html">SatSolver</a> *solver_c)</td></tr>
<tr class="memdesc:a27bb05f7f6a31a700d7407c45aebb6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets solver_c in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>.  <a href="#a27bb05f7f6a31a700d7407c45aebb6e8">More...</a><br/></td></tr>
<tr class="separator:a27bb05f7f6a31a700d7407c45aebb6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab48e1ba7b95b7e439f7c2f5f2e809a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#adab48e1ba7b95b7e439f7c2f5f2e809a">extrExp</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;nxt_win_reg, <a class="el" href="classSatSolver.html">SatSolver</a> *solver, const vector&lt; int &gt; to_exp) const </td></tr>
<tr class="memdesc:adab48e1ba7b95b7e439f7c2f5f2e809a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the solver for <a class="el" href="classLearningImplExtractor.html#aa61a9c39a6cb6e6e04eeb3ca876e50be" title="Same as runLearningQBFInc, but using universal expansion and a SAT solver. ">LearningImplExtractor::runLearningExp()</a>.  <a href="#adab48e1ba7b95b7e439f7c2f5f2e809a">More...</a><br/></td></tr>
<tr class="separator:adab48e1ba7b95b7e439f7c2f5f2e809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b6465bd5d8f5d939c253f7aca49c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a56b6465bd5d8f5d939c253f7aca49c59">setAbortCondition</a> (volatile int *abort_if)</td></tr>
<tr class="memdesc:a56b6465bd5d8f5d939c253f7aca49c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the integer pointed to becomes != 0, the expansion aborts.  <a href="#a56b6465bd5d8f5d939c253f7aca49c59">More...</a><br/></td></tr>
<tr class="separator:a56b6465bd5d8f5d939c253f7aca49c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c2e34bd041cbeff5ad9726a5b48895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#af2c2e34bd041cbeff5ad9726a5b48895">cleanup</a> ()</td></tr>
<tr class="memdesc:af2c2e34bd041cbeff5ad9726a5b48895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the stored data structures to save space.  <a href="#af2c2e34bd041cbeff5ad9726a5b48895">More...</a><br/></td></tr>
<tr class="separator:af2c2e34bd041cbeff5ad9726a5b48895"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adbc9898ad3b1aac28869c9b83c228816"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#adbc9898ad3b1aac28869c9b83c228816">univExpand</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;orig, <a class="el" href="classCNF.html">CNF</a> &amp;res, const vector&lt; int &gt; &amp;vars_to_exp, const vector&lt; int &gt; &amp;keep, float rate=1.1, const map&lt; int, set&lt; int &gt; &gt; *more_deps=NULL)</td></tr>
<tr class="memdesc:adbc9898ad3b1aac28869c9b83c228816"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard method for universal expansion of certain variables.  <a href="#adbc9898ad3b1aac28869c9b83c228816">More...</a><br/></td></tr>
<tr class="separator:adbc9898ad3b1aac28869c9b83c228816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a87f2309e7e1d511d9539872b08814c40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a87f2309e7e1d511d9539872b08814c40">initSolverIData</a> (bool limit_size=false)</td></tr>
<tr class="memdesc:a87f2309e7e1d511d9539872b08814c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>.  <a href="#a87f2309e7e1d511d9539872b08814c40">More...</a><br/></td></tr>
<tr class="separator:a87f2309e7e1d511d9539872b08814c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15bca765ef574d7e7d22f565444451a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#ab15bca765ef574d7e7d22f565444451a">simplifyTransAndsWithAbc</a> ()</td></tr>
<tr class="memdesc:ab15bca765ef574d7e7d22f565444451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the fully expanded AIGER graph using ABC.  <a href="#ab15bca765ef574d7e7d22f565444451a">More...</a><br/></td></tr>
<tr class="separator:ab15bca765ef574d7e7d22f565444451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309bb0771b1399cfd7480d0c5c5447fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a309bb0771b1399cfd7480d0c5c5447fc">shallAbort</a> () const </td></tr>
<tr class="memdesc:a309bb0771b1399cfd7480d0c5c5447fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of we call abort, and false otherwise.  <a href="#a309bb0771b1399cfd7480d0c5c5447fc">More...</a><br/></td></tr>
<tr class="separator:a309bb0771b1399cfd7480d0c5c5447fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0788526dcb1f26433a981b89b2b942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a9c0788526dcb1f26433a981b89b2b942">cleanupIData</a> ()</td></tr>
<tr class="memdesc:a9c0788526dcb1f26433a981b89b2b942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all data structures that are needed for expansion in solver_i.  <a href="#a9c0788526dcb1f26433a981b89b2b942">More...</a><br/></td></tr>
<tr class="separator:a9c0788526dcb1f26433a981b89b2b942"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a65c8d362518dae708b16a4f214511306"><td class="memItemLeft" align="right" valign="top">const vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a65c8d362518dae708b16a4f214511306">s_</a></td></tr>
<tr class="memdesc:a65c8d362518dae708b16a4f214511306"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of present-state variables.  <a href="#a65c8d362518dae708b16a4f214511306">More...</a><br/></td></tr>
<tr class="separator:a65c8d362518dae708b16a4f214511306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab623917d2dd9530ca51b6952862f107c"><td class="memItemLeft" align="right" valign="top">const vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#ab623917d2dd9530ca51b6952862f107c">i_</a></td></tr>
<tr class="memdesc:ab623917d2dd9530ca51b6952862f107c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of (uncontrollable) input variables.  <a href="#ab623917d2dd9530ca51b6952862f107c">More...</a><br/></td></tr>
<tr class="separator:ab623917d2dd9530ca51b6952862f107c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d032483de0474d8489678c28bb3a64"><td class="memItemLeft" align="right" valign="top">const vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a99d032483de0474d8489678c28bb3a64">c_</a></td></tr>
<tr class="memdesc:a99d032483de0474d8489678c28bb3a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of control signals (controllable input variables).  <a href="#a99d032483de0474d8489678c28bb3a64">More...</a><br/></td></tr>
<tr class="separator:a99d032483de0474d8489678c28bb3a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053df0842220ee9fa6b5ab41a2e10253"><td class="memItemLeft" align="right" valign="top">const vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a053df0842220ee9fa6b5ab41a2e10253">n_</a></td></tr>
<tr class="memdesc:a053df0842220ee9fa6b5ab41a2e10253"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of next-state variables.  <a href="#a053df0842220ee9fa6b5ab41a2e10253">More...</a><br/></td></tr>
<tr class="separator:a053df0842220ee9fa6b5ab41a2e10253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de6c3dba22507de35c5d5750612e423"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structCNFAnd.html">CNFAnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a9de6c3dba22507de35c5d5750612e423">i_trans_ands_</a></td></tr>
<tr class="memdesc:a9de6c3dba22507de35c5d5750612e423"><td class="mdescLeft">&#160;</td><td class="mdescRight">The expansion of the transition relation for <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>.  <a href="#a9de6c3dba22507de35c5d5750612e423">More...</a><br/></td></tr>
<tr class="separator:a9de6c3dba22507de35c5d5750612e423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fe5c141f55cc4e6097509d2309e2f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a72fe5c141f55cc4e6097509d2309e2f7">i_max_trans_var_</a></td></tr>
<tr class="memdesc:a72fe5c141f55cc4e6097509d2309e2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum variable index occurring in i_trans_ands_.  <a href="#a72fe5c141f55cc4e6097509d2309e2f7">More...</a><br/></td></tr>
<tr class="separator:a72fe5c141f55cc4e6097509d2309e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150474e2dd386599d750453eec601ec2"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a150474e2dd386599d750453eec601ec2">i_s_to_ren_n_</a></td></tr>
<tr class="memdesc:a150474e2dd386599d750453eec601ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map, renaming present-state vars to a renamed version of the next-state copy.  <a href="#a150474e2dd386599d750453eec601ec2">More...</a><br/></td></tr>
<tr class="separator:a150474e2dd386599d750453eec601ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3bf04d83d2164635bdc57d78617219"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a8e3bf04d83d2164635bdc57d78617219">i_rename_maps_</a></td></tr>
<tr class="memdesc:a8e3bf04d83d2164635bdc57d78617219"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rename maps resulting from the expansion of the transition relation.  <a href="#a8e3bf04d83d2164635bdc57d78617219">More...</a><br/></td></tr>
<tr class="separator:a8e3bf04d83d2164635bdc57d78617219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a67805b87282a1dcfcb25c33c04837d"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a7a67805b87282a1dcfcb25c33c04837d">i_copy_maps_</a></td></tr>
<tr class="memdesc:a7a67805b87282a1dcfcb25c33c04837d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional rename maps to be applied to i_rename_maps_.  <a href="#a7a67805b87282a1dcfcb25c33c04837d">More...</a><br/></td></tr>
<tr class="separator:a7a67805b87282a1dcfcb25c33c04837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e747b1df6cfd250707384b593b13a7"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a56e747b1df6cfd250707384b593b13a7">i_orig_prop_maps_</a></td></tr>
<tr class="memdesc:a56e747b1df6cfd250707384b593b13a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional rename maps to be applied to i_rename_maps_.  <a href="#a56e747b1df6cfd250707384b593b13a7">More...</a><br/></td></tr>
<tr class="separator:a56e747b1df6cfd250707384b593b13a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f970b4ccd465626cdb1fb8978f9fae"><td class="memItemLeft" align="right" valign="top">set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#ae1f970b4ccd465626cdb1fb8978f9fae">i_occ_</a></td></tr>
<tr class="memdesc:ae1f970b4ccd465626cdb1fb8978f9fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the final copies of the next-state variables.  <a href="#ae1f970b4ccd465626cdb1fb8978f9fae">More...</a><br/></td></tr>
<tr class="separator:ae1f970b4ccd465626cdb1fb8978f9fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bc6eec7ce33effdac18b8b1c0bd770"><td class="memItemLeft" align="right" valign="top">set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a02bc6eec7ce33effdac18b8b1c0bd770">i_prev_occ_</a></td></tr>
<tr class="memdesc:a02bc6eec7ce33effdac18b8b1c0bd770"><td class="mdescLeft">&#160;</td><td class="mdescRight">The almost-final copies of the next-state variables.  <a href="#a02bc6eec7ce33effdac18b8b1c0bd770">More...</a><br/></td></tr>
<tr class="separator:a02bc6eec7ce33effdac18b8b1c0bd770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44acd8709f042e39071913fb12303b0d"><td class="memItemLeft" align="right" valign="top">set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a44acd8709f042e39071913fb12303b0d">i_occ_in_i_rename_maps_</a></td></tr>
<tr class="memdesc:a44acd8709f042e39071913fb12303b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All variables that occur (as values) in i_rename_maps_.  <a href="#a44acd8709f042e39071913fb12303b0d">More...</a><br/></td></tr>
<tr class="separator:a44acd8709f042e39071913fb12303b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16753edd5e204fac8e8a528f6667c33"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#ad16753edd5e204fac8e8a528f6667c33">c_rename_maps_</a></td></tr>
<tr class="memdesc:ad16753edd5e204fac8e8a528f6667c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rename maps for the next-state variables for adding clauses to solver_c.  <a href="#ad16753edd5e204fac8e8a528f6667c33">More...</a><br/></td></tr>
<tr class="separator:ad16753edd5e204fac8e8a528f6667c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58b19991cb7aff5164af51f95ea6557"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#af58b19991cb7aff5164af51f95ea6557">c_cnf_</a></td></tr>
<tr class="memdesc:af58b19991cb7aff5164af51f95ea6557"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> to put into the solver when <a class="el" href="classUnivExpander.html#a27bb05f7f6a31a700d7407c45aebb6e8" title="Resets solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverCExp()</a> is called.  <a href="#af58b19991cb7aff5164af51f95ea6557">More...</a><br/></td></tr>
<tr class="separator:af58b19991cb7aff5164af51f95ea6557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048dabb0f36d29d4a709a3f284b60141"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a048dabb0f36d29d4a709a3f284b60141">c_keep_</a></td></tr>
<tr class="memdesc:a048dabb0f36d29d4a709a3f284b60141"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> to put into the solver when <a class="el" href="classUnivExpander.html#a27bb05f7f6a31a700d7407c45aebb6e8" title="Resets solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverCExp()</a> is called.  <a href="#a048dabb0f36d29d4a709a3f284b60141">More...</a><br/></td></tr>
<tr class="separator:a048dabb0f36d29d4a709a3f284b60141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abb36bae418610456ed7a20d11c5f47"><td class="memItemLeft" align="right" valign="top">volatile int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a6abb36bae418610456ed7a20d11c5f47">abort_if_</a></td></tr>
<tr class="memdesc:a6abb36bae418610456ed7a20d11c5f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this pointer points to some integer that is not 0, expansion aborts.  <a href="#a6abb36bae418610456ed7a20d11c5f47">More...</a><br/></td></tr>
<tr class="separator:a6abb36bae418610456ed7a20d11c5f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a115738b6f2e3fcd8362d632a3fff4677"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a115738b6f2e3fcd8362d632a3fff4677">UnivExpander</a> (const <a class="el" href="classUnivExpander.html">UnivExpander</a> &amp;other)</td></tr>
<tr class="memdesc:a115738b6f2e3fcd8362d632a3fff4677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a115738b6f2e3fcd8362d632a3fff4677">More...</a><br/></td></tr>
<tr class="separator:a115738b6f2e3fcd8362d632a3fff4677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263c8499565440575027b5d81c154bc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUnivExpander.html">UnivExpander</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnivExpander.html#a263c8499565440575027b5d81c154bc6">operator=</a> (const <a class="el" href="classUnivExpander.html">UnivExpander</a> &amp;other)</td></tr>
<tr class="memdesc:a263c8499565440575027b5d81c154bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a263c8499565440575027b5d81c154bc6">More...</a><br/></td></tr>
<tr class="separator:a263c8499565440575027b5d81c154bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class that can do universal expansion of given CNFs. </p>
<p>Universal expansion of a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> with respect to certain variables is an expensive operation, especially if there are a lot of variables to expand. Hence, this operation must be implemented cleverly. For this reason, this class provides several implementations, each one tailored towards a specific application (expanding CTRL-signals in a conjuction of the transition relation with some <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the next-state variables, etc.)</p>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.2.0 </dd></dl>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00071">71</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abebd87adfae7bb247f6239b3fc0a838e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UnivExpander::UnivExpander </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00095">95</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b79688ebb811fe8088f9cd762404cfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnivExpander::~UnivExpander </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00107">107</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a115738b6f2e3fcd8362d632a3fff4677"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnivExpander::UnivExpander </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnivExpander.html">UnivExpander</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7798c75e574c747502af62a6b2e16ce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::addExpNxtClauseToC </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td>
          <td class="paramname"><em>solver_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds next-state clauses to solver_c after initialization with <a class="el" href="classUnivExpander.html#a909bf44bb238afe91f4bf20416491771" title="Initializes solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">initSolverCExp()</a>. </p>
<p>After <a class="el" href="classUnivExpander.html#a909bf44bb238afe91f4bf20416491771" title="Initializes solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">initSolverCExp()</a> has been called to initialize solver_c, this method can be used to add next-state clauses to all expansions of the next-state variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>A clause over the current-state variables. It is added as clause over (all expansions of) the next state variables in solver_c. </td></tr>
    <tr><td class="paramname">solver_c</td><td>The solver to which the next-state copies of this clause should be added. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00932">932</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8h_source.html#l00433">c_rename_maps_</a>, and <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01045">ClauseExplorerSAT::considerNewInfoFromOthers()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="af2c2e34bd041cbeff5ad9726a5b48895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the stored data structures to save space. </p>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l01428">1428</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8h_source.html#l00441">c_cnf_</a>, <a class="el" href="UnivExpander_8h_source.html#l00450">c_keep_</a>, <a class="el" href="UnivExpander_8h_source.html#l00433">c_rename_maps_</a>, <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, and <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00391">ParallelLearner::run()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c0788526dcb1f26433a981b89b2b942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::cleanupIData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all data structures that are needed for expansion in solver_i. </p>
<p>These data structures can consume quite some memory, so we do not want to have them lying around uselessly. </p>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l02012">2012</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8h_source.html#l00393">i_copy_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00410">i_occ_</a>, <a class="el" href="UnivExpander_8h_source.html#l00425">i_occ_in_i_rename_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00404">i_orig_prop_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00420">i_prev_occ_</a>, <a class="el" href="UnivExpander_8h_source.html#l00382">i_rename_maps_</a>, and <a class="el" href="UnivExpander_8h_source.html#l00338">i_trans_ands_</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01428">cleanup()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="adab48e1ba7b95b7e439f7c2f5f2e809a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::extrExp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>nxt_win_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>to_exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the solver for <a class="el" href="classLearningImplExtractor.html#aa61a9c39a6cb6e6e04eeb3ca876e50be" title="Same as runLearningQBFInc, but using universal expansion and a SAT solver. ">LearningImplExtractor::runLearningExp()</a>. </p>
<p>This method initializes the SAT solver for circuit extraction using universal expansion in order to use a SAT solver instead of a QBF solver. However, this approach appears to be very slow. The solver is filled with the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> for T(x,i,c,x') &amp; !W(x'), expanded over some but not all control signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nxt_win_reg</td><td>The next-state copy of the winning region, i.e., W(x'). </td></tr>
    <tr><td class="paramname">solver</td><td>The solver in which the expanded <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> should be put. </td></tr>
    <tr><td class="paramname">to_exp</td><td>The set of control signals to expand. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00954">954</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8h_source.html#l00318">c_</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="UnivExpander_8h_source.html#l00311">i_</a>, <a class="el" href="classSatSolver.html#a791be541b59ef58a29a1c517fca943e7">SatSolver::incAdd2LitClause()</a>, <a class="el" href="classSatSolver.html#abca288874a1b8ab1a90cb274eb885ace">SatSolver::incAdd3LitClause()</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="classSatSolver.html#a5b39c45cd2a1abfe96c681515dfddb77">SatSolver::incAddUnitClause()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="UnivExpander_8h_source.html#l00049">CNFAnd::l</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="UnivExpander_8h_source.html#l00325">n_</a>, <a class="el" href="UnivExpander_8h_source.html#l00045">CNFAnd::r0</a>, <a class="el" href="UnivExpander_8h_source.html#l00047">CNFAnd::r1</a>, <a class="el" href="UnivExpander_8h_source.html#l00304">s_</a>, and <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">LearningImplExtractor::runLearningExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a909bf44bb238afe91f4bf20416491771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::initSolverCExp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td>
          <td class="paramname"><em>solver_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nr_of_signals_to_expand</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes solver_c in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>. </p>
<p>In <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>, solver_c needs to check exists x: forall i: exists x',t: W(x) &amp; T(x,i,c,x',t) &amp; W(x') where W is the winning region (a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the state variables x) and T is the transition relation with t being auxiliary variables. This method expands some of the input signals i in the transition relation T, and puts the resulting formula into solver_c. At the same time, this method also constructs a renaming map so clauses of W(x') can be added later on (using the method <a class="el" href="classUnivExpander.html#a7798c75e574c747502af62a6b2e16ce4" title="Adds next-state clauses to solver_c after initialization with initSolverCExp(). ">addExpNxtClauseToC()</a>). This method is highly optimized for exactly this purpose. <a class="el" href="classUnivExpander.html#adbc9898ad3b1aac28869c9b83c228816" title="The standard method for universal expansion of certain variables. ">univExpand()</a> could also be used in principle, but this method has more optimizations exploiting the structure of the transition relation.</p>
<dl class="section note"><dt>Note</dt><dd>The newly created auxiliary variables are not registered in the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created. ">VarManager</a> for performance reasons (there may be zillions of new variables introduced during the expansion).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver_c</td><td>The solver into which the expanded transition relation should be stored. </td></tr>
    <tr><td class="paramname">keep</td><td>This method declares the current-state variables, the uncontrollable inputs, and the next-state variables (in their various copys) as reusable. If you also want other variables to be reusable (e.g. previous-state variables), then they can be enumerated in this vector. </td></tr>
    <tr><td class="paramname">max_nr_of_signals_to_expand</td><td>For solver_c, expansion is very costly (more than for solver_i). Hence, we usually only expand a few input variables. This parameter defines the maximum number of input signals to expand. Low values are recommended. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00655">655</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00169">CNF::add1LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00186">CNF::add3LitClause()</a>, <a class="el" href="UnivExpander_8h_source.html#l00318">c_</a>, <a class="el" href="UnivExpander_8h_source.html#l00441">c_cnf_</a>, <a class="el" href="UnivExpander_8h_source.html#l00450">c_keep_</a>, <a class="el" href="UnivExpander_8h_source.html#l00433">c_rename_maps_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00271">AIG2CNF::getTmpDeps()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="UnivExpander_8h_source.html#l00311">i_</a>, <a class="el" href="classSatSolver.html#a791be541b59ef58a29a1c517fca943e7">SatSolver::incAdd2LitClause()</a>, <a class="el" href="classSatSolver.html#abca288874a1b8ab1a90cb274eb885ace">SatSolver::incAdd3LitClause()</a>, <a class="el" href="classSatSolver.html#a5b39c45cd2a1abfe96c681515dfddb77">SatSolver::incAddUnitClause()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="UnivExpander_8h_source.html#l00325">n_</a>, <a class="el" href="VarInfo_8h_source.html#l00097">VarInfo::PREV</a>, <a class="el" href="UnivExpander_8h_source.html#l00304">s_</a>, and <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="a87f2309e7e1d511d9539872b08814c40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UnivExpander::initSolverIData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_size</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function for <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>
<p>Some work in <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a> needs to be done again and again when this method is called repeatedly. For instance, the expansion of the transition relation is always the same. This method performs these repeated tasks only once, and stores the resulting information in fields of this class. This way, they can then be reused by <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a> whenever needed. All fields defined by this method start with 'i_'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit_size</td><td>If set to true, then this method aborts if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> size limit defined by <a class="el" href="classOptions.html#aa59992b1b4c698ade25627bb19a7d055" title="Returns the maximum memory (in kB) to use in SAT-based learning with expansion. ">Options::getSizeLimitForExpansion()</a> is exceeded. This is supposed to prevent running out of memory during the expansion. If this flag is set to false, or omitted, then the size limit does not apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the size limit for the expansion has been exceeded during the initialization already. False if everything went OK. </dd></dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l01439">1439</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8h_source.html#l00318">c_</a>, <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="Utils_8cpp_source.html#l00597">Utils::getCurrentMemUsage()</a>, <a class="el" href="Options_8cpp_source.html#l00544">Options::getSizeLimitForExpansion()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00271">AIG2CNF::getTmpDeps()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="UnivExpander_8h_source.html#l00311">i_</a>, <a class="el" href="UnivExpander_8h_source.html#l00393">i_copy_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00347">i_max_trans_var_</a>, <a class="el" href="UnivExpander_8h_source.html#l00410">i_occ_</a>, <a class="el" href="UnivExpander_8h_source.html#l00425">i_occ_in_i_rename_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00404">i_orig_prop_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00420">i_prev_occ_</a>, <a class="el" href="UnivExpander_8h_source.html#l00382">i_rename_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00363">i_s_to_ren_n_</a>, <a class="el" href="UnivExpander_8h_source.html#l00338">i_trans_ands_</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="UnivExpander_8h_source.html#l00049">CNFAnd::l</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="UnivExpander_8h_source.html#l00325">n_</a>, <a class="el" href="UnivExpander_8h_source.html#l00045">CNFAnd::r0</a>, <a class="el" href="UnivExpander_8h_source.html#l00047">CNFAnd::r1</a>, <a class="el" href="UnivExpander_8h_source.html#l00304">s_</a>, <a class="el" href="UnivExpander_8cpp_source.html#l02004">shallAbort()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a263c8499565440575027b5d81c154bc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUnivExpander.html">UnivExpander</a>&amp; UnivExpander::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnivExpander.html">UnivExpander</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="a27bb05f7f6a31a700d7407c45aebb6e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::resetSolverCExp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td>
          <td class="paramname"><em>solver_c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets solver_c in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>. </p>
<p>After many many iterations of <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>, solver_c may contain many redundant clauses, which only slow down the solving process. So, from time to time, we may just reset the solver again (i.e., set it into the state after calling <a class="el" href="classUnivExpander.html#a909bf44bb238afe91f4bf20416491771" title="Initializes solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">initSolverCExp</a>) to get rid of all these redundant clauses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver_c</td><td>The solver to reset. After calling this method, solver_c will be in the same state as if <a class="el" href="classUnivExpander.html#a909bf44bb238afe91f4bf20416491771" title="Initializes solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">initSolverCExp()</a> had just been called. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00947">947</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8h_source.html#l00441">c_cnf_</a>, <a class="el" href="UnivExpander_8h_source.html#l00450">c_keep_</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, and <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01045">ClauseExplorerSAT::considerNewInfoFromOthers()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d6935778cefc0b441db0d7f16933a48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UnivExpander::resetSolverIExp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td>
          <td class="paramname"><em>solver_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_size</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the reset of solver_i in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>. </p>
<p>In <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>, solver_i needs to check exists x,i: forall c: exists x',t: W(x) &amp; T(x,i,c,x',t) &amp; !W(x') where W is the winning region (a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the state variables x) and T is the transition relation with t being auxiliary variables. This method expands the control signals c of the above formula and puts the resulting formula into the SAT solver solver_i. This method is highly optimized for this purpose. For instance, the expansion of the transition relation is done only once and reused for different winning regions. <a class="el" href="classUnivExpander.html#adbc9898ad3b1aac28869c9b83c228816" title="The standard method for universal expansion of certain variables. ">univExpand()</a> could also be used in principle, but this method has more optimizations exploiting the structure of the formula that needs to be expanded.</p>
<dl class="section note"><dt>Note</dt><dd>The newly created auxiliary variables are not registered in the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created. ">VarManager</a> for performance reasons (there may be zillions of new variables introduced during the expansion).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_reg</td><td>The winning region with which the solver should be initialized. This winning region is compressed (redundant clauses are removed) inside this function and, hence, modified. </td></tr>
    <tr><td class="paramname">solver_i</td><td>The solver into which the expanded <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> should be stored. </td></tr>
    <tr><td class="paramname">limit_size</td><td>If set to true, then this method aborts if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> size limit defined by <a class="el" href="classOptions.html#aa59992b1b4c698ade25627bb19a7d055" title="Returns the maximum memory (in kB) to use in SAT-based learning with expansion. ">Options::getSizeLimitForExpansion()</a> is exceeded. This is supposed to prevent running out of memory during the expansion. If this flag is set to false, or omitted, then the size limit does not apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the size limit for the expansion has been exceeded. False if everything went OK (or nothing was checked because limit_size was set to false). </dd></dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00302">302</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00560">ParallelLearner::triggerExplorerRestart()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00658">ParallelLearner::triggerInitialMode1Restart()</a>.</p>

</div>
</div>
<a class="anchor" id="a08608ee328b1c0503fb49eec8654e005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UnivExpander::resetSolverIExp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classSatSolver.html">SatSolver</a> * &gt;&#160;</td>
          <td class="paramname"><em>solvers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_size</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous function but resets multiple solvers simultaneously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_reg</td><td>The winning region with which the solver should be initialized. This winning region is compressed (redundant clauses are removed) inside this function and, hence, modified. </td></tr>
    <tr><td class="paramname">solvers</td><td>The list of solvers into which the expanded <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> should be stored. </td></tr>
    <tr><td class="paramname">limit_size</td><td>If set to true, then this method aborts if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> size limit defined by <a class="el" href="classOptions.html#aa59992b1b4c698ade25627bb19a7d055" title="Returns the maximum memory (in kB) to use in SAT-based learning with expansion. ">Options::getSizeLimitForExpansion()</a> is exceeded. This is supposed to prevent running out of memory during the expansion. If this flag is set to false, or omitted, then the size limit does not apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the size limit for the expansion has been exceeded. False if everything went OK (or nothing was checked because limit_size was set to false). </dd></dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00309">309</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="Utils_8cpp_source.html#l00502">Utils::compressNextStateCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="Utils_8cpp_source.html#l00597">Utils::getCurrentMemUsage()</a>, <a class="el" href="Options_8cpp_source.html#l00544">Options::getSizeLimitForExpansion()</a>, <a class="el" href="UnivExpander_8h_source.html#l00311">i_</a>, <a class="el" href="UnivExpander_8h_source.html#l00393">i_copy_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00347">i_max_trans_var_</a>, <a class="el" href="UnivExpander_8h_source.html#l00425">i_occ_in_i_rename_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00404">i_orig_prop_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00382">i_rename_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00338">i_trans_ands_</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="UnivExpander_8h_source.html#l00325">n_</a>, and <a class="el" href="UnivExpander_8h_source.html#l00304">s_</a>.</p>

</div>
</div>
<a class="anchor" id="a56b6465bd5d8f5d939c253f7aca49c59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::setAbortCondition </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>abort_if</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the integer pointed to becomes != 0, the expansion aborts. </p>
<p>This is useful in the parallelization: if one thread already found a solution, it makes sense to abort the expansion (because the expansion can take quite long).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_if</td><td>A pointer to an integer. If this integer ever becomes != 0, the expansion aborts. If this pointer is NULL, we never abort. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l01422">1422</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8h_source.html#l00455">abort_if_</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00251">ParallelLearner::ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="a309bb0771b1399cfd7480d0c5c5447fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UnivExpander::shallAbort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true of we call abort, and false otherwise. </p>
<p>This is useful in the parallelization: if one thread already found a solution, it makes sense to abort the expansion (because the expansion can take quite long).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classUnivExpander.html#a56b6465bd5d8f5d939c253f7aca49c59" title="If the integer pointed to becomes != 0, the expansion aborts. ">setAbortCondition</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true of we call abort, and false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l02004">2004</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="UnivExpander_8h_source.html#l00455">abort_if_</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>.</p>

</div>
</div>
<a class="anchor" id="ab15bca765ef574d7e7d22f565444451a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::simplifyTransAndsWithAbc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies the fully expanded AIGER graph using ABC. </p>
<p>This is a helper for <a class="el" href="classUnivExpander.html#a87f2309e7e1d511d9539872b08814c40" title="A helper function for resetSolverIExp(). ">initSolverIData()</a>. If the transition relation is already fully expanded, then this method can be used to rewrite this expansion further to shring the formula. This method modifies i_trans_ands_, i_max_trans_var_, and i_rename_maps_. </p>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l01851">1851</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="Options_8cpp_source.html#l00481">Options::getTPDirName()</a>, <a class="el" href="Options_8cpp_source.html#l00471">Options::getUniqueTmpFileName()</a>, <a class="el" href="UnivExpander_8h_source.html#l00311">i_</a>, <a class="el" href="UnivExpander_8h_source.html#l00393">i_copy_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00347">i_max_trans_var_</a>, <a class="el" href="UnivExpander_8h_source.html#l00410">i_occ_</a>, <a class="el" href="UnivExpander_8h_source.html#l00404">i_orig_prop_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00420">i_prev_occ_</a>, <a class="el" href="UnivExpander_8h_source.html#l00382">i_rename_maps_</a>, <a class="el" href="UnivExpander_8h_source.html#l00338">i_trans_ands_</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="UnivExpander_8h_source.html#l00049">CNFAnd::l</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="UnivExpander_8h_source.html#l00045">CNFAnd::r0</a>, <a class="el" href="UnivExpander_8h_source.html#l00047">CNFAnd::r1</a>, and <a class="el" href="UnivExpander_8h_source.html#l00304">s_</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>.</p>

</div>
</div>
<a class="anchor" id="adbc9898ad3b1aac28869c9b83c228816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnivExpander::univExpand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars_to_exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rate</em> = <code>1.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; int, set&lt; int &gt; &gt; *&#160;</td>
          <td class="paramname"><em>more_deps</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The standard method for universal expansion of certain variables. </p>
<dl class="section note"><dt>Note</dt><dd>The newly created auxiliary variables are not registered in the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created. ">VarManager</a> for performance reasons (there may be zillions of new variables introduced during the expansion).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>The original <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> in which we perform universal expansion. </td></tr>
    <tr><td class="paramname">res</td><td>An empty <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. This is where the result will be stored. </td></tr>
    <tr><td class="paramname">vars_to_exp</td><td>The list of variables to expand. </td></tr>
    <tr><td class="paramname">keep</td><td>The list of variables that are quantified outside of the vars_to_exp and should hence not be renamed during the expansion. </td></tr>
    <tr><td class="paramname">rate</td><td>A number between 0 and 1. It defines which fraction of the vars_to_exp should be expanded. Value 0.4 means that 40% of the vars_to_exp should be expanded. Use a value larger than 1 (or omit this parameter) if you want to be sure that every signal is expanded. </td></tr>
    <tr><td class="paramname">more_deps</td><td>Additional dependencies that can be exploited during expansion. This map must map user-defined (temporary) variables to a set of other variables that define these variables. Don't include the dependencies of the temporary variables used to encode the transition relation, and don't include the dependencies of the next-state variables because they are automatically read from <a class="el" href="classAIG2CNF.html" title="Transforms an AIGER specification into CNF. ">AIG2CNF</a>. But if you have additional temporary variables, e.g., from Tseitin encoding some formula part then the expansion can benefit from dependency information (it needs to copy less). In any case: more_deps[i] must only contain variables in keep or vars_to_exp. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UnivExpander_8cpp_source.html#l00113">113</a> of file <a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00571">CNF::appendVarsTo()</a>, <a class="el" href="defines_8h_source.html#l00138">DASSERT</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">AIG2CNF::getTmpDepsTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, and <a class="el" href="CNF_8cpp_source.html#l00294">CNF::swapWith()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6abb36bae418610456ed7a20d11c5f47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile int* UnivExpander::abort_if_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this pointer points to some integer that is not 0, expansion aborts. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00455">455</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01422">setAbortCondition()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l02004">shallAbort()</a>.</p>

</div>
</div>
<a class="anchor" id="a99d032483de0474d8489678c28bb3a64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;int&gt;&amp; UnivExpander::c_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of control signals (controllable input variables). </p>
<p>This list is often used, so we keep it as a field to increase readability of the code. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00318">318</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l00954">extrExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">initSolverCExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>.</p>

</div>
</div>
<a class="anchor" id="af58b19991cb7aff5164af51f95ea6557"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> UnivExpander::c_cnf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> to put into the solver when <a class="el" href="classUnivExpander.html#a27bb05f7f6a31a700d7407c45aebb6e8" title="Resets solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverCExp()</a> is called. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is computed by <a class="el" href="classUnivExpander.html#a909bf44bb238afe91f4bf20416491771" title="Initializes solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">initSolverCExp()</a> and contains the expanded transition relation for solver_c. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00441">441</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01428">cleanup()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">initSolverCExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00947">resetSolverCExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a048dabb0f36d29d4a709a3f284b60141"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; UnivExpander::c_keep_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> to put into the solver when <a class="el" href="classUnivExpander.html#a27bb05f7f6a31a700d7407c45aebb6e8" title="Resets solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverCExp()</a> is called. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is computed by <a class="el" href="classUnivExpander.html#a909bf44bb238afe91f4bf20416491771" title="Initializes solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">initSolverCExp()</a> and contains the variables that should not be optimized away by the solver (because they will be needed in the incremental use of the solver). </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00450">450</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01428">cleanup()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">initSolverCExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00947">resetSolverCExp()</a>.</p>

</div>
</div>
<a class="anchor" id="ad16753edd5e204fac8e8a528f6667c33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt; UnivExpander::c_rename_maps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rename maps for the next-state variables for adding clauses to solver_c. </p>
<p>c_rename_maps_[i] is the rename map for present-state variables to the i-th copy of the next state variables. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00433">433</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l00932">addExpNxtClauseToC()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01428">cleanup()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00655">initSolverCExp()</a>.</p>

</div>
</div>
<a class="anchor" id="ab623917d2dd9530ca51b6952862f107c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;int&gt;&amp; UnivExpander::i_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of (uncontrollable) input variables. </p>
<p>This list is often used, so we keep it as a field to increase readability of the code. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00311">311</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l00954">extrExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">initSolverCExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a67805b87282a1dcfcb25c33c04837d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt; UnivExpander::i_copy_maps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional rename maps to be applied to i_rename_maps_. </p>
<p>For small benchmarks, this field is not used. For small benchmarks, all the renaming is stored in i_rename_maps_. However, for large benchmarks with many control signals, i_rename_maps_ can grow very large and eat up all our memory. For such cases, we do not build up i_rename_maps_ completely, but store the remaining renamings (to be applied to i_rename_maps_) in i_copy_maps_ and i_orig_prop_maps_. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00393">393</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<a class="anchor" id="a72fe5c141f55cc4e6097509d2309e2f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int UnivExpander::i_max_trans_var_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum variable index occurring in i_trans_ands_. </p>
<p>That is, for <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>, i_max_trans_var_ + 1 is the next fresh <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> variable. All fields starting with 'i_' (like this one) are initialized by <a class="el" href="classUnivExpander.html#a87f2309e7e1d511d9539872b08814c40" title="A helper function for resetSolverIExp(). ">initSolverIData()</a> and used by <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00347">347</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1f970b4ccd465626cdb1fb8978f9fae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;int&gt; UnivExpander::i_occ_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All the final copies of the next-state variables. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00410">410</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<a class="anchor" id="a44acd8709f042e39071913fb12303b0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;int&gt; UnivExpander::i_occ_in_i_rename_maps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All variables that occur (as values) in i_rename_maps_. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00425">425</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a56e747b1df6cfd250707384b593b13a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt; UnivExpander::i_orig_prop_maps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional rename maps to be applied to i_rename_maps_. </p>
<p>For small benchmarks, this field is not used. For small benchmarks, all the renaming is stored in i_rename_maps_. However, for large benchmarks with many control signals, i_rename_maps_ can grow very large and eat up all our memory. For such cases, we do not build up i_rename_maps_ completely, but store the remaining renamings (to be applied to i_rename_maps_) in i_copy_maps_ and i_orig_prop_maps_. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00404">404</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<a class="anchor" id="a02bc6eec7ce33effdac18b8b1c0bd770"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;int&gt; UnivExpander::i_prev_occ_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The almost-final copies of the next-state variables. </p>
<p>This set is only used to overwrite renamings more efficiently. When we overwrite the renamings, then we need to update the last renaming map. The almost-final copies of the next-state variables are exactly the variables that are used as indices in the final rename map. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00420">420</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e3bf04d83d2164635bdc57d78617219"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt; UnivExpander::i_rename_maps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rename maps resulting from the expansion of the transition relation. </p>
<p>i_rename_maps_[cnt] defines how to rename state variables to the obtain the renamed version of the next-state variables for expansion number cnt. i_rename_maps_[c1][c2] gives the c1'th renaming of the state variable with index (not value!) c2. We use the index to save memory. This rename map does not only do renaming, but also constant propagation. If a certain variable is renamed to 1, then it is set to TRUE. If it is renamed to -1, then it is set to FALSE. If there are n control signals, then this vector could contain 2^n rename maps, one for each expansion, in the worst case. For certain benchmarks, this rename map alone can consume all our memory (while i_trans_ands_ still stays small). Hence, if this i_rename_maps_ grows too large, we do not build it fully. Instead, we store further renamings (to be applied to i_rename_maps_) in i_copy_maps_ and i_orig_prop_maps_ and apply them only when needed. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00382">382</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<a class="anchor" id="a150474e2dd386599d750453eec601ec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; UnivExpander::i_s_to_ren_n_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A map, renaming present-state vars to a renamed version of the next-state copy. </p>
<p><a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a> gets the winning region, and needs to expand and negate the next-state copy of the winning region. This map does two renamings in one go: (1) it renames present state variables to their corresponding next-state copy, and (2) it further renames the next-state copy of state variables to the auxiliary variables defining them in the transition relation. Originally, the transition relation <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> has special clauses that do this renaming. We remove these clauses and do the renaming with a map. This is more efficient. Otherwise, the renaming-clauses of the transition relation would get copied many many many times, which increases the size of the expanded CNFs unnecessarily. All fields starting with 'i_' (like this one) are initialized by <a class="el" href="classUnivExpander.html#a87f2309e7e1d511d9539872b08814c40" title="A helper function for resetSolverIExp(). ">initSolverIData()</a> and used by <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00363">363</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>.</p>

</div>
</div>
<a class="anchor" id="a9de6c3dba22507de35c5d5750612e423"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structCNFAnd.html">CNFAnd</a>&gt; UnivExpander::i_trans_ands_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The expansion of the transition relation for <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>
<p>We do not expand the transition relation again and again, but we do this only once and reuse it. The only thing we expand freshly each time is the next state copy of the (negation of the) winning region. All fields starting with 'i_' (like this one) are initialized by <a class="el" href="classUnivExpander.html#a87f2309e7e1d511d9539872b08814c40" title="A helper function for resetSolverIExp(). ">initSolverIData()</a> and used by <a class="el" href="classUnivExpander.html#a1d6935778cefc0b441db0d7f16933a48" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. We store the expansion of the transition relation here as a list of AND gates. Storing it as <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> would waste memory (this expansion can be very big). </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00338">338</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l02012">cleanupIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<a class="anchor" id="a053df0842220ee9fa6b5ab41a2e10253"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;int&gt;&amp; UnivExpander::n_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of next-state variables. </p>
<p>This list is often used, so we keep it as a field to increase readability of the code. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00325">325</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l00954">extrExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">initSolverCExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a65c8d362518dae708b16a4f214511306"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;int&gt;&amp; UnivExpander::s_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of present-state variables. </p>
<p>This list is often used, so we keep it as a field to increase readability of the code. </p>

<p>Definition at line <a class="el" href="UnivExpander_8h_source.html#l00304">304</a> of file <a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l00954">extrExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">initSolverCExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00309">resetSolverIExp()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l01851">simplifyTransAndsWithAbc()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="UnivExpander_8h_source.html">UnivExpander.h</a></li>
<li>src/<a class="el" href="UnivExpander_8cpp_source.html">UnivExpander.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 26 2015 08:54:58 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
