<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>demiurge: OrigUnivExpander Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classOrigUnivExpander-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OrigUnivExpander Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A utility class that can do universal expansion of given CNFs.  
 <a href="classOrigUnivExpander.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a61521e0c80376b67f7859531f86b69cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a61521e0c80376b67f7859531f86b69cb">OrigUnivExpander</a> ()</td></tr>
<tr class="memdesc:a61521e0c80376b67f7859531f86b69cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a61521e0c80376b67f7859531f86b69cb">More...</a><br/></td></tr>
<tr class="separator:a61521e0c80376b67f7859531f86b69cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd23ac105ad8c0674df2a97943d12af"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a0cd23ac105ad8c0674df2a97943d12af">~OrigUnivExpander</a> ()</td></tr>
<tr class="memdesc:a0cd23ac105ad8c0674df2a97943d12af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a0cd23ac105ad8c0674df2a97943d12af">More...</a><br/></td></tr>
<tr class="separator:a0cd23ac105ad8c0674df2a97943d12af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd12e41626b01f53ac7b8c654fa9218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218">resetSolverIExp</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_reg, <a class="el" href="classSatSolver.html">SatSolver</a> *solver_i, bool limit_size=false)</td></tr>
<tr class="memdesc:abcd12e41626b01f53ac7b8c654fa9218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the reset of solver_i in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>.  <a href="#abcd12e41626b01f53ac7b8c654fa9218">More...</a><br/></td></tr>
<tr class="separator:abcd12e41626b01f53ac7b8c654fa9218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0752883a0f7a9bb17d5eda38a7dda2a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a0752883a0f7a9bb17d5eda38a7dda2a1">resetSolverCExp</a> (<a class="el" href="classSatSolver.html">SatSolver</a> *solver_c, const vector&lt; int &gt; &amp;keep, size_t max_nr_of_signals_to_expand=1)</td></tr>
<tr class="memdesc:a0752883a0f7a9bb17d5eda38a7dda2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the reset of solver_c in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>.  <a href="#a0752883a0f7a9bb17d5eda38a7dda2a1">More...</a><br/></td></tr>
<tr class="separator:a0752883a0f7a9bb17d5eda38a7dda2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebdb1dd5210ad13ee8cdb2adfe1ec48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a6ebdb1dd5210ad13ee8cdb2adfe1ec48">addExpNxtClauseToC</a> (const vector&lt; int &gt; &amp;clause, <a class="el" href="classSatSolver.html">SatSolver</a> *solver_c)</td></tr>
<tr class="memdesc:a6ebdb1dd5210ad13ee8cdb2adfe1ec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds next-state clauses to solver_c after initialization with <a class="el" href="classOrigUnivExpander.html#a0752883a0f7a9bb17d5eda38a7dda2a1" title="Performs the reset of solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverCExp()</a>.  <a href="#a6ebdb1dd5210ad13ee8cdb2adfe1ec48">More...</a><br/></td></tr>
<tr class="separator:a6ebdb1dd5210ad13ee8cdb2adfe1ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e28c3075de86dcc7228fa547b284590"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a5e28c3075de86dcc7228fa547b284590">univExpand</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;orig, <a class="el" href="classCNF.html">CNF</a> &amp;res, const vector&lt; int &gt; &amp;vars_to_exp, const vector&lt; int &gt; &amp;keep, float rate=1.1, const map&lt; int, set&lt; int &gt; &gt; *more_deps=NULL)</td></tr>
<tr class="memdesc:a5e28c3075de86dcc7228fa547b284590"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard method for universal expansion of certain variables.  <a href="#a5e28c3075de86dcc7228fa547b284590">More...</a><br/></td></tr>
<tr class="separator:a5e28c3075de86dcc7228fa547b284590"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1ca430c08a9927733951149db492916e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a1ca430c08a9927733951149db492916e">initSolverIData</a> (bool limit_size=false)</td></tr>
<tr class="memdesc:a1ca430c08a9927733951149db492916e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>.  <a href="#a1ca430c08a9927733951149db492916e">More...</a><br/></td></tr>
<tr class="separator:a1ca430c08a9927733951149db492916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3e52a15c675f3f9dfedfb0b083ed12c4"><td class="memItemLeft" align="right" valign="top">const vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a3e52a15c675f3f9dfedfb0b083ed12c4">s_</a></td></tr>
<tr class="memdesc:a3e52a15c675f3f9dfedfb0b083ed12c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of present-state variables.  <a href="#a3e52a15c675f3f9dfedfb0b083ed12c4">More...</a><br/></td></tr>
<tr class="separator:a3e52a15c675f3f9dfedfb0b083ed12c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e61937364c1f6ae1113c3bee359ab"><td class="memItemLeft" align="right" valign="top">const vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a1e2e61937364c1f6ae1113c3bee359ab">i_</a></td></tr>
<tr class="memdesc:a1e2e61937364c1f6ae1113c3bee359ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of (uncontrollable) input variables.  <a href="#a1e2e61937364c1f6ae1113c3bee359ab">More...</a><br/></td></tr>
<tr class="separator:a1e2e61937364c1f6ae1113c3bee359ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f9918f16eb03c75dc2a97182f75bdc"><td class="memItemLeft" align="right" valign="top">const vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a55f9918f16eb03c75dc2a97182f75bdc">c_</a></td></tr>
<tr class="memdesc:a55f9918f16eb03c75dc2a97182f75bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of control signals (controllable input variables).  <a href="#a55f9918f16eb03c75dc2a97182f75bdc">More...</a><br/></td></tr>
<tr class="separator:a55f9918f16eb03c75dc2a97182f75bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21f9c6dab80e323bf9d17172fa9dc2"><td class="memItemLeft" align="right" valign="top">const vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#aee21f9c6dab80e323bf9d17172fa9dc2">n_</a></td></tr>
<tr class="memdesc:aee21f9c6dab80e323bf9d17172fa9dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of next-state variables.  <a href="#aee21f9c6dab80e323bf9d17172fa9dc2">More...</a><br/></td></tr>
<tr class="separator:aee21f9c6dab80e323bf9d17172fa9dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2a151446c62688478b7d548fca860c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a2b2a151446c62688478b7d548fca860c">i_exp_trans_</a></td></tr>
<tr class="memdesc:a2b2a151446c62688478b7d548fca860c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The expansion of the transition relation for <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>.  <a href="#a2b2a151446c62688478b7d548fca860c">More...</a><br/></td></tr>
<tr class="separator:a2b2a151446c62688478b7d548fca860c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150c22a734df707f76190a66b6eb2a44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a150c22a734df707f76190a66b6eb2a44">i_max_trans_var_</a></td></tr>
<tr class="memdesc:a150c22a734df707f76190a66b6eb2a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum variable index occurring in i_exp_trans_.  <a href="#a150c22a734df707f76190a66b6eb2a44">More...</a><br/></td></tr>
<tr class="separator:a150c22a734df707f76190a66b6eb2a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a45566b24c00386d7530f4b212b42d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a03a45566b24c00386d7530f4b212b42d">i_s_to_ren_n_</a></td></tr>
<tr class="memdesc:a03a45566b24c00386d7530f4b212b42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map, renaming present-state vars to a renamed version of the next-state copy.  <a href="#a03a45566b24c00386d7530f4b212b42d">More...</a><br/></td></tr>
<tr class="separator:a03a45566b24c00386d7530f4b212b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e2c9ca2129fed67662f36834198b08"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#ab9e2c9ca2129fed67662f36834198b08">i_rename_maps_</a></td></tr>
<tr class="memdesc:ab9e2c9ca2129fed67662f36834198b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rename maps resulting from the expansion of the transition relation.  <a href="#ab9e2c9ca2129fed67662f36834198b08">More...</a><br/></td></tr>
<tr class="separator:ab9e2c9ca2129fed67662f36834198b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a13d81ac5119a0a31aa0bbb8964e25"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a49a13d81ac5119a0a31aa0bbb8964e25">i_orig_prop_maps_</a></td></tr>
<tr class="memdesc:a49a13d81ac5119a0a31aa0bbb8964e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rename maps for constant propagation in the original during expansion.  <a href="#a49a13d81ac5119a0a31aa0bbb8964e25">More...</a><br/></td></tr>
<tr class="separator:a49a13d81ac5119a0a31aa0bbb8964e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ffdcc269b3e72eae24c6744b412b4e"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a88ffdcc269b3e72eae24c6744b412b4e">c_rename_maps_</a></td></tr>
<tr class="memdesc:a88ffdcc269b3e72eae24c6744b412b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rename maps for the next-state variables for adding clauses to solver_c.  <a href="#a88ffdcc269b3e72eae24c6744b412b4e">More...</a><br/></td></tr>
<tr class="separator:a88ffdcc269b3e72eae24c6744b412b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afd2271d8565fdd4280eb9952e06f1179"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#afd2271d8565fdd4280eb9952e06f1179">OrigUnivExpander</a> (const <a class="el" href="classOrigUnivExpander.html">OrigUnivExpander</a> &amp;other)</td></tr>
<tr class="memdesc:afd2271d8565fdd4280eb9952e06f1179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#afd2271d8565fdd4280eb9952e06f1179">More...</a><br/></td></tr>
<tr class="separator:afd2271d8565fdd4280eb9952e06f1179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9bdf0d9f02ce1a84a471386fb521f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOrigUnivExpander.html">OrigUnivExpander</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrigUnivExpander.html#a7a9bdf0d9f02ce1a84a471386fb521f8">operator=</a> (const <a class="el" href="classOrigUnivExpander.html">OrigUnivExpander</a> &amp;other)</td></tr>
<tr class="memdesc:a7a9bdf0d9f02ce1a84a471386fb521f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a7a9bdf0d9f02ce1a84a471386fb521f8">More...</a><br/></td></tr>
<tr class="separator:a7a9bdf0d9f02ce1a84a471386fb521f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class that can do universal expansion of given CNFs. </p>
<p>Universal expansion of a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> with respect to certain variables is an expensive operation, especially if there are a lot of variables to expand. Hence, this operation must be implemented cleverly. For this reason, this class provides several implementations, each one tailored towards a specific application (expanding CTRL-signals in a conjuction of the transition relation with some <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the next-state variables, etc.)</p>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.2.0 </dd></dl>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00051">51</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a61521e0c80376b67f7859531f86b69cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OrigUnivExpander::OrigUnivExpander </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8cpp_source.html#l00038">38</a> of file <a class="el" href="OrigUnivExpander_8cpp_source.html">OrigUnivExpander.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0cd23ac105ad8c0674df2a97943d12af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OrigUnivExpander::~OrigUnivExpander </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8cpp_source.html#l00049">49</a> of file <a class="el" href="OrigUnivExpander_8cpp_source.html">OrigUnivExpander.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd2271d8565fdd4280eb9952e06f1179"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OrigUnivExpander::OrigUnivExpander </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOrigUnivExpander.html">OrigUnivExpander</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6ebdb1dd5210ad13ee8cdb2adfe1ec48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OrigUnivExpander::addExpNxtClauseToC </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td>
          <td class="paramname"><em>solver_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds next-state clauses to solver_c after initialization with <a class="el" href="classOrigUnivExpander.html#a0752883a0f7a9bb17d5eda38a7dda2a1" title="Performs the reset of solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverCExp()</a>. </p>
<p>After <a class="el" href="classOrigUnivExpander.html#a0752883a0f7a9bb17d5eda38a7dda2a1" title="Performs the reset of solver_c in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverCExp()</a> has been called to initialize solver_c, this method can be used to add next-state clauses to all expansions of the next-state variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>A clause over the current-state variables. It is added as clause over (all expansions of) the next state variables in solver_c. </td></tr>
    <tr><td class="paramname">solver_c</td><td>The solver to which the next-state copies of this clause should be added. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OrigUnivExpander_8cpp_source.html#l00830">830</a> of file <a class="el" href="OrigUnivExpander_8cpp_source.html">OrigUnivExpander.cpp</a>.</p>

<p>References <a class="el" href="OrigUnivExpander_8h_source.html#l00277">c_rename_maps_</a>, and <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ca430c08a9927733951149db492916e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OrigUnivExpander::initSolverIData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_size</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function for <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>
<p>Some work in <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a> needs to be done again and again when this method is called repeatedly. For instance, the expansion of the transition relation is always the same. This method performs these repeated tasks only once, and stores the resulting information in fields of this class. This way, they can then be reused by <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a> whenever needed. All fields defined by this method start with 'i_'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit_size</td><td>If set to true, then this method aborts if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> size limit defined by <a class="el" href="classOptions.html#aa59992b1b4c698ade25627bb19a7d055" title="Returns the maximum memory (in kB) to use in SAT-based learning with expansion. ">Options::getSizeLimitForExpansion()</a> is exceeded. This is supposed to prevent running out of memory during the expansion. If this flag is set to false, or omitted, then the size limit does not apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the size limit for the expansion has been exceeded during the initialization already. False if everything went OK. </dd></dl>

<p>Definition at line <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">846</a> of file <a class="el" href="OrigUnivExpander_8cpp_source.html">OrigUnivExpander.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00186">CNF::add3LitClause()</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00206">c_</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="Options_8cpp_source.html#l00544">Options::getSizeLimitForExpansion()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">AIG2CNF::getTmpDepsTrans()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00224">i_exp_trans_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00233">i_max_trans_var_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00269">i_orig_prop_maps_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00259">i_rename_maps_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00249">i_s_to_ren_n_</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00213">n_</a>, and <a class="el" href="OrigUnivExpander_8h_source.html#l00192">s_</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a9bdf0d9f02ce1a84a471386fb521f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOrigUnivExpander.html">OrigUnivExpander</a>&amp; OrigUnivExpander::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOrigUnivExpander.html">OrigUnivExpander</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="a0752883a0f7a9bb17d5eda38a7dda2a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OrigUnivExpander::resetSolverCExp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td>
          <td class="paramname"><em>solver_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nr_of_signals_to_expand</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the reset of solver_c in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>. </p>
<p>In <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>, solver_c needs to check exists x: forall i: exists x',t: W(x) &amp; T(x,i,c,x',t) &amp; W(x') where W is the winning region (a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the state variables x) and T is the transition relation with t being auxiliary variables. This method expands some of the input signals i in the transition relation T, and puts the resulting formula into solver_c. At the same time, this method also constructs a renaming map so clauses of W(x') can be added later on (using the method <a class="el" href="classOrigUnivExpander.html#a6ebdb1dd5210ad13ee8cdb2adfe1ec48" title="Adds next-state clauses to solver_c after initialization with resetSolverCExp(). ">addExpNxtClauseToC()</a>). This method is highly optimized for exactly this purpose. <a class="el" href="classOrigUnivExpander.html#a5e28c3075de86dcc7228fa547b284590" title="The standard method for universal expansion of certain variables. ">univExpand()</a> could also be used in principle, but this method has more optimizations exploiting the structure of the transition relation.</p>
<dl class="section note"><dt>Note</dt><dd>The newly created auxiliary variables are not registered in the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created. ">VarManager</a> for performance reasons (there may be zillions of new variables introduced during the expansion).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver_c</td><td>The solver into which the expanded transition relation should be stored. </td></tr>
    <tr><td class="paramname">keep</td><td>This method declares the current-state variables, the uncontrollable inputs, and the next-state variables (in their various copys) as reusable. If you also want other variables to be reusable (e.g. previous-state variables), then they can be enumerated in this vector. </td></tr>
    <tr><td class="paramname">max_nr_of_signals_to_expand</td><td>For solver_c, expansion is very costly (more than for solver_i). Hence, we usually only expand a few input variables. This parameter defines the maximum number of input signals to expand. Low values are recommended. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">576</a> of file <a class="el" href="OrigUnivExpander_8cpp_source.html">OrigUnivExpander.cpp</a>.</p>

<p>References <a class="el" href="OrigUnivExpander_8h_source.html#l00206">c_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00277">c_rename_maps_</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">AIG2CNF::getTmpDepsTrans()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00199">i_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00249">i_s_to_ren_n_</a>, <a class="el" href="classSatSolver.html#a791be541b59ef58a29a1c517fca943e7">SatSolver::incAdd2LitClause()</a>, <a class="el" href="classSatSolver.html#abca288874a1b8ab1a90cb274eb885ace">SatSolver::incAdd3LitClause()</a>, <a class="el" href="classSatSolver.html#a5b39c45cd2a1abfe96c681515dfddb77">SatSolver::incAddUnitClause()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00213">n_</a>, <a class="el" href="VarInfo_8h_source.html#l00097">VarInfo::PREV</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00192">s_</a>, and <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>.</p>

</div>
</div>
<a class="anchor" id="abcd12e41626b01f53ac7b8c654fa9218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OrigUnivExpander::resetSolverIExp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td>
          <td class="paramname"><em>solver_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_size</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the reset of solver_i in <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>. </p>
<p>In <a class="el" href="classLearnSynthSAT.html#a8727927b4e0432acb6bcea883fd2f1f9" title="Like computeWinningRegionPlain() but using universal expansion. ">LearnSynthSAT::computeWinningRegionPlainExp()</a>, solver_i needs to check exists x,i: forall c: exists x',t: W(x) &amp; T(x,i,c,x',t) &amp; !W(x') where W is the winning region (a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the state variables x) and T is the transition relation with t being auxiliary variables. This method expands the control signals c of the above formula and puts the resulting formula into the SAT solver solver_i. This method is highly optimized for this purpose. For instance, the expansion of the transition relation is done only once and reused for different winning regions. <a class="el" href="classOrigUnivExpander.html#a5e28c3075de86dcc7228fa547b284590" title="The standard method for universal expansion of certain variables. ">univExpand()</a> could also be used in principle, but this method has more optimizations exploiting the structure of the formula that needs to be expanded.</p>
<dl class="section note"><dt>Note</dt><dd>The newly created auxiliary variables are not registered in the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created. ">VarManager</a> for performance reasons (there may be zillions of new variables introduced during the expansion).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_reg</td><td>The winning region with which the solver should be initialized. </td></tr>
    <tr><td class="paramname">solver_i</td><td>The solver into which the expanded <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> should be store. </td></tr>
    <tr><td class="paramname">limit_size</td><td>If set to true, then this method aborts if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> size limit defined by <a class="el" href="classOptions.html#aa59992b1b4c698ade25627bb19a7d055" title="Returns the maximum memory (in kB) to use in SAT-based learning with expansion. ">Options::getSizeLimitForExpansion()</a> is exceeded. This is supposed to prevent running out of memory during the expansion. If this flag is set to false, or omitted, then the size limit does not apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the size limit for the expansion has been exceeded. False if everything went OK (or nothing was checked because limit_size was set to false). </dd></dl>

<p>Definition at line <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">245</a> of file <a class="el" href="OrigUnivExpander_8cpp_source.html">OrigUnivExpander.cpp</a>.</p>

<p>References <a class="el" href="OrigUnivExpander_8h_source.html#l00206">c_</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00306">CNF::getNrOfClauses()</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00199">i_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00224">i_exp_trans_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00233">i_max_trans_var_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00269">i_orig_prop_maps_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00259">i_rename_maps_</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00249">i_s_to_ren_n_</a>, <a class="el" href="classSatSolver.html#a791be541b59ef58a29a1c517fca943e7">SatSolver::incAdd2LitClause()</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a5b39c45cd2a1abfe96c681515dfddb77">SatSolver::incAddUnitClause()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="OrigUnivExpander_8h_source.html#l00192">s_</a>, and <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e28c3075de86dcc7228fa547b284590"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OrigUnivExpander::univExpand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars_to_exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rate</em> = <code>1.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; int, set&lt; int &gt; &gt; *&#160;</td>
          <td class="paramname"><em>more_deps</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The standard method for universal expansion of certain variables. </p>
<dl class="section note"><dt>Note</dt><dd>The newly created auxiliary variables are not registered in the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created. ">VarManager</a> for performance reasons (there may be zillions of new variables introduced during the expansion).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>The original <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> in which we perform universal expansion. </td></tr>
    <tr><td class="paramname">res</td><td>An empty <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. This is where the result will be stored. </td></tr>
    <tr><td class="paramname">vars_to_exp</td><td>The list of variables to expand. </td></tr>
    <tr><td class="paramname">keep</td><td>The list of variables that are quantified outside of the vars_to_exp and should hence not be renamed during the expansion. </td></tr>
    <tr><td class="paramname">rate</td><td>A number between 0 and 1. It defines which fraction of the vars_to_exp should be expanded. Value 0.4 means that 40% of the vars_to_exp should be expanded. Use a value larger than 1 (or omit this parameter) if you want to be sure that every signal is expanded. </td></tr>
    <tr><td class="paramname">more_deps</td><td>Additional dependencies that can be exploited during expansion. This map must map user-defined (temporary) variables to a set of other variables that define these variables. Don't include the dependencies of the temporary variables used to encode the transition relation, and don't include the dependencies of the next-state variables because they are automatically read from <a class="el" href="classAIG2CNF.html" title="Transforms an AIGER specification into CNF. ">AIG2CNF</a>. But if you have additional temporary variables, e.g., from Tseitin encoding some formula part then the expansion can benefit from dependency information (it needs to copy less). In any case: more_deps[i] must only contain variables in keep or vars_to_exp. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OrigUnivExpander_8cpp_source.html#l00055">55</a> of file <a class="el" href="OrigUnivExpander_8cpp_source.html">OrigUnivExpander.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00571">CNF::appendVarsTo()</a>, <a class="el" href="defines_8h_source.html#l00138">DASSERT</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">AIG2CNF::getTmpDepsTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, and <a class="el" href="CNF_8cpp_source.html#l00294">CNF::swapWith()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a55f9918f16eb03c75dc2a97182f75bdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;int&gt;&amp; OrigUnivExpander::c_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of control signals (controllable input variables). </p>
<p>This list is often used, so we keep it as a field to increase readability of the code. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00206">206</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">resetSolverCExp()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a88ffdcc269b3e72eae24c6744b412b4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt; OrigUnivExpander::c_rename_maps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rename maps for the next-state variables for adding clauses to solver_c. </p>
<p>c_rename_maps_[i] is the rename map for present-state variables to the i-th copy of the next state variables. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00277">277</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00830">addExpNxtClauseToC()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">resetSolverCExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e2e61937364c1f6ae1113c3bee359ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;int&gt;&amp; OrigUnivExpander::i_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of (uncontrollable) input variables. </p>
<p>This list is often used, so we keep it as a field to increase readability of the code. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00199">199</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">resetSolverCExp()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b2a151446c62688478b7d548fca860c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> OrigUnivExpander::i_exp_trans_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The expansion of the transition relation for <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>
<p>We do not expand the transition relation again and again, but we do this only once and reuse it. The only thing we expand freshly each time is the next state copy of the (negation of the) winning region. All fields starting with 'i_' (like this one) are initialized by <a class="el" href="classOrigUnivExpander.html#a1ca430c08a9927733951149db492916e" title="A helper function for resetSolverIExp(). ">initSolverIData()</a> and used by <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00224">224</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a150c22a734df707f76190a66b6eb2a44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OrigUnivExpander::i_max_trans_var_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum variable index occurring in i_exp_trans_. </p>
<p>That is, for <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>, i_max_trans_var_ + 1 is the next fresh <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> variable. All fields starting with 'i_' (like this one) are initialized by <a class="el" href="classOrigUnivExpander.html#a1ca430c08a9927733951149db492916e" title="A helper function for resetSolverIExp(). ">initSolverIData()</a> and used by <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00233">233</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a49a13d81ac5119a0a31aa0bbb8964e25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt; OrigUnivExpander::i_orig_prop_maps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rename maps for constant propagation in the original during expansion. </p>
<p>i_orig_prop_maps_[c_idx] defines how to rename variables in the original when creating the copy due to expansion of the control signal c_[c_idx]. A variable can only be renamed to itself, to 1 (TRUE) and to -1 (FALSE). That is, this is no real renaming but essentially only constant propagation. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00269">269</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e2c9ca2129fed67662f36834198b08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt; OrigUnivExpander::i_rename_maps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rename maps resulting from the expansion of the transition relation. </p>
<p>i_rename_maps_[c_idx] defines how to rename variables when expanding the control signal c_[c_idx]. This rename map does not only do renaming, but also constant propagation. If a certain variable is renamed to 1, then it is set to TRUE. If it is renamed to -1, then it is set to FALSE. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00259">259</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a03a45566b24c00386d7530f4b212b42d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; OrigUnivExpander::i_s_to_ren_n_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A map, renaming present-state vars to a renamed version of the next-state copy. </p>
<p><a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a> gets the winning region, and needs to expand and negate the next-state copy of the winning region. This map does two renamings in one go: (1) it renames present state variables to their corresponding next-state copy, and (2) it further renames the next-state copy of state variables to the auxiliary variables defining them in the transition relation. Originally, the transition relation <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> has special clauses that do this renaming. We remove these clauses and do the renaming with a map. This is more efficient. Otherwise, the renaming-clauses of the transition relation would get copied many many many times, which increases the size of the expanded CNFs unnecessarily. All fields starting with 'i_' (like this one) are initialized by <a class="el" href="classOrigUnivExpander.html#a1ca430c08a9927733951149db492916e" title="A helper function for resetSolverIExp(). ">initSolverIData()</a> and used by <a class="el" href="classOrigUnivExpander.html#abcd12e41626b01f53ac7b8c654fa9218" title="Performs the reset of solver_i in LearnSynthSAT::computeWinningRegionPlainExp(). ">resetSolverIExp()</a>. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00249">249</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">resetSolverCExp()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="aee21f9c6dab80e323bf9d17172fa9dc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;int&gt;&amp; OrigUnivExpander::n_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of next-state variables. </p>
<p>This list is often used, so we keep it as a field to increase readability of the code. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00213">213</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">resetSolverCExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e52a15c675f3f9dfedfb0b083ed12c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;int&gt;&amp; OrigUnivExpander::s_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of present-state variables. </p>
<p>This list is often used, so we keep it as a field to increase readability of the code. </p>

<p>Definition at line <a class="el" href="OrigUnivExpander_8h_source.html#l00192">192</a> of file <a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a>.</p>

<p>Referenced by <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">initSolverIData()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">resetSolverCExp()</a>, and <a class="el" href="OrigUnivExpander_8cpp_source.html#l00245">resetSolverIExp()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="OrigUnivExpander_8h_source.html">OrigUnivExpander.h</a></li>
<li>src/<a class="el" href="OrigUnivExpander_8cpp_source.html">OrigUnivExpander.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 26 2015 08:54:56 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
