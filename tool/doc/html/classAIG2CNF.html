<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>demiurge: AIG2CNF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classAIG2CNF-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AIG2CNF Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Transforms an AIGER specification into <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>.  
 <a href="classAIG2CNF.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2f57817266c9a882dffc8c5dab1fd3c4"><td class="memItemLeft" align="right" valign="top">typedef map&lt; int, set&lt; <a class="el" href="classVarInfo.html">VarInfo</a> &gt;<br class="typebreak"/>
 &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a2f57817266c9a882dffc8c5dab1fd3c4">DepConstIter</a></td></tr>
<tr class="memdesc:a2f57817266c9a882dffc8c5dab1fd3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for a const-iterator over the dependencies of temporary variables.  <a href="#a2f57817266c9a882dffc8c5dab1fd3c4">More...</a><br/></td></tr>
<tr class="separator:a2f57817266c9a882dffc8c5dab1fd3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa872708acbdc2bcb1bd23da9a1db2833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#aa872708acbdc2bcb1bd23da9a1db2833">initFromAig</a> (aiger *aig)</td></tr>
<tr class="memdesc:aa872708acbdc2bcb1bd23da9a1db2833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this class from an aiger structure.  <a href="#aa872708acbdc2bcb1bd23da9a1db2833">More...</a><br/></td></tr>
<tr class="separator:aa872708acbdc2bcb1bd23da9a1db2833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3be4d76137eb30a6bed5885f709f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a4e3be4d76137eb30a6bed5885f709f29">clear</a> ()</td></tr>
<tr class="memdesc:a4e3be4d76137eb30a6bed5885f709f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all the CNFs constructed by <a class="el" href="classAIG2CNF.html#aa872708acbdc2bcb1bd23da9a1db2833">initFromAig() </a>.  <a href="#a4e3be4d76137eb30a6bed5885f709f29">More...</a><br/></td></tr>
<tr class="separator:a4e3be4d76137eb30a6bed5885f709f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f56e622e210868ffafcdee4ad9fea2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a02f56e622e210868ffafcdee4ad9fea2">getTrans</a> () const </td></tr>
<tr class="memdesc:a02f56e622e210868ffafcdee4ad9fea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transition relation in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>.  <a href="#a02f56e622e210868ffafcdee4ad9fea2">More...</a><br/></td></tr>
<tr class="separator:a02f56e622e210868ffafcdee4ad9fea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8899c00619a3c182e78d21b988d748"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#add8899c00619a3c182e78d21b988d748">getTransEqT</a> () const </td></tr>
<tr class="memdesc:add8899c00619a3c182e78d21b988d748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the transition holds iff a certain literal is true.  <a href="#add8899c00619a3c182e78d21b988d748">More...</a><br/></td></tr>
<tr class="separator:add8899c00619a3c182e78d21b988d748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f4e351f8d3f3f73b80e70849f00fe1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a50f4e351f8d3f3f73b80e70849f00fe1">getT</a> () const </td></tr>
<tr class="memdesc:a50f4e351f8d3f3f73b80e70849f00fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the literal assigned by <a class="el" href="classAIG2CNF.html#add8899c00619a3c182e78d21b988d748">getTransEqT() </a>.  <a href="#a50f4e351f8d3f3f73b80e70849f00fe1">More...</a><br/></td></tr>
<tr class="separator:a50f4e351f8d3f3f73b80e70849f00fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71ea2d9f9280c8bb3d20d109e892e2d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#ac71ea2d9f9280c8bb3d20d109e892e2d">getSafeStates</a> () const </td></tr>
<tr class="memdesc:ac71ea2d9f9280c8bb3d20d109e892e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of safe states.  <a href="#ac71ea2d9f9280c8bb3d20d109e892e2d">More...</a><br/></td></tr>
<tr class="separator:ac71ea2d9f9280c8bb3d20d109e892e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6e6af6ac83605669918008b12d30e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a7e6e6af6ac83605669918008b12d30e7">getUnsafeStates</a> () const </td></tr>
<tr class="memdesc:a7e6e6af6ac83605669918008b12d30e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of unsafe states.  <a href="#a7e6e6af6ac83605669918008b12d30e7">More...</a><br/></td></tr>
<tr class="separator:a7e6e6af6ac83605669918008b12d30e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04a7275b64d96d7c16c5c8c8668b93c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#af04a7275b64d96d7c16c5c8c8668b93c">getNextSafeStates</a> () const </td></tr>
<tr class="memdesc:af04a7275b64d96d7c16c5c8c8668b93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is safe.  <a href="#af04a7275b64d96d7c16c5c8c8668b93c">More...</a><br/></td></tr>
<tr class="separator:af04a7275b64d96d7c16c5c8c8668b93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bec5428f2f5f6efa41810a308ebbe1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a1bec5428f2f5f6efa41810a308ebbe1f">getNextUnsafeStates</a> () const </td></tr>
<tr class="memdesc:a1bec5428f2f5f6efa41810a308ebbe1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is unsafe.  <a href="#a1bec5428f2f5f6efa41810a308ebbe1f">More...</a><br/></td></tr>
<tr class="separator:a1bec5428f2f5f6efa41810a308ebbe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20be327c24ca3ed7493b56a254d6a63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#ae20be327c24ca3ed7493b56a254d6a63">getInitial</a> () const </td></tr>
<tr class="memdesc:ae20be327c24ca3ed7493b56a254d6a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the initial state.  <a href="#ae20be327c24ca3ed7493b56a254d6a63">More...</a><br/></td></tr>
<tr class="separator:ae20be327c24ca3ed7493b56a254d6a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4076dda7514fc3015867494be3aaac"><td class="memItemLeft" align="right" valign="top">const map&lt; int, set&lt; <a class="el" href="classVarInfo.html">VarInfo</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a3f4076dda7514fc3015867494be3aaac">getTmpDeps</a> () const </td></tr>
<tr class="memdesc:a3f4076dda7514fc3015867494be3aaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns dependencies of temporary variables in the transition relation.  <a href="#a3f4076dda7514fc3015867494be3aaac">More...</a><br/></td></tr>
<tr class="separator:a3f4076dda7514fc3015867494be3aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d64a22868a17f6c3cf8dd3af88f02b"><td class="memItemLeft" align="right" valign="top">const map&lt; int, set&lt; <a class="el" href="classVarInfo.html">VarInfo</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a87d64a22868a17f6c3cf8dd3af88f02b">getTmpDepsTrans</a> ()</td></tr>
<tr class="memdesc:a87d64a22868a17f6c3cf8dd3af88f02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns transitive dependencies of temporary variables in the transition relation.  <a href="#a87d64a22868a17f6c3cf8dd3af88f02b">More...</a><br/></td></tr>
<tr class="separator:a87d64a22868a17f6c3cf8dd3af88f02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4358961404803c1be6b73f5aada4ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a3f4358961404803c1be6b73f5aada4ce">isTrueInTrans</a> ()</td></tr>
<tr class="memdesc:a3f4358961404803c1be6b73f5aada4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if variable "1" should be defined as TRUE in the transition relation.  <a href="#a3f4358961404803c1be6b73f5aada4ce">More...</a><br/></td></tr>
<tr class="separator:a3f4358961404803c1be6b73f5aada4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7a4db833018cb851ab608004b4e651e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classAIG2CNF.html">AIG2CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a7a4db833018cb851ab608004b4e651e4">instance</a> ()</td></tr>
<tr class="memdesc:a7a4db833018cb851ab608004b4e651e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the one and only instance of this class.  <a href="#a7a4db833018cb851ab608004b4e651e4">More...</a><br/></td></tr>
<tr class="separator:a7a4db833018cb851ab608004b4e651e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aedcb9a8efe69fe03721fdc17c5d11bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#aedcb9a8efe69fe03721fdc17c5d11bfc">trans_</a></td></tr>
<tr class="memdesc:aedcb9a8efe69fe03721fdc17c5d11bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transition relation in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>.  <a href="#aedcb9a8efe69fe03721fdc17c5d11bfc">More...</a><br/></td></tr>
<tr class="separator:aedcb9a8efe69fe03721fdc17c5d11bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e9b65092f626865a4aa541a48e4f1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#af7e9b65092f626865a4aa541a48e4f1b">trans_eq_t_</a></td></tr>
<tr class="memdesc:af7e9b65092f626865a4aa541a48e4f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the transition holds iff <a class="el" href="classAIG2CNF.html#af2a7f6ecdcec3b5b2f37a11b0adde65a">t_ </a> is true.  <a href="#af7e9b65092f626865a4aa541a48e4f1b">More...</a><br/></td></tr>
<tr class="separator:af7e9b65092f626865a4aa541a48e4f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a7f6ecdcec3b5b2f37a11b0adde65a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#af2a7f6ecdcec3b5b2f37a11b0adde65a">t_</a></td></tr>
<tr class="memdesc:af2a7f6ecdcec3b5b2f37a11b0adde65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The literal assigned by <a class="el" href="classAIG2CNF.html#af7e9b65092f626865a4aa541a48e4f1b">trans_eq_t_ </a>.  <a href="#af2a7f6ecdcec3b5b2f37a11b0adde65a">More...</a><br/></td></tr>
<tr class="separator:af2a7f6ecdcec3b5b2f37a11b0adde65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394d2a3600bc3bec864cf08acac61437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a394d2a3600bc3bec864cf08acac61437">safe_</a></td></tr>
<tr class="memdesc:a394d2a3600bc3bec864cf08acac61437"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of safe states.  <a href="#a394d2a3600bc3bec864cf08acac61437">More...</a><br/></td></tr>
<tr class="separator:a394d2a3600bc3bec864cf08acac61437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfcf3a27261a2283a99362d2527d64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#afbfcf3a27261a2283a99362d2527d64f">unsafe_</a></td></tr>
<tr class="memdesc:afbfcf3a27261a2283a99362d2527d64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of unsafe states.  <a href="#afbfcf3a27261a2283a99362d2527d64f">More...</a><br/></td></tr>
<tr class="separator:afbfcf3a27261a2283a99362d2527d64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057c6a3159253267c99f115b7d724ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a057c6a3159253267c99f115b7d724ee2">next_safe_</a></td></tr>
<tr class="memdesc:a057c6a3159253267c99f115b7d724ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is safe.  <a href="#a057c6a3159253267c99f115b7d724ee2">More...</a><br/></td></tr>
<tr class="separator:a057c6a3159253267c99f115b7d724ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0430b9b4ff38a7b0ae339fb0abd191c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a0430b9b4ff38a7b0ae339fb0abd191c9">next_unsafe_</a></td></tr>
<tr class="memdesc:a0430b9b4ff38a7b0ae339fb0abd191c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is unsafe.  <a href="#a0430b9b4ff38a7b0ae339fb0abd191c9">More...</a><br/></td></tr>
<tr class="separator:a0430b9b4ff38a7b0ae339fb0abd191c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d0b27b61d672ecf2bd007e0d473439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a83d0b27b61d672ecf2bd007e0d473439">initial_</a></td></tr>
<tr class="memdesc:a83d0b27b61d672ecf2bd007e0d473439"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the initial state.  <a href="#a83d0b27b61d672ecf2bd007e0d473439">More...</a><br/></td></tr>
<tr class="separator:a83d0b27b61d672ecf2bd007e0d473439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8617860055dfa8cbcc1f572676f57b84"><td class="memItemLeft" align="right" valign="top">map&lt; int, set&lt; <a class="el" href="classVarInfo.html">VarInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a8617860055dfa8cbcc1f572676f57b84">trans_tmp_deps_</a></td></tr>
<tr class="memdesc:a8617860055dfa8cbcc1f572676f57b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variables on which a temporary variable of the transition relation depends.  <a href="#a8617860055dfa8cbcc1f572676f57b84">More...</a><br/></td></tr>
<tr class="separator:a8617860055dfa8cbcc1f572676f57b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3c2e9acc3357e837349e30447b93c3"><td class="memItemLeft" align="right" valign="top">map&lt; int, set&lt; <a class="el" href="classVarInfo.html">VarInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a7e3c2e9acc3357e837349e30447b93c3">trans_tmp_deps_trans_</a></td></tr>
<tr class="memdesc:a7e3c2e9acc3357e837349e30447b93c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like trans_tmp_deps_, but stores (transitive) dependencies non non-temporary vars.  <a href="#a7e3c2e9acc3357e837349e30447b93c3">More...</a><br/></td></tr>
<tr class="separator:a7e3c2e9acc3357e837349e30447b93c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a46853e81b9c2be9dc9dab2d080355d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a0a46853e81b9c2be9dc9dab2d080355d">true_in_trans_</a></td></tr>
<tr class="memdesc:a0a46853e81b9c2be9dc9dab2d080355d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating if the transition relation should define the var "1" as true.  <a href="#a0a46853e81b9c2be9dc9dab2d080355d">More...</a><br/></td></tr>
<tr class="separator:a0a46853e81b9c2be9dc9dab2d080355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2da966a41a8ff74e6ecebf0d1d3d3829"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a2da966a41a8ff74e6ecebf0d1d3d3829">AIG2CNF</a> ()</td></tr>
<tr class="memdesc:a2da966a41a8ff74e6ecebf0d1d3d3829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a2da966a41a8ff74e6ecebf0d1d3d3829">More...</a><br/></td></tr>
<tr class="separator:a2da966a41a8ff74e6ecebf0d1d3d3829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97283bcce3d32f458ed7717b452e931"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#ab97283bcce3d32f458ed7717b452e931">~AIG2CNF</a> ()</td></tr>
<tr class="memdesc:ab97283bcce3d32f458ed7717b452e931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab97283bcce3d32f458ed7717b452e931">More...</a><br/></td></tr>
<tr class="separator:ab97283bcce3d32f458ed7717b452e931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3b1fac1ae78ff3c9dac99cd7b63d9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a2b3b1fac1ae78ff3c9dac99cd7b63d9d">AIG2CNF</a> (const <a class="el" href="classAIG2CNF.html">AIG2CNF</a> &amp;other)</td></tr>
<tr class="memdesc:a2b3b1fac1ae78ff3c9dac99cd7b63d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a2b3b1fac1ae78ff3c9dac99cd7b63d9d">More...</a><br/></td></tr>
<tr class="separator:a2b3b1fac1ae78ff3c9dac99cd7b63d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee82fcfe444616f35078957ec762489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAIG2CNF.html">AIG2CNF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#a1ee82fcfe444616f35078957ec762489">operator=</a> (const <a class="el" href="classAIG2CNF.html">AIG2CNF</a> &amp;other)</td></tr>
<tr class="memdesc:a1ee82fcfe444616f35078957ec762489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a1ee82fcfe444616f35078957ec762489">More...</a><br/></td></tr>
<tr class="separator:a1ee82fcfe444616f35078957ec762489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:ae298ae4804c63f5bac4dfab7528d35ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classAIG2CNF.html">AIG2CNF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIG2CNF.html#ae298ae4804c63f5bac4dfab7528d35ad">instance_</a> = NULL</td></tr>
<tr class="memdesc:ae298ae4804c63f5bac4dfab7528d35ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The one and only instance of this class.  <a href="#ae298ae4804c63f5bac4dfab7528d35ad">More...</a><br/></td></tr>
<tr class="separator:ae298ae4804c63f5bac4dfab7528d35ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transforms an AIGER specification into <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. </p>
<p>This class creates <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> formulas representing the transition relation as well as the initial state, and the set of safe states from an AIGER specification. It does not parse the AIGER file itself, but expects that this has already been done with the AIGER utility tools (see <a href="http://fmv.jku.at/aiger/">http://fmv.jku.at/aiger/</a>). This class then analyzes the resulting 'aiger' structure to build the corresponding CNFs. It is compatible with AIGER version 1.9.4. This class can parse AIGER structures that are compatible with input format for the synthesis competition (see <a href="http://www.syntcomp.org/">http://www.syntcomp.org/</a>). That is, the AIGER structure is expected to have exactly one output: This output signals that an error occurred. The synthesis problem addressed by this tool is to prevent the error-output form over becoming TRUE. Controllable inputs are identified via their name. If an input signal has a name that starts with 'controllable_', then it is considered as controllable.</p>
<p>The resulting transition relation is a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> T(x,i,c,x') that talks about the current state bits x, the uncontrollable inputs i, the controllable inputs c, and the next state copies x' of the state bits x. The transition relation is </p>
<ul>
<li>
complete, i.e., forall x,i,c: exists x': T(x,i,c,x'). </li>
<li>
deterministic, i.e., forall x,i,c,x1',x2': (T(x,i,c,x1') AND T(x,i,c,x2')) implies (x1' = x2') </li>
</ul>
<p>This means: for every state and input, the next state is uniquely defined.</p>
<p>There is only one initial state. It is the state where all state-bits are set to FALSE. (This may change with newer AIGER versions in the future).</p>
<p>The set of safe states is identified by one special state bit. This special state bit does not exist in the original AIGER file but is introduced by this class. This transformation (encoded in the transition relation) is supposed to make the life of the synthesis algorithms easier.</p>
<p>This class is implemented as a Singleton. That is, you cannot instantiate objects of this class with the constructor. Use the method <a class="el" href="classAIG2CNF.html#a7a4db833018cb851ab608004b4e651e4">instance() </a> to obtain the one and only instance of this class.</p>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.2.0 </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00080">80</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a2f57817266c9a882dffc8c5dab1fd3c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; int, set&lt; <a class="el" href="classVarInfo.html">VarInfo</a> &gt; &gt;::const_iterator <a class="el" href="classAIG2CNF.html#a2f57817266c9a882dffc8c5dab1fd3c4">AIG2CNF::DepConstIter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type for a const-iterator over the dependencies of temporary variables. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00289">289</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2da966a41a8ff74e6ecebf0d1d3d3829"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AIG2CNF::AIG2CNF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The constructor is disabled (set private) as this method is implemented as a Singleton. Use the method <a class="el" href="classAIG2CNF.html#a7a4db833018cb851ab608004b4e651e4">instance() </a> to obtain the one and only instance of this class. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00322">322</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00042">instance()</a>.</p>

</div>
</div>
<a class="anchor" id="ab97283bcce3d32f458ed7717b452e931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AIG2CNF::~AIG2CNF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The destructor is disabled (set private) as this method is implemented as a Singleton. One cannot instantiate objects of this class, so there is no need to be able to delete them. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00328">328</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b3b1fac1ae78ff3c9dac99cd7b63d9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AIG2CNF::AIG2CNF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAIG2CNF.html">AIG2CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4e3be4d76137eb30a6bed5885f709f29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AIG2CNF::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all the CNFs constructed by <a class="el" href="classAIG2CNF.html#aa872708acbdc2bcb1bd23da9a1db2833">initFromAig() </a>. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00210">210</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="AIG2CNF_8h_source.html#l00370">initial_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00351">next_safe_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00360">next_unsafe_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00333">safe_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00324">t_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00306">trans_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00316">trans_eq_t_</a>, and <a class="el" href="AIG2CNF_8h_source.html#l00342">unsafe_</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="ae20be327c24ca3ed7493b56a254d6a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCNF.html">CNF</a> &amp; AIG2CNF::getInitial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the initial state. </p>
<p>There is exactly one initial state (this is a restriction imposed by the AIGER format which serves as input for our tool). Furthermore, the initial state is always characterized by having all state bits set to FALSE. However, this may change with future AIGER versions.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the initial state. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00265">265</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00370">initial_</a>.</p>

</div>
</div>
<a class="anchor" id="af04a7275b64d96d7c16c5c8c8668b93c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCNF.html">CNF</a> &amp; AIG2CNF::getNextSafeStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is safe. </p>
<p>The set of safe next states is actually characterized by one single state bit, namely the next states where the variable <a class="el" href="classVarManager.html#ac1a84b367c26dfc5ee9e612f7d61b288" title="Returns the one and only instance of this class. ">VarManager::instance()</a>.getNextErrorStateVar() is FALSE. The returned <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts exactly this.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is safe. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00253">253</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00351">next_safe_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>.</p>

</div>
</div>
<a class="anchor" id="a1bec5428f2f5f6efa41810a308ebbe1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCNF.html">CNF</a> &amp; AIG2CNF::getNextUnsafeStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is unsafe. </p>
<p>The set of unsafe next states is actually characterized by one single state bit, namely the next states where the variable <a class="el" href="classVarManager.html#ac1a84b367c26dfc5ee9e612f7d61b288" title="Returns the one and only instance of this class. ">VarManager::instance()</a>.getNextErrorStateVar() is TRUE. The returned <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts exactly this.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is unsafe. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00259">259</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00360">next_unsafe_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="ac71ea2d9f9280c8bb3d20d109e892e2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCNF.html">CNF</a> &amp; AIG2CNF::getSafeStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of safe states. </p>
<p>The set of safe states is actually characterized by one single state bit, namely the states where the variable <a class="el" href="classVarManager.html#ac1a84b367c26dfc5ee9e612f7d61b288" title="Returns the one and only instance of this class. ">VarManager::instance()</a>.getPresErrorStateVar() is FALSE. The returned <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts exactly this.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of safe states. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00241">241</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00333">safe_</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00701">ClauseExplorerSAT::ClauseExplorerSAT()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00408">LearnSynthQBFInc::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">LearnSynthQBF::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">LearnSynthQBFInd::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00565">LearnSynthQBFInc::computeWinningRegionAllPool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00488">LearnSynthQBFInc::computeWinningRegionAllPush()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00122">LearnSynthQBFInc::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">LearnSynthQBF::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">LearnSynthQBFInd::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00273">LearnSynthQBFInc::computeWinningRegionOnePool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00199">LearnSynthQBFInc::computeWinningRegionOnePush()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">LearnSynthQBF::computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>.</p>

</div>
</div>
<a class="anchor" id="a50f4e351f8d3f3f73b80e70849f00fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AIG2CNF::getT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the literal assigned by <a class="el" href="classAIG2CNF.html#add8899c00619a3c182e78d21b988d748">getTransEqT() </a>. </p>
<p>The method <a class="el" href="classAIG2CNF.html#add8899c00619a3c182e78d21b988d748">getTransEqT() </a> returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> that asserts T(x,i,c,x') &lt;-&gt; l, where l is the literal returned by this method. This can be useful if you need the negated transition relation, if you want to use the the transition relation in some complicated formula, or if your formula should contain the transition relation several times (e.g. A &amp; T | B &amp; !T) .</p>
<dl class="section return"><dt>Returns</dt><dd>The literal assigned by <a class="el" href="classAIG2CNF.html#add8899c00619a3c182e78d21b988d748">getTransEqT() </a> </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00235">235</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00324">t_</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00575">TemplateSynth::syntQBF()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l02502">TemplExplorer::syntQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f4076dda7514fc3015867494be3aaac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt; int, set&lt; <a class="el" href="classVarInfo.html">VarInfo</a> &gt; &gt; &amp; AIG2CNF::getTmpDeps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns dependencies of temporary variables in the transition relation. </p>
<p>For each temporary variable that has been introduced when encoding the transition relation into <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>, the returned map stores on which other variables (state variables, inputs, or other temporary variables) a certain temporary CNF-variable depends on. This information can be useful in optimizations: For instance, if a certain temporary variable only depends on state-variables and uncontrollable inputs, the control signals can be allowed to depend on such a temporary variable during circuit extraction.</p>
<dl class="section return"><dt>Returns</dt><dd>The dependencies of temporary variables in the transition relation as a map from temporary <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> variables to the set of other variables on which the respective variables depend. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00271">271</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00382">trans_tmp_deps_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">UnivExpander::initSolverCExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">UnivExpander::initSolverIData()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l01039">ParExtractorWorker::insertMissingAndFromTrans()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">LearningImplExtractor::insertMissingAndFromTrans()</a>.</p>

</div>
</div>
<a class="anchor" id="a87d64a22868a17f6c3cf8dd3af88f02b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt; int, set&lt; <a class="el" href="classVarInfo.html">VarInfo</a> &gt; &gt; &amp; AIG2CNF::getTmpDepsTrans </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns transitive dependencies of temporary variables in the transition relation. </p>
<p>For each temporary variable that has been introduced when encoding the transition relation into <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>, the returned map stores on which other non-temporary variables (state variables, or controllable or uncontrollable inputs) a certain temporary CNF-variable depends on. That is, in contrast to <a class="el" href="classAIG2CNF.html#a3f4076dda7514fc3015867494be3aaac" title="Returns dependencies of temporary variables in the transition relation. ">getTmpDeps</a>, dependencies on other temporary variables are represented by taking their dependencies on state variables and (uncontrollable and controllable) inputs. This information can be useful in optimizations: For instance, if a certain temporary variable only depends on state-variables and uncontrollable inputs, the control signals can be allowed to depend on such a temporary variable during circuit extraction.</p>
<dl class="section return"><dt>Returns</dt><dd>The transitive dependencies of temporary variables in the transition relation as a which the respective variables depend. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00278">278</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>, <a class="el" href="AIG2CNF_8h_source.html#l00382">trans_tmp_deps_</a>, and <a class="el" href="AIG2CNF_8h_source.html#l00392">trans_tmp_deps_trans_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">OrigUnivExpander::initSolverIData()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">LearningImplExtractor::LearningImplExtractor()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00193">ParExtractorWorker::ParExtractorWorker()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">OrigUnivExpander::resetSolverCExp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00553">ParExtractorWorker::runSATDep()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00055">OrigUnivExpander::univExpand()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00113">UnivExpander::univExpand()</a>.</p>

</div>
</div>
<a class="anchor" id="a02f56e622e210868ffafcdee4ad9fea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCNF.html">CNF</a> &amp; AIG2CNF::getTrans </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the transition relation in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. </p>
<p>The returned transition relation is a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> T(x,i,c,x') that talks about the current state bits x, the uncontrollable inputs i, the controllable inputs c, and the next state copies x' of the state bits x. The transition relation is </p>
<ul>
<li>
complete, i.e., forall x,i,c: exists x': T(x,i,c,x'). </li>
<li>
deterministic, i.e., forall x,i,c,x1',x2': (T(x,i,c,x1') AND T(x,i,c,x2')) implies (x1' = x2') </li>
</ul>
<p>This means: for every state and input, the next state is uniquely defined.</p>
<dl class="section return"><dt>Returns</dt><dd>The transition relation in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00223">223</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00306">trans_</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00659">TemplateSynth::check()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02611">TemplExplorer::check()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00954">UnivExpander::extrExp()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">UnivExpander::initSolverCExp()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">OrigUnivExpander::initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">UnivExpander::initSolverIData()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd::LearnSynthQBFInd()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00043">LearnSynthSAT::LearnSynthSAT()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00119">PrevStateInfo::PrevStateInfo()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">OrigUnivExpander::resetSolverCExp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00553">ParExtractorWorker::runSATDep()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00607">TemplateSynth::syntSAT()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l02544">TemplExplorer::syntSAT()</a>.</p>

</div>
</div>
<a class="anchor" id="add8899c00619a3c182e78d21b988d748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCNF.html">CNF</a> &amp; AIG2CNF::getTransEqT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the transition holds iff a certain literal is true. </p>
<p>The returned <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts T(x,i,c,x') &lt;-&gt; l, where l is the literal returned by <a class="el" href="classAIG2CNF.html#a50f4e351f8d3f3f73b80e70849f00fe1">getT() </a>. This can be useful if you need the negated transition relation, if you want to use the the transition relation in some complicated formula, or if your formula should contain the transition relation several times (e.g. A &amp; T | B &amp; !T) .</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the transition holds iff a certain literal is true. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00229">229</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00316">trans_eq_t_</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00575">TemplateSynth::syntQBF()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l02502">TemplExplorer::syntQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e6e6af6ac83605669918008b12d30e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCNF.html">CNF</a> &amp; AIG2CNF::getUnsafeStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of unsafe states. </p>
<p>The set of unsafe states is actually characterized by one single state bit, namely the states where the variable <a class="el" href="classVarManager.html#ac1a84b367c26dfc5ee9e612f7d61b288" title="Returns the one and only instance of this class. ">VarManager::instance()</a>.getPresErrorStateVar() is TRUE. The returned <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts exactly this.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of unsafe states. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00247">247</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00342">unsafe_</a>.</p>

</div>
</div>
<a class="anchor" id="aa872708acbdc2bcb1bd23da9a1db2833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AIG2CNF::initFromAig </td>
          <td>(</td>
          <td class="paramtype">aiger *&#160;</td>
          <td class="paramname"><em>aig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this class from an aiger structure. </p>
<p>This method actually builds the CNFs formulas representing the transition relation as well as the initial state, and the set of safe states from an AIGER specification. This is where all the magic happens. This method is called once in beginning before a back-end is started. The back-ends can then access the constructed CNFs. This method also initializes the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created. ">VarManager</a> with the correct sets of variables.</p>
<p>This method can parse AIGER structures that are compatible with input format for the synthesis competition (see <a href="http://www.syntcomp.org/">http://www.syntcomp.org/</a>). That is, the AIGER structure is expected to have exactly one output: This output signals that an error occurred. The synthesis problem addressed by this tool is to prevent the error-output form over becoming TRUE. Controllable inputs are identified via their name. If an input signal has a name that starts with 'controllable_', then it is considered as controllable.</p>
<p>The resulting transition relation is a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> T(x,i,c,x') that talks about the current state bits x, the uncontrollable inputs i, the controllable inputs c, and the next state copies x' of the state bits x. The transition relation is </p>
<ul>
<li>
complete, i.e., forall x,i,c: exists x': T(x,i,c,x'). </li>
<li>
deterministic, i.e., forall x,i,c,x1',x2': (T(x,i,c,x1') AND T(x,i,c,x2')) implies (x1' = x2') </li>
</ul>
<p>This means: for every state and input, the next state is uniquely defined.</p>
<p>There is only one initial state. It is the state where all state-bits are set to FALSE. (This may change with newer AIGER versions in the future).</p>
<p>The set of safe states is identified by one special state bit. This special state bit does not exist in the original AIGER file but is introduced by this class. This transformation (encoded in the transition relation) is supposed to make the life of the synthesis algorithms easier.</p>
<dl class="section pre"><dt>Precondition</dt><dd>aig != NULL </dd>
<dd>
aig-&gt;num_outputs == 1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aig</td><td>The aiger structure as parsed by the AIGER utilities. The current implementation assumes version 1.9.4 of the AIGER utilities. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00051">51</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00169">CNF::add1LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00186">CNF::add3LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="VarManager_8cpp_source.html#l00274">VarManager::aigLitToCnfLit()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00267">VarManager::getInfo()</a>, <a class="el" href="VarManager_8cpp_source.html#l00326">VarManager::getNextErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00320">VarManager::getPresErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00092">VarManager::initFromAig()</a>, <a class="el" href="AIG2CNF_8h_source.html#l00370">initial_</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8h_source.html#l00351">next_safe_</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="AIG2CNF_8h_source.html#l00360">next_unsafe_</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="AIG2CNF_8h_source.html#l00333">safe_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00324">t_</a>, <a class="el" href="StringUtils_8cpp_source.html#l00056">StringUtils::toLowerCase()</a>, <a class="el" href="AIG2CNF_8h_source.html#l00306">trans_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00316">trans_eq_t_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00382">trans_tmp_deps_</a>, <a class="el" href="AIG2CNF_8h_source.html#l00400">true_in_trans_</a>, and <a class="el" href="AIG2CNF_8h_source.html#l00342">unsafe_</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00178">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a4db833018cb851ab608004b4e651e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIG2CNF.html">AIG2CNF</a> &amp; AIG2CNF::instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the one and only instance of this class. </p>
<p>This class is implemented as a Singleton. That is, you cannot instantiate objects of this class with the constructor. Use this method to obtain the one and only instance of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>The one and only instance of this class. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00042">42</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8cpp_source.html#l00322">AIG2CNF()</a>, <a class="el" href="AIG2CNF_8h_source.html#l00444">instance_</a>, and <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>.</p>

<p>Referenced by <a class="el" href="TemplateSynth_8cpp_source.html#l00659">TemplateSynth::check()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02611">TemplExplorer::check()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00701">ClauseExplorerSAT::ClauseExplorerSAT()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01419">CounterGenSAT::compressBored()</a>, <a class="el" href="Utils_8cpp_source.html#l00502">Utils::compressNextStateCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">LearnSynthQBF::computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00408">LearnSynthQBFInc::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">LearnSynthQBF::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">LearnSynthQBFInd::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00565">LearnSynthQBFInc::computeWinningRegionAllPool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00488">LearnSynthQBFInc::computeWinningRegionAllPush()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00122">LearnSynthQBFInc::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">LearnSynthQBF::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">LearnSynthQBFInd::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00273">LearnSynthQBFInc::computeWinningRegionOnePool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00199">LearnSynthQBFInc::computeWinningRegionOnePush()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">LearnSynthQBF::computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01045">ClauseExplorerSAT::considerNewInfoFromOthers()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00502">IFM13Synth::debugCheckInvariants()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01981">LearnSynthSAT::debugCheckWinReg()</a>, <a class="el" href="Utils_8cpp_source.html#l00655">Utils::debugCheckWinReg()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00633">LearnSynthQBFInd::debugCheckWinRegReach()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00954">UnivExpander::extrExp()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00463">IFM13Synth::getGenBlockTransSolver()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02197">IFM13Explorer::getGenBlockTransSolver()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00451">IFM13Synth::getGotoNextLowerSolver()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02185">IFM13Explorer::getGotoNextLowerSolver()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01753">IFM13Explorer::IFM13Explorer()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth::IFM13Synth()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00655">UnivExpander::initSolverCExp()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00846">OrigUnivExpander::initSolverIData()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l01439">UnivExpander::initSolverIData()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l01039">ParExtractorWorker::insertMissingAndFromTrans()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">LearningImplExtractor::insertMissingAndFromTrans()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">LearningImplExtractor::LearningImplExtractor()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF::LearnSynthQBF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd::LearnSynthQBFInd()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00043">LearnSynthSAT::LearnSynthSAT()</a>, <a class="el" href="main_8cpp_source.html#l00178">main()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01564">ClauseMinimizerQBF::minimizeClausesInc()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01674">ClauseMinimizerQBF::minimizeClausesNoInc()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00193">ParExtractorWorker::ParExtractorWorker()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00119">PrevStateInfo::PrevStateInfo()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00897">LearnSynthQBFInc::recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00565">LearnSynthQBF::recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">LearnSynthQBFInd::recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00920">LearnSynthQBFInc::recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00588">LearnSynthQBF::recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">LearnSynthQBFInd::recomputeGenCNF()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00576">OrigUnivExpander::resetSolverCExp()</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00309">UnivExpander::resetSolverIExp()</a>, <a class="el" href="QBFCertImplExtractor_8cpp_source.html#l00063">QBFCertImplExtractor::run()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00391">ParallelLearner::run()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">LearningImplExtractor::runLearningQBF()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00284">LearningImplExtractor::runLearningQBFInc()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l01128">ParExtractorQBFWorker::runQBF()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00294">ParExtractorWorker::runSAT()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00553">ParExtractorWorker::runSATDep()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00575">TemplateSynth::syntQBF()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02502">TemplExplorer::syntQBF()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00607">TemplateSynth::syntSAT()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02544">TemplExplorer::syntSAT()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00560">ParallelLearner::triggerExplorerRestart()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00658">ParallelLearner::triggerInitialMode1Restart()</a>, <a class="el" href="OrigUnivExpander_8cpp_source.html#l00055">OrigUnivExpander::univExpand()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00113">UnivExpander::univExpand()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f4358961404803c1be6b73f5aada4ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AIG2CNF::isTrueInTrans </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if variable "1" should be defined as TRUE in the transition relation. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>This is a hack. This should always be done. But this would require re-computation of the pre-computed winning regions for the experiments, so it is delayed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if variable "1" should be defined as TRUE in the transition relation. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8cpp_source.html#l00316">316</a> of file <a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a>.</p>

<p>References <a class="el" href="AIG2CNF_8h_source.html#l00400">true_in_trans_</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">LearningImplExtractor::LearningImplExtractor()</a>, and <a class="el" href="ParExtractor_8cpp_source.html#l00193">ParExtractorWorker::ParExtractorWorker()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ee82fcfe444616f35078957ec762489"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIG2CNF.html">AIG2CNF</a>&amp; AIG2CNF::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAIG2CNF.html">AIG2CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a83d0b27b61d672ecf2bd007e0d473439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> AIG2CNF::initial_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the initial state. </p>
<p>There is exactly one initial state (this is a restriction imposed by the AIGER format which serves as input for our tool). Furthermore, the initial state is always characterized by having all state bits set to FALSE. However, this may change with future AIGER versions. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00370">370</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00265">getInitial()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="ae298ae4804c63f5bac4dfab7528d35ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIG2CNF.html">AIG2CNF</a> * AIG2CNF::instance_ = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The one and only instance of this class. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00444">444</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00042">instance()</a>.</p>

</div>
</div>
<a class="anchor" id="a057c6a3159253267c99f115b7d724ee2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> AIG2CNF::next_safe_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is safe. </p>
<p>The set of safe next states is actually characterized by one single state bit, namely the next states where the variable <a class="el" href="classVarManager.html#ac1a84b367c26dfc5ee9e612f7d61b288" title="Returns the one and only instance of this class. ">VarManager::instance()</a>.getNextErrorStateVar() is FALSE. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts exactly this. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00351">351</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00253">getNextSafeStates()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="a0430b9b4ff38a7b0ae339fb0abd191c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> AIG2CNF::next_unsafe_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the next state is unsafe. </p>
<p>The set of unsafe next states is actually characterized by one single state bit, namely the next states where the variable <a class="el" href="classVarManager.html#ac1a84b367c26dfc5ee9e612f7d61b288" title="Returns the one and only instance of this class. ">VarManager::instance()</a>.getNextErrorStateVar() is TRUE. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts exactly this. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00360">360</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00259">getNextUnsafeStates()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="a394d2a3600bc3bec864cf08acac61437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> AIG2CNF::safe_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of safe states. </p>
<p>The set of safe states is actually characterized by one single state bit, namely the states where the variable <a class="el" href="classVarManager.html#ac1a84b367c26dfc5ee9e612f7d61b288" title="Returns the one and only instance of this class. ">VarManager::instance()</a>.getPresErrorStateVar() is FALSE. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts exactly this. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00333">333</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00241">getSafeStates()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="af2a7f6ecdcec3b5b2f37a11b0adde65a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AIG2CNF::t_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The literal assigned by <a class="el" href="classAIG2CNF.html#af7e9b65092f626865a4aa541a48e4f1b">trans_eq_t_ </a>. </p>
<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> <a class="el" href="classAIG2CNF.html#af7e9b65092f626865a4aa541a48e4f1b">trans_eq_t_ </a> asserts T(x,i,c,x') &lt;-&gt; <a class="el" href="classAIG2CNF.html#af2a7f6ecdcec3b5b2f37a11b0adde65a">t_ </a>. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00324">324</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00235">getT()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="aedcb9a8efe69fe03721fdc17c5d11bfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> AIG2CNF::trans_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The transition relation in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. </p>
<p>The transition relation is a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> T(x,i,c,x') that talks about the current state bits x, the uncontrollable inputs i, the controllable inputs c, and the next state copies x' of the state bits x. The transition relation is </p>
<ul>
<li>
complete, i.e., forall x,i,c: exists x': T(x,i,c,x'). </li>
<li>
deterministic, i.e., forall x,i,c,x1',x2': (T(x,i,c,x1') AND T(x,i,c,x2')) implies (x1' = x2') </li>
</ul>
<p>This means: for every state and input, the next state is uniquely defined. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00306">306</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">getTrans()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="af7e9b65092f626865a4aa541a48e4f1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> AIG2CNF::trans_eq_t_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> saying that the transition holds iff <a class="el" href="classAIG2CNF.html#af2a7f6ecdcec3b5b2f37a11b0adde65a">t_ </a> is true. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts T(x,i,c,x') &lt;-&gt; <a class="el" href="classAIG2CNF.html#af2a7f6ecdcec3b5b2f37a11b0adde65a">t_ </a>. This can be useful if you need the negated transition relation, if you want to use the the transition relation in some complicated formula, or if your formula should contain the transition relation several times (e.g. A &amp; T | B &amp; !T) . </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00316">316</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00229">getTransEqT()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="a8617860055dfa8cbcc1f572676f57b84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;int, set&lt;<a class="el" href="classVarInfo.html">VarInfo</a>&gt; &gt; AIG2CNF::trans_tmp_deps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The variables on which a temporary variable of the transition relation depends. </p>
<p>For each temporary variable that has been introduced when encoding the transition relation into <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>, this map stores on which other variables (state variables, inputs, or other temporary variables) a certain temporary CNF-variable depends. This information can be useful in optimizations: For instance, if a certain temporary variable only depends on state-variables and uncontrollable inputs, the the control signals can be allowed to depend on such a temporary variable during circuit extraction. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00382">382</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00271">getTmpDeps()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">getTmpDepsTrans()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3c2e9acc3357e837349e30447b93c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;int, set&lt;<a class="el" href="classVarInfo.html">VarInfo</a>&gt; &gt; AIG2CNF::trans_tmp_deps_trans_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like trans_tmp_deps_, but stores (transitive) dependencies non non-temporary vars. </p>
<p>This map stores essentially the same information as trans_tmp_deps_. However, it only contains (transitive) dependencies on state variables and (uncontrollable and controllable) inputs. Dependencies on other temporary variables are represented by taking their dependencies on state variables and (uncontrollable and controllable) inputs. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00392">392</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00278">getTmpDepsTrans()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a46853e81b9c2be9dc9dab2d080355d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIG2CNF::true_in_trans_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A flag indicating if the transition relation should define the var "1" as true. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>This is a hack. This should always be done. But this would require re-computation of the pre-computed winning regions for the experiments, so it is delayed. </dd></dl>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00400">400</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00316">isTrueInTrans()</a>.</p>

</div>
</div>
<a class="anchor" id="afbfcf3a27261a2283a99362d2527d64f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> AIG2CNF::unsafe_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representing the set of unsafe states. </p>
<p>The set of unsafe states is actually characterized by one single state bit, namely the states where the variable <a class="el" href="classVarManager.html#ac1a84b367c26dfc5ee9e612f7d61b288" title="Returns the one and only instance of this class. ">VarManager::instance()</a>.getPresErrorStateVar() is TRUE. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> asserts exactly this. </p>

<p>Definition at line <a class="el" href="AIG2CNF_8h_source.html#l00342">342</a> of file <a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a>.</p>

<p>Referenced by <a class="el" href="AIG2CNF_8cpp_source.html#l00210">clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00247">getUnsafeStates()</a>, and <a class="el" href="AIG2CNF_8cpp_source.html#l00051">initFromAig()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="AIG2CNF_8h_source.html">AIG2CNF.h</a></li>
<li>src/<a class="el" href="AIG2CNF_8cpp_source.html">AIG2CNF.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 26 2015 08:54:52 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
