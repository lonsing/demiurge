<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>demiurge: LearnSynthQBF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classLearnSynthQBF-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LearnSynthQBF Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a learning-based synthesis using a QBF solver.  
 <a href="classLearnSynthQBF.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LearnSynthQBF:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLearnSynthQBF.png" usemap="#LearnSynthQBF_map" alt=""/>
  <map id="LearnSynthQBF_map" name="LearnSynthQBF_map">
<area href="classBackEnd.html" title="An interface for the back-ends. " alt="BackEnd" shape="rect" coords="0,0,103,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7f4fe1f847d6af8ecebaa9a9f631b7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#ae7f4fe1f847d6af8ecebaa9a9f631b7c">LearnSynthQBF</a> (<a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *impl_extractor)</td></tr>
<tr class="memdesc:ae7f4fe1f847d6af8ecebaa9a9f631b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae7f4fe1f847d6af8ecebaa9a9f631b7c">More...</a><br/></td></tr>
<tr class="separator:ae7f4fe1f847d6af8ecebaa9a9f631b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692e516f27fd78a44884b715688bd7d9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a692e516f27fd78a44884b715688bd7d9">~LearnSynthQBF</a> ()</td></tr>
<tr class="memdesc:a692e516f27fd78a44884b715688bd7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a692e516f27fd78a44884b715688bd7d9">More...</a><br/></td></tr>
<tr class="separator:a692e516f27fd78a44884b715688bd7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed85bb2fe317a5fdc7eef71fe598c606"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#aed85bb2fe317a5fdc7eef71fe598c606">run</a> ()</td></tr>
<tr class="memdesc:aed85bb2fe317a5fdc7eef71fe598c606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes this back-end.  <a href="#aed85bb2fe317a5fdc7eef71fe598c606">More...</a><br/></td></tr>
<tr class="separator:aed85bb2fe317a5fdc7eef71fe598c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae8219ab3e4987775e1d6a006a9d38f4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#ae8219ab3e4987775e1d6a006a9d38f4d">computeWinningRegion</a> ()</td></tr>
<tr class="memdesc:ae8219ab3e4987775e1d6a006a9d38f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region and stores the result in <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>.  <a href="#ae8219ab3e4987775e1d6a006a9d38f4d">More...</a><br/></td></tr>
<tr class="separator:ae8219ab3e4987775e1d6a006a9d38f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac538cd53082bad1c8c45a7e178dfa4cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#ac538cd53082bad1c8c45a7e178dfa4cb">computeWinningRegionOne</a> ()</td></tr>
<tr class="memdesc:ac538cd53082bad1c8c45a7e178dfa4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the standard method to compute the winning region.  <a href="#ac538cd53082bad1c8c45a7e178dfa4cb">More...</a><br/></td></tr>
<tr class="separator:ac538cd53082bad1c8c45a7e178dfa4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c897056a5018ff1717ea2d76f6cd8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#af8c897056a5018ff1717ea2d76f6cd8f">computeWinningRegionOneSAT</a> ()</td></tr>
<tr class="memdesc:af8c897056a5018ff1717ea2d76f6cd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region, using two SAT-solvers to compute counterexamples.  <a href="#af8c897056a5018ff1717ea2d76f6cd8f">More...</a><br/></td></tr>
<tr class="separator:af8c897056a5018ff1717ea2d76f6cd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a9ecb2b77c540cdcc327a35cd15c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a09a9ecb2b77c540cdcc327a35cd15c18">computeWinningRegionAll</a> ()</td></tr>
<tr class="memdesc:a09a9ecb2b77c540cdcc327a35cd15c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region, always computing all counterexample generalizations.  <a href="#a09a9ecb2b77c540cdcc327a35cd15c18">More...</a><br/></td></tr>
<tr class="separator:a09a9ecb2b77c540cdcc327a35cd15c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b8dd6e26d646a6f197afb362168408"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a04b8dd6e26d646a6f197afb362168408">computeCounterexampleQBF</a> (vector&lt; int &gt; &amp;ce)</td></tr>
<tr class="memdesc:a04b8dd6e26d646a6f197afb362168408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a counterexample-state using a QBF-solver.  <a href="#a04b8dd6e26d646a6f197afb362168408">More...</a><br/></td></tr>
<tr class="separator:a04b8dd6e26d646a6f197afb362168408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221800bf3f040b66b8a790bab4c82b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a3221800bf3f040b66b8a790bab4c82b5">computeCounterexampleSAT</a> (vector&lt; int &gt; &amp;ce)</td></tr>
<tr class="memdesc:a3221800bf3f040b66b8a790bab4c82b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a counterexample-state using two competing SAT-solvers.  <a href="#a3221800bf3f040b66b8a790bab4c82b5">More...</a><br/></td></tr>
<tr class="separator:a3221800bf3f040b66b8a790bab4c82b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73856a79be3fb7e260485bcda7c31f80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a73856a79be3fb7e260485bcda7c31f80">computeBlockingClause</a> (vector&lt; int &gt; &amp;ce, vector&lt; int &gt; &amp;blocking_clause)</td></tr>
<tr class="memdesc:a73856a79be3fb7e260485bcda7c31f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a blocking clause for a counterexample.  <a href="#a73856a79be3fb7e260485bcda7c31f80">More...</a><br/></td></tr>
<tr class="separator:a73856a79be3fb7e260485bcda7c31f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa7b4583cc17d01f4c82fd57e763e1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#affa7b4583cc17d01f4c82fd57e763e1f">computeAllBlockingClauses</a> (vector&lt; int &gt; &amp;ce, vector&lt; vector&lt; int &gt; &gt; &amp;blocking_clauses)</td></tr>
<tr class="memdesc:affa7b4583cc17d01f4c82fd57e763e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all minimal blocking clauses for a counterexample.  <a href="#affa7b4583cc17d01f4c82fd57e763e1f">More...</a><br/></td></tr>
<tr class="separator:affa7b4583cc17d01f4c82fd57e763e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5b9d45d6f69575ed5257fe9a869893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#adf5b9d45d6f69575ed5257fe9a869893">reduceExistingClauses</a> ()</td></tr>
<tr class="memdesc:adf5b9d45d6f69575ed5257fe9a869893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to drop literals from clauses in the winning region.  <a href="#adf5b9d45d6f69575ed5257fe9a869893">More...</a><br/></td></tr>
<tr class="separator:adf5b9d45d6f69575ed5257fe9a869893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46d02268fe5ea73789280058ec75136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#aa46d02268fe5ea73789280058ec75136">recomputeCheckCNF</a> (bool take_small_win=true)</td></tr>
<tr class="memdesc:aa46d02268fe5ea73789280058ec75136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recomputes the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> (of the QBF) that is used for computing counterexamples.  <a href="#aa46d02268fe5ea73789280058ec75136">More...</a><br/></td></tr>
<tr class="separator:aa46d02268fe5ea73789280058ec75136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c6d16c3db9057bfa515b06b7a7ffe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#aa1c6d16c3db9057bfa515b06b7a7ffe9">recomputeGenCNF</a> (bool take_small_win=true)</td></tr>
<tr class="memdesc:aa1c6d16c3db9057bfa515b06b7a7ffe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recomputes the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> (of the QBF) that is used for generalizing counterexamples.  <a href="#aa1c6d16c3db9057bfa515b06b7a7ffe9">More...</a><br/></td></tr>
<tr class="separator:aa1c6d16c3db9057bfa515b06b7a7ffe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704edaade039b09520815b581fe98b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a704edaade039b09520815b581fe98b47">restrictToStates</a> (vector&lt; int &gt; &amp;vec) const </td></tr>
<tr class="memdesc:a704edaade039b09520815b581fe98b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts a vector of literals (a cube or clause) to state-variables only.  <a href="#a704edaade039b09520815b581fe98b47">More...</a><br/></td></tr>
<tr class="separator:a704edaade039b09520815b581fe98b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eed607741968f74e31976e8ca40a62f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a9eed607741968f74e31976e8ca40a62f">generalizeCounterexample</a> (vector&lt; int &gt; &amp;ce, bool check_sat=true) const </td></tr>
<tr class="memdesc:a9eed607741968f74e31976e8ca40a62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalizes a counterexample-state by dropping literals.  <a href="#a9eed607741968f74e31976e8ca40a62f">More...</a><br/></td></tr>
<tr class="separator:a9eed607741968f74e31976e8ca40a62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9c6b41f7df5f4ed4bfc5930136fc1152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152">winning_region_</a></td></tr>
<tr class="memdesc:a9c6b41f7df5f4ed4bfc5930136fc1152"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current over-approximation of the winning region.  <a href="#a9c6b41f7df5f4ed4bfc5930136fc1152">More...</a><br/></td></tr>
<tr class="separator:a9c6b41f7df5f4ed4bfc5930136fc1152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b460cdc140c3969a32ea77982181d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#aa9b460cdc140c3969a32ea77982181d2">winning_region_large_</a></td></tr>
<tr class="memdesc:aa9b460cdc140c3969a32ea77982181d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current over-approximation of the winning region in an uncompressed form.  <a href="#aa9b460cdc140c3969a32ea77982181d2">More...</a><br/></td></tr>
<tr class="separator:aa9b460cdc140c3969a32ea77982181d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c46943042fdcfd672ce2251ef49cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLearnStatisticsQBF.html">LearnStatisticsQBF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a85c46943042fdcfd672ce2251ef49cd9">statistics_</a></td></tr>
<tr class="memdesc:a85c46943042fdcfd672ce2251ef49cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores and maintains statistics and performance measures.  <a href="#a85c46943042fdcfd672ce2251ef49cd9">More...</a><br/></td></tr>
<tr class="separator:a85c46943042fdcfd672ce2251ef49cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4c4279f543a0adea992fccf22009f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQBFSolver.html">QBFSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a8b4c4279f543a0adea992fccf22009f4">qbf_solver_</a></td></tr>
<tr class="memdesc:a8b4c4279f543a0adea992fccf22009f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The QBF-solver used for all queries.  <a href="#a8b4c4279f543a0adea992fccf22009f4">More...</a><br/></td></tr>
<tr class="separator:a8b4c4279f543a0adea992fccf22009f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafe15fef745bb97ac36741cbe00d4c1"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>, <br class="typebreak"/>
<a class="el" href="classQBFSolver.html#ac091e263cb55286cc07b2451bcf4d3c7">QBFSolver::Quant</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#afafe15fef745bb97ac36741cbe00d4c1">check_quant_</a></td></tr>
<tr class="memdesc:afafe15fef745bb97ac36741cbe00d4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quantifier prefix of the QBF for computing counterexamples.  <a href="#afafe15fef745bb97ac36741cbe00d4c1">More...</a><br/></td></tr>
<tr class="separator:afafe15fef745bb97ac36741cbe00d4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe20b32b1b8c07a237322825c91a36f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#afe20b32b1b8c07a237322825c91a36f0">check_cnf_</a></td></tr>
<tr class="memdesc:afe20b32b1b8c07a237322825c91a36f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> matrix of the QBF for computing counterexamples.  <a href="#afe20b32b1b8c07a237322825c91a36f0">More...</a><br/></td></tr>
<tr class="separator:afe20b32b1b8c07a237322825c91a36f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6687cca6f45b9684d3bd6e7cc8c20c"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>, <br class="typebreak"/>
<a class="el" href="classQBFSolver.html#ac091e263cb55286cc07b2451bcf4d3c7">QBFSolver::Quant</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a2a6687cca6f45b9684d3bd6e7cc8c20c">gen_quant_</a></td></tr>
<tr class="memdesc:a2a6687cca6f45b9684d3bd6e7cc8c20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quantifier prefix of the QBF for generalizing counterexamples.  <a href="#a2a6687cca6f45b9684d3bd6e7cc8c20c">More...</a><br/></td></tr>
<tr class="separator:a2a6687cca6f45b9684d3bd6e7cc8c20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0678a7c034958c31bd5d92615e9859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#adb0678a7c034958c31bd5d92615e9859">generalize_clause_cnf_</a></td></tr>
<tr class="memdesc:adb0678a7c034958c31bd5d92615e9859"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> matrix of the QBF for generalizing counterexamples.  <a href="#adb0678a7c034958c31bd5d92615e9859">More...</a><br/></td></tr>
<tr class="separator:adb0678a7c034958c31bd5d92615e9859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2e8c87c0ca0d83c484d6181ea5a788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#ada2e8c87c0ca0d83c484d6181ea5a788">solver_i_</a></td></tr>
<tr class="memdesc:ada2e8c87c0ca0d83c484d6181ea5a788"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SAT-solver for antagonist moves when using <a class="el" href="classLearnSynthQBF.html#a3221800bf3f040b66b8a790bab4c82b5" title="Computes a counterexample-state using two competing SAT-solvers. ">computeCounterexampleSAT()</a>.  <a href="#ada2e8c87c0ca0d83c484d6181ea5a788">More...</a><br/></td></tr>
<tr class="separator:ada2e8c87c0ca0d83c484d6181ea5a788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f20d46129ad1fe2db8272348a7e589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSatSolver.html">SatSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a14f20d46129ad1fe2db8272348a7e589">solver_ctrl_</a></td></tr>
<tr class="memdesc:a14f20d46129ad1fe2db8272348a7e589"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SAT-solver for protagonist moves when using <a class="el" href="classLearnSynthQBF.html#a3221800bf3f040b66b8a790bab4c82b5" title="Computes a counterexample-state using two competing SAT-solvers. ">computeCounterexampleSAT()</a>.  <a href="#a14f20d46129ad1fe2db8272348a7e589">More...</a><br/></td></tr>
<tr class="separator:a14f20d46129ad1fe2db8272348a7e589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227ff215ffb411e57686aa3d8e7f7026"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a227ff215ffb411e57686aa3d8e7f7026">incremental_vars_to_keep_</a></td></tr>
<tr class="memdesc:a227ff215ffb411e57686aa3d8e7f7026"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of variables the SAT-solver should not optimize away.  <a href="#a227ff215ffb411e57686aa3d8e7f7026">More...</a><br/></td></tr>
<tr class="separator:a227ff215ffb411e57686aa3d8e7f7026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65774a2b9e6137d6ff45cbf755d4843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#ae65774a2b9e6137d6ff45cbf755d4843">solver_i_precise_</a></td></tr>
<tr class="memdesc:ae65774a2b9e6137d6ff45cbf755d4843"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating if solver_i_ is precise.  <a href="#ae65774a2b9e6137d6ff45cbf755d4843">More...</a><br/></td></tr>
<tr class="separator:ae65774a2b9e6137d6ff45cbf755d4843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b0c8db41c054eef617e7e9156fad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#ad34b0c8db41c054eef617e7e9156fad8">impl_extractor_</a></td></tr>
<tr class="memdesc:ad34b0c8db41c054eef617e7e9156fad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The engine to use for circuit extraction.  <a href="#ad34b0c8db41c054eef617e7e9156fad8">More...</a><br/></td></tr>
<tr class="separator:ad34b0c8db41c054eef617e7e9156fad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad8d67501811be3fc0366e19df7f8d10a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#ad8d67501811be3fc0366e19df7f8d10a">LearnSynthQBF</a> (const <a class="el" href="classLearnSynthQBF.html">LearnSynthQBF</a> &amp;other)</td></tr>
<tr class="memdesc:ad8d67501811be3fc0366e19df7f8d10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ad8d67501811be3fc0366e19df7f8d10a">More...</a><br/></td></tr>
<tr class="separator:ad8d67501811be3fc0366e19df7f8d10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143bc7b32f7511ddbdbdec01c2e43578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLearnSynthQBF.html">LearnSynthQBF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBF.html#a143bc7b32f7511ddbdbdec01c2e43578">operator=</a> (const <a class="el" href="classLearnSynthQBF.html">LearnSynthQBF</a> &amp;other)</td></tr>
<tr class="memdesc:a143bc7b32f7511ddbdbdec01c2e43578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a143bc7b32f7511ddbdbdec01c2e43578">More...</a><br/></td></tr>
<tr class="separator:a143bc7b32f7511ddbdbdec01c2e43578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements a learning-based synthesis using a QBF solver. </p>
<p>The computation of the winning region works as follows. We start with the initial guess that the winning region F is the set of all state states P. In a loop, we first compute a counterexample to the correctness of this guess in form of a state from which the antagonist (controlling the uncontrollable inputs i) can enforce to leave F. The state is represented as a cube over all state-variables. Next, this state-cube is generalized into a larger region of states by dropping literals as long as the cube contains only states that are winning for the antagonist (and hence must be removed or have already been removed from F). Finally, the generalized cube is removed from F. The next iteration checks for counterexample-state on the refined F. This is repeated until no more counterexample-states exist (then the specification is realizable and F is a winning region) or the initial state has been removed from F (in which case the specification is unrealizable).</p>
<p>This procedure is implemented in <a class="el" href="classLearnSynthQBF.html#ac538cd53082bad1c8c45a7e178dfa4cb" title="Uses the standard method to compute the winning region. ">computeWinningRegionOne()</a>. Some variants of this procedure are implemented in other methods of this class. The method <a class="el" href="classLearnSynthQBF.html#af8c897056a5018ff1717ea2d76f6cd8f" title="Computes the winning region, using two SAT-solvers to compute counterexamples. ">computeWinningRegionOneSAT()</a> uses two SAT solvers instead of a QBF solver to compute a counterexample-state. The method <a class="el" href="classLearnSynthQBF.html#a09a9ecb2b77c540cdcc327a35cd15c18" title="Computes the winning region, always computing all counterexample generalizations. ...">computeWinningRegionAll()</a> computes (and excludes) not only one generalization of the counterexample but all generalizations. Command-line parameters (&ndash;mode) decide which of these methods to use.</p>
<p>Finally the <a class="el" href="classQBFCertImplExtractor.html" title="Given a winning region in CNF, this method extracts a circuit using QBFCert. ">QBFCertImplExtractor</a> is used to extract a circuit.</p>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.2.0 </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00072">72</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae7f4fe1f847d6af8ecebaa9a9f631b7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LearnSynthQBF::LearnSynthQBF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td>
          <td class="paramname"><em>impl_extractor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl_extractor</td><td>The engine to use for circuit extraction. It will be deleted by this class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">40</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="QBFSolver_8h_source.html#l00067">QBFSolver::A</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00379">check_quant_</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="QBFSolver_8h_source.html#l00062">QBFSolver::E</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00394">gen_quant_</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00424">incremental_vars_to_keep_</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00419">solver_ctrl_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00410">solver_i_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00435">solver_i_precise_</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, and <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>.</p>

</div>
</div>
<a class="anchor" id="a692e516f27fd78a44884b715688bd7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LearnSynthQBF::~LearnSynthQBF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00079">79</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBF_8h_source.html#l00442">impl_extractor_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00371">qbf_solver_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00419">solver_ctrl_</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00410">solver_i_</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d67501811be3fc0366e19df7f8d10a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LearnSynthQBF::LearnSynthQBF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLearnSynthQBF.html">LearnSynthQBF</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="affa7b4583cc17d01f4c82fd57e763e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::computeAllBlockingClauses </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocking_clauses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes all minimal blocking clauses for a counterexample. </p>
<p>This method is like <a class="el" href="classLearnSynthQBF.html#a73856a79be3fb7e260485bcda7c31f80" title="Computes a blocking clause for a counterexample. ">computeBlockingClause()</a>. However, instead of computing just one generalization of the counterexample (and the corresponding blocking clause) it computes all minimal generalizations (and corresponding blocking clauses). It does so using a simple hitting set tree algorithm as presented by "Raymond Reiter: A Theory of Diagnosis
from First Principles. Artif. Intell. 32(1): 57-95 (1987)".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>The counterexample to block. It is a full or partial cube over the state variables. </td></tr>
    <tr><td class="paramname">blocking_clauses</td><td>An empty vector. It is used to store the computed blocking clauses. The counterexample falsifies all blocking clauses in this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if one of the blocking clauses blocks the initial state. This means that the initial state is removed from the winning region, i.e., the specification is unrealizable. True is returned otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">450</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="Utils_8cpp_source.html#l00045">Utils::containsInit()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00401">generalize_clause_cnf_</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">generalizeCounterexample()</a>, <a class="el" href="Utils_8cpp_source.html#l00248">Utils::intersectionEmpty()</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00089">LearnStatisticsQBF::notifyAfterCubeMin()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00083">LearnStatisticsQBF::notifyBeforeCubeMin()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00106">LearnStatisticsQBF::notifyCubeMin()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>, and <a class="el" href="Utils_8cpp_source.html#l00227">Utils::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>.</p>

</div>
</div>
<a class="anchor" id="a73856a79be3fb7e260485bcda7c31f80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::computeBlockingClause </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocking_clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a blocking clause for a counterexample. </p>
<p>A naive blocking clause would be the plain negation of the counterexample. However, in order to boost the overall performance of the algorithm, we generalize the counterexample before we negate it. This is done by dropping literals from the counterexample-cube as long as all states in the cube are counterexamples (or have already been removed from the winning region). The method also checks if the blocking clause blocks the initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>The counterexample to block. It is a full or partial cube over the state variables. </td></tr>
    <tr><td class="paramname">blocking_clause</td><td>An empty vector. It is used to store the computed blocking clause. The counterexample falsifies the blocking clause. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the blocking clause blocks the initial state. This means that the initial state is removed from the winning region, i.e., the specification is unrealizable. True is returned otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00432">432</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="Utils_8cpp_source.html#l00045">Utils::containsInit()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">generalizeCounterexample()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00089">LearnStatisticsQBF::notifyAfterCubeMin()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00083">LearnStatisticsQBF::notifyBeforeCubeMin()</a>, <a class="el" href="Utils_8cpp_source.html#l00168">Utils::randomize()</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>.</p>

</div>
</div>
<a class="anchor" id="a04b8dd6e26d646a6f197afb362168408"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::computeCounterexampleQBF </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a counterexample-state using a QBF-solver. </p>
<p>'Counterexample' here means: counterexample to the correctness of the current guess of the winning region. A counterexample is simply a state (represented as cube over the state variables) from which the antagonist can enforce to leave the winning region. This method uses a single call to a QBF-solver in order to find such a state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>An empty vector. The computed counterexample is stored in this vector in form of a cube over the state variables. The cube does not necessarily contain all state variables. If some state variables are irrelevant, then they may be omitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a counterexample was found, false if no counterexample exists. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00333">333</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBF_8h_source.html#l00386">check_cnf_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00379">check_quant_</a>, <a class="el" href="classQBFSolver.html#a76fc0c757a2c039816e3e06547f06d5c">QBFSolver::isSatModel()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00075">LearnStatisticsQBF::notifyAfterComputeCube()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00069">LearnStatisticsQBF::notifyBeforeComputeCube()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00371">qbf_solver_</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00608">restrictToStates()</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>.</p>

</div>
</div>
<a class="anchor" id="a3221800bf3f040b66b8a790bab4c82b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::computeCounterexampleSAT </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a counterexample-state using two competing SAT-solvers. </p>
<p>'Counterexample' here means: counterexample to the correctness of the current guess of the winning region. A counterexample is simply a state (represented as cube over the state variables) from which the antagonist can enforce to leave the winning region. This method uses two competing SAT-solvers in order to find such a state. First, solver <a class="el" href="classLearnSynthQBF.html#ada2e8c87c0ca0d83c484d6181ea5a788" title="The SAT-solver for antagonist moves when using computeCounterexampleSAT(). ">solver_i_</a> finds some input values i that could be chosen by the antagonist in order to leave the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. Next, solver_ctrl_ checks if there exists a response of the protagonist to chose control values c such that the winning region is not left. If no such response exists, then we have found a counterexample. Otherwise, we exclude the state-input combination found by <a class="el" href="classLearnSynthQBF.html#ada2e8c87c0ca0d83c484d6181ea5a788" title="The SAT-solver for antagonist moves when using computeCounterexampleSAT(). ">solver_i_</a> and try again.</p>
<p>There is also an optimization which allows to use <a class="el" href="classLearnSynthQBF.html#ada2e8c87c0ca0d83c484d6181ea5a788" title="The SAT-solver for antagonist moves when using computeCounterexampleSAT(). ">solver_i_</a> incrementally: The next state-copy of the winning region is updated only lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>An empty vector. The computed counterexample is stored in this vector in form of a cube over the state variables. The cube does not necessarily contain all state variables. If some state variables are irrelevant, then they may be omitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a counterexample was found, false if no counterexample exists. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">345</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="Utils_8cpp_source.html#l00305">Utils::compressStateCNF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Utils_8cpp_source.html#l00067">Utils::extract()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00424">incremental_vars_to_keep_</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="CNF_8cpp_source.html#l00272">CNF::negate()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00075">LearnStatisticsQBF::notifyAfterComputeCube()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00069">LearnStatisticsQBF::notifyBeforeComputeCube()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00419">solver_ctrl_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00410">solver_i_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00435">solver_i_precise_</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00347">winning_region_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8219ab3e4987775e1d6a006a9d38f4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::computeWinningRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region and stores the result in <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. </p>
<p>Depending on the command-line parameters (&ndash;mode) this method calls one of </p>
<ul>
<li>
<a class="el" href="classLearnSynthQBF.html#ac538cd53082bad1c8c45a7e178dfa4cb" title="Uses the standard method to compute the winning region. ">computeWinningRegionOne()</a> </li>
<li>
<a class="el" href="classLearnSynthQBF.html#af8c897056a5018ff1717ea2d76f6cd8f" title="Computes the winning region, using two SAT-solvers to compute counterexamples. ">computeWinningRegionOneSAT()</a> </li>
<li>
<a class="el" href="classLearnSynthQBF.html#a09a9ecb2b77c540cdcc327a35cd15c18" title="Computes the winning region, always computing all counterexample generalizations. ...">computeWinningRegionAll()</a> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00125">125</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>, and <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00092">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a09a9ecb2b77c540cdcc327a35cd15c18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::computeWinningRegionAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region, always computing all counterexample generalizations. </p>
<p>The working principle is the same as for <a class="el" href="classLearnSynthQBF.html#ac538cd53082bad1c8c45a7e178dfa4cb" title="Uses the standard method to compute the winning region. ">computeWinningRegionOne()</a>. The only difference is that this method computes and excludes all counterexample generalizations instead of just one.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">267</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00386">check_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="Utils_8cpp_source.html#l00305">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00333">computeCounterexampleQBF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Logger_8h_source.html#l00105">Logger::DBG</a>, <a class="el" href="Utils_8cpp_source.html#l00630">Utils::debugPrint()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00401">generalize_clause_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00306">CNF::getNrOfClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00312">CNF::getNrOfLits()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00241">AIG2CNF::getSafeStates()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00036">Logger::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00085">Logger::isEnabled()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00114">LearnStatisticsQBF::logStatistics()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00565">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00588">recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">reduceExistingClauses()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00347">winning_region_</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00359">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00125">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="ac538cd53082bad1c8c45a7e178dfa4cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::computeWinningRegionOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the standard method to compute the winning region. </p>
<p>This standard method works as follows. We start with the initial guess that the winning region F is the set of all state states P. In a loop, we first compute a counterexample to the correctness of this guess in form of a state from which the antagonist (controlling the uncontrollable inputs i) can enforce to leave F. The state is represented as a cube over all state-variables. Next, this state-cube is generalized into a larger region of states by dropping literals as long as the cube contains only states that are winning for the antagonist (and hence must be removed or have already been removed from F). Finally, the generalized cube is removed from F. The next iteration checks for counterexample-state on the refined F. This is repeated until no more counterexample-states exist (then the specification is realizable and F is a winning region) or the initial state has been removed from F (in which case the specification is unrealizable).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">135</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00386">check_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="Utils_8cpp_source.html#l00305">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00432">computeBlockingClause()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00333">computeCounterexampleQBF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Logger_8h_source.html#l00105">Logger::DBG</a>, <a class="el" href="Utils_8cpp_source.html#l00630">Utils::debugPrint()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00401">generalize_clause_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00306">CNF::getNrOfClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00312">CNF::getNrOfLits()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00241">AIG2CNF::getSafeStates()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00036">Logger::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00085">Logger::isEnabled()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00114">LearnStatisticsQBF::logStatistics()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00565">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00588">recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>, <a class="el" href="Utils_8cpp_source.html#l00227">Utils::swapPresentToNext()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00347">winning_region_</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00359">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00125">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="af8c897056a5018ff1717ea2d76f6cd8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::computeWinningRegionOneSAT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region, using two SAT-solvers to compute counterexamples. </p>
<p>The working principle is the same as for <a class="el" href="classLearnSynthQBF.html#ac538cd53082bad1c8c45a7e178dfa4cb" title="Uses the standard method to compute the winning region. ">computeWinningRegionOne()</a>. The only difference is that counterexample-states (states from which the antagonist controlling the inputs i can enforce to leave the winning region) are computed using two competing SAT-solvers instead of a QBF-solver.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">204</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00386">check_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00432">computeBlockingClause()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">computeCounterexampleSAT()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Logger_8h_source.html#l00105">Logger::DBG</a>, <a class="el" href="Utils_8cpp_source.html#l00630">Utils::debugPrint()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00401">generalize_clause_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00306">CNF::getNrOfClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00312">CNF::getNrOfLits()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00241">AIG2CNF::getSafeStates()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00036">Logger::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00085">Logger::isEnabled()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00114">LearnStatisticsQBF::logStatistics()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00588">recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00419">solver_ctrl_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00410">solver_i_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>, <a class="el" href="Utils_8cpp_source.html#l00227">Utils::swapPresentToNext()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00347">winning_region_</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00359">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00125">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="a9eed607741968f74e31976e8ca40a62f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::generalizeCounterexample </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_sat</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generalizes a counterexample-state by dropping literals. </p>
<p>This method generalizes a counterexample-state (a cube over the present-state variables) by dropping literals as long as all states in the cube are counterexamples (or have already been removed from the winning region). Optionally, this method also checks if the passed vector is a valid (generalization of a) counterexample.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>The counterexample to generalize (it will be overwritten by its own generalization). This is a complete or partial cube over the present state variables. </td></tr>
    <tr><td class="paramname">check_sat</td><td>If set to true, then this method checks if the passed counterexample vector is indeed a valid (generalization of a) counterexample. If set to false, then this step is skipped. If this parameter is true and the passed vector is not a valid counterexample, then it will not be modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the passed vector is a valid (generalization of a) counterexample, or if the check was skipped by setting check_sat = false. False is returned only if the check was performed (check_sat = true) and the passed vector is not a valid counterexample. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">627</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00130">CNF::addCube()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00394">gen_quant_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00401">generalize_clause_cnf_</a>, <a class="el" href="classQBFSolver.html#a53ef157391b176dfbd2a77a1e31befc3">QBFSolver::isSat()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00371">qbf_solver_</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="Utils_8cpp_source.html#l00174">Utils::sort()</a>, and <a class="el" href="Utils_8cpp_source.html#l00227">Utils::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">computeAllBlockingClauses()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00432">computeBlockingClause()</a>.</p>

</div>
</div>
<a class="anchor" id="a143bc7b32f7511ddbdbdec01c2e43578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLearnSynthQBF.html">LearnSynthQBF</a>&amp; LearnSynthQBF::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLearnSynthQBF.html">LearnSynthQBF</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="aa46d02268fe5ea73789280058ec75136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBF::recomputeCheckCNF </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_small_win</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recomputes the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> (of the QBF) that is used for computing counterexamples. </p>
<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> used for computing counterexamples is F &amp; T &amp; !F', where F is the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. The result is stored in <a class="el" href="classLearnSynthQBF.html#afe20b32b1b8c07a237322825c91a36f0" title="The CNF matrix of the QBF for computing counterexamples. ">check_cnf_</a>. Since F is constantly updated with new clauses, <a class="el" href="classLearnSynthQBF.html#afe20b32b1b8c07a237322825c91a36f0" title="The CNF matrix of the QBF for computing counterexamples. ">check_cnf_</a> needs to be updated as well. In an old version, we updated the <a class="el" href="classLearnSynthQBF.html#afe20b32b1b8c07a237322825c91a36f0" title="The CNF matrix of the QBF for computing counterexamples. ">check_cnf_</a> in place, modifying only the clauses that need to be modified. This gives quite ugly code. Since this operation is not performance critical (compared to QBF-solving), we now recompute check_cnf_ completely in each iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">take_small_win</td><td>If this parameter is true (or omitted) the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a> is used to compute the <a class="el" href="classLearnSynthQBF.html#afe20b32b1b8c07a237322825c91a36f0" title="The CNF matrix of the QBF for computing counterexamples. ">check_cnf_</a>. Otherwise, the <a class="el" href="classLearnSynthQBF.html#aa9b460cdc140c3969a32ea77982181d2" title="The current over-approximation of the winning region in an uncompressed form. ">winning_region_large_</a> is used. The difference between these two winning region versions is as follows. From time to we remove redundant clauses (clauses implied by other clauses) from <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a> but not from <a class="el" href="classLearnSynthQBF.html#aa9b460cdc140c3969a32ea77982181d2" title="The current over-approximation of the winning region in an uncompressed form. ">winning_region_large_</a>. Hence, <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a> is often smaller, but <a class="el" href="classLearnSynthQBF.html#aa9b460cdc140c3969a32ea77982181d2" title="The current over-approximation of the winning region in an uncompressed form. ">winning_region_large_</a> may contain clauses the solver may have to learn when using <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00565">565</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00386">check_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="CNF_8cpp_source.html#l00272">CNF::negate()</a>, <a class="el" href="VarManager_8cpp_source.html#l00063">VarManager::resetToLastPush()</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00347">winning_region_</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00359">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1c6d16c3db9057bfa515b06b7a7ffe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBF::recomputeGenCNF </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_small_win</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recomputes the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> (of the QBF) that is used for generalizing counterexamples. </p>
<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> used for generalizing counterexamples is F &amp; T &amp; F', where F is the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. The result is stored in <a class="el" href="classLearnSynthQBF.html#adb0678a7c034958c31bd5d92615e9859" title="The CNF matrix of the QBF for generalizing counterexamples. ">generalize_clause_cnf_</a>. Since F is constantly updated with new clauses, <a class="el" href="classLearnSynthQBF.html#adb0678a7c034958c31bd5d92615e9859" title="The CNF matrix of the QBF for generalizing counterexamples. ">generalize_clause_cnf_</a> needs to be updated as well. In an old version, we updated the <a class="el" href="classLearnSynthQBF.html#adb0678a7c034958c31bd5d92615e9859" title="The CNF matrix of the QBF for generalizing counterexamples. ">generalize_clause_cnf_</a> in place. This results in ugly code at some places (especially when the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a> is compressed or simplified). Since this operation is not performance critical (compared to QBF-solving), we now recompute <a class="el" href="classLearnSynthQBF.html#adb0678a7c034958c31bd5d92615e9859" title="The CNF matrix of the QBF for generalizing counterexamples. ">generalize_clause_cnf_</a> completely in each iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">take_small_win</td><td>If this parameter is true (or omitted) the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a> is used to compute the <a class="el" href="classLearnSynthQBF.html#adb0678a7c034958c31bd5d92615e9859" title="The CNF matrix of the QBF for generalizing counterexamples. ">generalize_clause_cnf_</a>. Otherwise, the <a class="el" href="classLearnSynthQBF.html#aa9b460cdc140c3969a32ea77982181d2" title="The current over-approximation of the winning region in an uncompressed form. ">winning_region_large_</a> is used. The difference between these two winning region versions is as follows. From time to we remove redundant clauses (clauses implied by other clauses) from <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a> but not from <a class="el" href="classLearnSynthQBF.html#aa9b460cdc140c3969a32ea77982181d2" title="The current over-approximation of the winning region in an uncompressed form. ">winning_region_large_</a>. Hence, <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a> is often smaller, but <a class="el" href="classLearnSynthQBF.html#aa9b460cdc140c3969a32ea77982181d2" title="The current over-approximation of the winning region in an uncompressed form. ">winning_region_large_</a> may contain clauses the solver may have to learn when using <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00588">588</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00401">generalize_clause_cnf_</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00347">winning_region_</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00359">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>.</p>

</div>
</div>
<a class="anchor" id="adf5b9d45d6f69575ed5257fe9a869893"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBF::reduceExistingClauses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to drop literals from clauses in the winning region. </p>
<p>This method examines all clauses (in <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>) that have already been computed and checks if more literals can be dropped. This is done in the same way as for dropping literals when generalizing a counterexample.</p>
<p>The intuition behind this method is that, even if a literal could not be dropped before, it could be dropped at a later point in time because the winning region has been refined in the meantime. However, in practice, typically only very few additional literals can be dropped, so this method often does not pay off. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">532</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="CNF_8cpp_source.html#l00123">CNF::addNegClauseAsCube()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00394">gen_quant_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00401">generalize_clause_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00306">CNF::getNrOfClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00312">CNF::getNrOfLits()</a>, <a class="el" href="classQBFSolver.html#a53ef157391b176dfbd2a77a1e31befc3">QBFSolver::isSat()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00089">LearnStatisticsQBF::notifyAfterCubeMin()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00083">LearnStatisticsQBF::notifyBeforeCubeMin()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00371">qbf_solver_</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00347">winning_region_</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00359">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>.</p>

</div>
</div>
<a class="anchor" id="a704edaade039b09520815b581fe98b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBF::restrictToStates </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts a vector of literals (a cube or clause) to state-variables only. </p>
<p>That is, all literals that do not talk about present state variables are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of literals (the cube or clause) to restricts to state-variables only. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00608">608</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="VarManager_8cpp_source.html#l00267">VarManager::getInfo()</a>, <a class="el" href="VarInfo_8cpp_source.html#l00087">VarInfo::getKind()</a>, <a class="el" href="VarManager_8cpp_source.html#l00320">VarManager::getPresErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, and <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00333">computeCounterexampleQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="aed85bb2fe317a5fdc7eef71fe598c606"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes this back-end. </p>
<p>The computation of the winning region works as follows. We start with the initial guess that the winning region F is the set of all state states P. In a loop, we first compute a counterexample to the correctness of this guess in form of a state from which the antagonist (controlling the uncontrollable inputs i) can enforce to leave F. The state is represented as a cube over all state-variables. Next, this state-cube is generalized into a larger region of states by dropping literals as long as the cube contains only states that are winning for the antagonist (and hence must be removed or have already been removed from F). Finally, the generalized cube is removed from F. The next iteration checks for counterexample-state on the refined F. This is repeated until no more counterexample-states exist (then the specification is realizable and F is a winning region) or the initial state has been removed from F (in which case the specification is unrealizable).</p>
<p>Command-line parameters (&ndash;mode) are used to select different variants of this method. There is </p>
<ul>
<li>
the standard method as described above, </li>
<li>
a variant which computes counterexamples using two SAT-solvers instead of a QBF solver, </li>
<li>
a variant which computes and excludes all counterexample-generalizations instead of just one. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classBackEnd.html#a099e717dc71e9cc2d838b1ca86340590">BackEnd</a>.</p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8cpp_source.html#l00092">92</a> of file <a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBF_8cpp_source.html#l00125">computeWinningRegion()</a>, <a class="el" href="Utils_8cpp_source.html#l00645">Utils::debugCheckWinReg()</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">CNFImplExtractor::extractCircuit()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00442">impl_extractor_</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="Logger_8h_source.html#l00302">L_INF</a>, <a class="el" href="Logger_8h_source.html#l00285">L_RES</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00290">CNFImplExtractor::logStatistics()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00114">LearnStatisticsQBF::logStatistics()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00062">LearnStatisticsQBF::notifyWinRegEnd()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00056">LearnStatisticsQBF::notifyWinRegStart()</a>, <a class="el" href="VarManager_8cpp_source.html#l00055">VarManager::push()</a>, <a class="el" href="LearnSynthQBF_8h_source.html#l00364">statistics_</a>, and <a class="el" href="LearnSynthQBF_8h_source.html#l00347">winning_region_</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="afe20b32b1b8c07a237322825c91a36f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBF::check_cnf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> matrix of the QBF for computing counterexamples. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is always F &amp; T &amp; !F', where F is the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00386">386</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00333">computeCounterexampleQBF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00565">recomputeCheckCNF()</a>.</p>

</div>
</div>
<a class="anchor" id="afafe15fef745bb97ac36741cbe00d4c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;<a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>, <a class="el" href="classQBFSolver.html#ac091e263cb55286cc07b2451bcf4d3c7">QBFSolver::Quant</a>&gt; &gt; LearnSynthQBF::check_quant_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The quantifier prefix of the QBF for computing counterexamples. </p>
<p>This quantifier prefix is always exists x,i: forall c: exists x',tmp: </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00379">379</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00333">computeCounterexampleQBF()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a6687cca6f45b9684d3bd6e7cc8c20c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;<a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>, <a class="el" href="classQBFSolver.html#ac091e263cb55286cc07b2451bcf4d3c7">QBFSolver::Quant</a>&gt; &gt; LearnSynthQBF::gen_quant_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The quantifier prefix of the QBF for generalizing counterexamples. </p>
<p>This quantifier prefix is always exists x: forall i: exists c,x',tmp: </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00394">394</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">reduceExistingClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="adb0678a7c034958c31bd5d92615e9859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBF::generalize_clause_cnf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> matrix of the QBF for generalizing counterexamples. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is always F &amp; T &amp; F', where F is the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00401">401</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00588">recomputeGenCNF()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">reduceExistingClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="ad34b0c8db41c054eef617e7e9156fad8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a>* LearnSynthQBF::impl_extractor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The engine to use for circuit extraction. </p>
<p>It will be deleted by this class (in the destructor). </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00442">442</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00092">run()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00079">~LearnSynthQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="a227ff215ffb411e57686aa3d8e7f7026"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LearnSynthQBF::incremental_vars_to_keep_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of variables the SAT-solver should not optimize away. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00424">424</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">computeCounterexampleSAT()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b4c4279f543a0adea992fccf22009f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQBFSolver.html">QBFSolver</a>* LearnSynthQBF::qbf_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The QBF-solver used for all queries. </p>
<p>The type of solver is selected with command-line arguments. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00371">371</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00333">computeCounterexampleQBF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">reduceExistingClauses()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00079">~LearnSynthQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="a14f20d46129ad1fe2db8272348a7e589"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSatSolver.html">SatSolver</a>* LearnSynthQBF::solver_ctrl_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The SAT-solver for protagonist moves when using <a class="el" href="classLearnSynthQBF.html#a3221800bf3f040b66b8a790bab4c82b5" title="Computes a counterexample-state using two competing SAT-solvers. ">computeCounterexampleSAT()</a>. </p>
<p>It stores the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> F &amp; T &amp; !F', where F is the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. However, !F' is only updated lazily for performance reasons (this way, incremental solving can be exploited better). </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00419">419</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00079">~LearnSynthQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="ada2e8c87c0ca0d83c484d6181ea5a788"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSatSolver.html">SatSolver</a>* LearnSynthQBF::solver_i_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The SAT-solver for antagonist moves when using <a class="el" href="classLearnSynthQBF.html#a3221800bf3f040b66b8a790bab4c82b5" title="Computes a counterexample-state using two competing SAT-solvers. ">computeCounterexampleSAT()</a>. </p>
<p>It stores the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> F &amp; T &amp; !F', where F is the <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. However, !F' is only updated lazily for performance reasons (this way, incremental solving can be exploited better). </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00410">410</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00079">~LearnSynthQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="ae65774a2b9e6137d6ff45cbf755d4843"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBF::solver_i_precise_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A flag indicating if solver_i_ is precise. </p>
<p>We update the next-state copy of the winning region in solver_i_ only lazily to better support incremental solving. If this flag is true, then this means that the next-state copy of the winning region is accurate in solver_i_. If this flag is false, then we must not trust any unsatisfiability verdicts coming from solver_i_ (but need to update the next-state copy of the winning region instead). </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00435">435</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">computeCounterexampleSAT()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="a85c46943042fdcfd672ce2251ef49cd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLearnStatisticsQBF.html">LearnStatisticsQBF</a> LearnSynthQBF::statistics_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores and maintains statistics and performance measures. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00364">364</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00432">computeBlockingClause()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00333">computeCounterexampleQBF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">reduceExistingClauses()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00092">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c6b41f7df5f4ed4bfc5930136fc1152"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBF::winning_region_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current over-approximation of the winning region. </p>
<p>Only when <a class="el" href="classLearnSynthQBF.html#ae8219ab3e4987775e1d6a006a9d38f4d" title="Computes the winning region and stores the result in winning_region_. ">computeWinningRegion()</a> is done, this field will store the correct winning region. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00347">347</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00565">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00588">recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">reduceExistingClauses()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00092">run()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9b460cdc140c3969a32ea77982181d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBF::winning_region_large_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current over-approximation of the winning region in an uncompressed form. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is logically equivalent to <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a>. However, <a class="el" href="classLearnSynthQBF.html#a9c6b41f7df5f4ed4bfc5930136fc1152" title="The current over-approximation of the winning region. ">winning_region_</a> is 'compressed' from time to time by removing redundant clauses (clauses that are implied by other clauses in the winning region). This field stores the uncompressed version of the winning region. Having the uncompressed winning region can be good because throwing away redundant clauses is not always beneficial. The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> get smaller, but the solver may have to re-discover the removed clauses. </p>

<p>Definition at line <a class="el" href="LearnSynthQBF_8h_source.html#l00359">359</a> of file <a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00565">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00588">recomputeGenCNF()</a>, and <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">reduceExistingClauses()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="LearnSynthQBF_8h_source.html">LearnSynthQBF.h</a></li>
<li>src/<a class="el" href="LearnSynthQBF_8cpp_source.html">LearnSynthQBF.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 26 2015 08:54:55 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
