<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>demiurge: LearnSynthQBFInd Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classLearnSynthQBFInd-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LearnSynthQBFInd Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a learning-based synthesis with inductive reachability reasoning.  
 <a href="classLearnSynthQBFInd.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LearnSynthQBFInd:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLearnSynthQBFInd.png" usemap="#LearnSynthQBFInd_map" alt=""/>
  <map id="LearnSynthQBFInd_map" name="LearnSynthQBFInd_map">
<area href="classBackEnd.html" title="An interface for the back-ends." alt="BackEnd" shape="rect" coords="0,0,120,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e05b058bbff2f55eeb054e3968a3a70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a3e05b058bbff2f55eeb054e3968a3a70">LearnSynthQBFInd</a> (<a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *impl_extractor)</td></tr>
<tr class="memdesc:a3e05b058bbff2f55eeb054e3968a3a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a3e05b058bbff2f55eeb054e3968a3a70"></a><br/></td></tr>
<tr class="memitem:ae7c562c17f47985549499bb1ea6d4485"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#ae7c562c17f47985549499bb1ea6d4485">~LearnSynthQBFInd</a> ()</td></tr>
<tr class="memdesc:ae7c562c17f47985549499bb1ea6d4485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ae7c562c17f47985549499bb1ea6d4485"></a><br/></td></tr>
<tr class="memitem:a6709343a109f82c427dcbc4a576d9c03"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a6709343a109f82c427dcbc4a576d9c03">run</a> ()</td></tr>
<tr class="memdesc:a6709343a109f82c427dcbc4a576d9c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes this back-end.  <a href="#a6709343a109f82c427dcbc4a576d9c03"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a41593ccf692af8948f4b1255fb13ffe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a41593ccf692af8948f4b1255fb13ffe5">computeWinningRegion</a> ()</td></tr>
<tr class="memdesc:a41593ccf692af8948f4b1255fb13ffe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region and stores the result in <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>.  <a href="#a41593ccf692af8948f4b1255fb13ffe5"></a><br/></td></tr>
<tr class="memitem:a9a48eb17721b9c941689795e0913dc0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a9a48eb17721b9c941689795e0913dc0b">computeWinningRegionOne</a> ()</td></tr>
<tr class="memdesc:a9a48eb17721b9c941689795e0913dc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the standard method to compute the winning region, with inductive reasoning.  <a href="#a9a48eb17721b9c941689795e0913dc0b"></a><br/></td></tr>
<tr class="memitem:a1665e16ff8fa78f696b1e3373db96edb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a1665e16ff8fa78f696b1e3373db96edb">computeWinningRegionAll</a> ()</td></tr>
<tr class="memdesc:a1665e16ff8fa78f696b1e3373db96edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the winning region, always computing all counterexample generalizations.  <a href="#a1665e16ff8fa78f696b1e3373db96edb"></a><br/></td></tr>
<tr class="memitem:a1a771069bb5352236c509593e8f18426"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a1a771069bb5352236c509593e8f18426">computeCounterexampleQBF</a> (vector&lt; int &gt; &amp;ce)</td></tr>
<tr class="memdesc:a1a771069bb5352236c509593e8f18426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a counterexample-state using a QBF-solver with inductive reasoning.  <a href="#a1a771069bb5352236c509593e8f18426"></a><br/></td></tr>
<tr class="memitem:a0ddc68117f68cecdfd09231562f981c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a0ddc68117f68cecdfd09231562f981c7">computeBlockingClause</a> (vector&lt; int &gt; &amp;ce, vector&lt; int &gt; &amp;blocking_clause)</td></tr>
<tr class="memdesc:a0ddc68117f68cecdfd09231562f981c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a blocking clause for a counterexample.  <a href="#a0ddc68117f68cecdfd09231562f981c7"></a><br/></td></tr>
<tr class="memitem:a22e56037bf21941a2a2510eabd97b279"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a22e56037bf21941a2a2510eabd97b279">computeAllBlockingClauses</a> (vector&lt; int &gt; &amp;ce, vector&lt; vector&lt; int &gt; &gt; &amp;blocking_clauses)</td></tr>
<tr class="memdesc:a22e56037bf21941a2a2510eabd97b279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all minimal blocking clauses for a counterexample.  <a href="#a22e56037bf21941a2a2510eabd97b279"></a><br/></td></tr>
<tr class="memitem:a0f02719c7a3b6d928337f310dabff478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a0f02719c7a3b6d928337f310dabff478">reduceExistingClauses</a> ()</td></tr>
<tr class="memdesc:a0f02719c7a3b6d928337f310dabff478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to drop literals from clauses in the winning region.  <a href="#a0f02719c7a3b6d928337f310dabff478"></a><br/></td></tr>
<tr class="memitem:a5c7c552e1e8db8dd80e53778d42e9627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a5c7c552e1e8db8dd80e53778d42e9627">recomputeCheckCNF</a> (bool take_small_win=true)</td></tr>
<tr class="memdesc:a5c7c552e1e8db8dd80e53778d42e9627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recomputes the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> (of the QBF) that is used for computing counterexamples.  <a href="#a5c7c552e1e8db8dd80e53778d42e9627"></a><br/></td></tr>
<tr class="memitem:ae1ed892480cb3404d5ff1e7ee35b5a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#ae1ed892480cb3404d5ff1e7ee35b5a9c">recomputeGenCNF</a> (bool take_small_win=true)</td></tr>
<tr class="memdesc:ae1ed892480cb3404d5ff1e7ee35b5a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recomputes the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> (of the QBF) that is used for generalizing counterexamples.  <a href="#ae1ed892480cb3404d5ff1e7ee35b5a9c"></a><br/></td></tr>
<tr class="memitem:a75417fbbe8b1bedbd1ef158299606929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a75417fbbe8b1bedbd1ef158299606929">restrictToStates</a> (vector&lt; int &gt; &amp;vec) const </td></tr>
<tr class="memdesc:a75417fbbe8b1bedbd1ef158299606929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts a vector of literals (a cube or clause) to state-variables only.  <a href="#a75417fbbe8b1bedbd1ef158299606929"></a><br/></td></tr>
<tr class="memitem:a5a34501e485a063d8120a2a79c39d9c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a5a34501e485a063d8120a2a79c39d9c9">generalizeCounterexample</a> (vector&lt; int &gt; &amp;ce, bool check_sat=true) const </td></tr>
<tr class="memdesc:a5a34501e485a063d8120a2a79c39d9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalizes a counterexample-state by dropping literals.  <a href="#a5a34501e485a063d8120a2a79c39d9c9"></a><br/></td></tr>
<tr class="memitem:a106c202c2855e1d83e0074674fef51a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a106c202c2855e1d83e0074674fef51a9">presentToPrevious</a> (int literal) const </td></tr>
<tr class="memdesc:a106c202c2855e1d83e0074674fef51a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the previous-state copy of a literal.  <a href="#a106c202c2855e1d83e0074674fef51a9"></a><br/></td></tr>
<tr class="memitem:a9a336d870d76716b356a2870eb1bf9b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a9a336d870d76716b356a2870eb1bf9b7">presentToPrevious</a> (vector&lt; int &gt; &amp;cube_or_clause) const </td></tr>
<tr class="memdesc:a9a336d870d76716b356a2870eb1bf9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the previous-state copy of a cube or clause.  <a href="#a9a336d870d76716b356a2870eb1bf9b7"></a><br/></td></tr>
<tr class="memitem:a50be93ab3f6b7bd38c1f607dcb4b91b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a50be93ab3f6b7bd38c1f607dcb4b91b8">presentToPrevious</a> (<a class="el" href="classCNF.html">CNF</a> &amp;cnf) const </td></tr>
<tr class="memdesc:a50be93ab3f6b7bd38c1f607dcb4b91b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the previous-state copy of a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>.  <a href="#a50be93ab3f6b7bd38c1f607dcb4b91b8"></a><br/></td></tr>
<tr class="memitem:abb1bed24925bb028eeb33b2bfb8914a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#abb1bed24925bb028eeb33b2bfb8914a1">debugCheckWinRegReach</a> () const </td></tr>
<tr class="memdesc:abb1bed24925bb028eeb33b2bfb8914a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a winning region computed with optimization RC for correctness.  <a href="#abb1bed24925bb028eeb33b2bfb8914a1"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab8ce6031137413e90e0626bbdc734be0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0">winning_region_</a></td></tr>
<tr class="memdesc:ab8ce6031137413e90e0626bbdc734be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current over-approximation of the winning region.  <a href="#ab8ce6031137413e90e0626bbdc734be0"></a><br/></td></tr>
<tr class="memitem:a333c9336ba28a2c41f252a3051a59581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a333c9336ba28a2c41f252a3051a59581">winning_region_large_</a></td></tr>
<tr class="memdesc:a333c9336ba28a2c41f252a3051a59581"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current over-approximation of the winning region in an uncompressed form.  <a href="#a333c9336ba28a2c41f252a3051a59581"></a><br/></td></tr>
<tr class="memitem:af83f4253aeedaed56cb789369b054724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLearnStatisticsQBF.html">LearnStatisticsQBF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#af83f4253aeedaed56cb789369b054724">statistics_</a></td></tr>
<tr class="memdesc:af83f4253aeedaed56cb789369b054724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores and maintains statistics and performance measures.  <a href="#af83f4253aeedaed56cb789369b054724"></a><br/></td></tr>
<tr class="memitem:ada2a2526b313b2ba4bb9d717fb63362d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQBFSolver.html">QBFSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#ada2a2526b313b2ba4bb9d717fb63362d">qbf_solver_</a></td></tr>
<tr class="memdesc:ada2a2526b313b2ba4bb9d717fb63362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The QBF-solver used for all queries.  <a href="#ada2a2526b313b2ba4bb9d717fb63362d"></a><br/></td></tr>
<tr class="memitem:ab9287e0b57dbf85dab6e7f7caf30cd13"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>, <br class="typebreak"/>
<a class="el" href="classQBFSolver.html#ac091e263cb55286cc07b2451bcf4d3c7">QBFSolver::Quant</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#ab9287e0b57dbf85dab6e7f7caf30cd13">check_quant_</a></td></tr>
<tr class="memdesc:ab9287e0b57dbf85dab6e7f7caf30cd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quantifier prefix of the QBF for computing counterexamples.  <a href="#ab9287e0b57dbf85dab6e7f7caf30cd13"></a><br/></td></tr>
<tr class="memitem:ac90a4574da82c96888db219291368554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#ac90a4574da82c96888db219291368554">check_cnf_</a></td></tr>
<tr class="memdesc:ac90a4574da82c96888db219291368554"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> matrix of the QBF for computing counterexamples.  <a href="#ac90a4574da82c96888db219291368554"></a><br/></td></tr>
<tr class="memitem:a1a20b68cc735e4bbc0cc7030329acb4d"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>, <br class="typebreak"/>
<a class="el" href="classQBFSolver.html#ac091e263cb55286cc07b2451bcf4d3c7">QBFSolver::Quant</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a1a20b68cc735e4bbc0cc7030329acb4d">gen_quant_</a></td></tr>
<tr class="memdesc:a1a20b68cc735e4bbc0cc7030329acb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quantifier prefix of the QBF for generalizing counterexamples.  <a href="#a1a20b68cc735e4bbc0cc7030329acb4d"></a><br/></td></tr>
<tr class="memitem:ad61b112cfcc60506f7b21c9ea9267b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#ad61b112cfcc60506f7b21c9ea9267b37">generalize_clause_cnf_</a></td></tr>
<tr class="memdesc:ad61b112cfcc60506f7b21c9ea9267b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> matrix of the QBF for generalizing counterexamples.  <a href="#ad61b112cfcc60506f7b21c9ea9267b37"></a><br/></td></tr>
<tr class="memitem:a8047ab13c44736c39c11f9c0b48e29cf"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a8047ab13c44736c39c11f9c0b48e29cf">current_to_previous_map_</a></td></tr>
<tr class="memdesc:a8047ab13c44736c39c11f9c0b48e29cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from present-state variables to their previous-state copy.  <a href="#a8047ab13c44736c39c11f9c0b48e29cf"></a><br/></td></tr>
<tr class="memitem:a36e64e8ac156ca4978e73be5493de782"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a36e64e8ac156ca4978e73be5493de782">current_state_is_initial_</a></td></tr>
<tr class="memdesc:a36e64e8ac156ca4978e73be5493de782"><td class="mdescLeft">&#160;</td><td class="mdescRight">A literal that is true if the current state is initial and false otherwise.  <a href="#a36e64e8ac156ca4978e73be5493de782"></a><br/></td></tr>
<tr class="memitem:ad99eafb7ee9134115f9fbe986e5eb0c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#ad99eafb7ee9134115f9fbe986e5eb0c5">prev_trans_or_initial_</a></td></tr>
<tr class="memdesc:ad99eafb7ee9134115f9fbe986e5eb0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Says: the current state is initial or the previous transition relation holds.  <a href="#ad99eafb7ee9134115f9fbe986e5eb0c5"></a><br/></td></tr>
<tr class="memitem:a6854254065f912e3d5fe07a1b895f1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a6854254065f912e3d5fe07a1b895f1c6">check_reach_</a></td></tr>
<tr class="memdesc:a6854254065f912e3d5fe07a1b895f1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Says: <a class="el" href="classLearnSynthQBFInd.html#ad99eafb7ee9134115f9fbe986e5eb0c5" title="Says: the current state is initial or the previous transition relation holds.">prev_trans_or_initial_</a> and the current state is different from the previous.  <a href="#a6854254065f912e3d5fe07a1b895f1c6"></a><br/></td></tr>
<tr class="memitem:af87e4a2c1d17c4c5bc398082d6d3e365"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#af87e4a2c1d17c4c5bc398082d6d3e365">do_reach_check_</a></td></tr>
<tr class="memdesc:af87e4a2c1d17c4c5bc398082d6d3e365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables optimization RC.  <a href="#af87e4a2c1d17c4c5bc398082d6d3e365"></a><br/></td></tr>
<tr class="memitem:a8c285416b6f27e86bdda92fd578327b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a8c285416b6f27e86bdda92fd578327b8">impl_extractor_</a></td></tr>
<tr class="memdesc:a8c285416b6f27e86bdda92fd578327b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The engine to use for circuit extraction.  <a href="#a8c285416b6f27e86bdda92fd578327b8"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a55edd29ba2b93167b7d7b2bf6b835673"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a55edd29ba2b93167b7d7b2bf6b835673">LearnSynthQBFInd</a> (const <a class="el" href="classLearnSynthQBFInd.html">LearnSynthQBFInd</a> &amp;other)</td></tr>
<tr class="memdesc:a55edd29ba2b93167b7d7b2bf6b835673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a55edd29ba2b93167b7d7b2bf6b835673"></a><br/></td></tr>
<tr class="memitem:a411e8fa65ea22877c0fa9180f31120f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLearnSynthQBFInd.html">LearnSynthQBFInd</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearnSynthQBFInd.html#a411e8fa65ea22877c0fa9180f31120f9">operator=</a> (const <a class="el" href="classLearnSynthQBFInd.html">LearnSynthQBFInd</a> &amp;other)</td></tr>
<tr class="memdesc:a411e8fa65ea22877c0fa9180f31120f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a411e8fa65ea22877c0fa9180f31120f9"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implements a learning-based synthesis with inductive reachability reasoning. </p>
<p>This class is almost an exact copy of <a class="el" href="classLearnSynthQBF.html" title="Implements a learning-based synthesis using a QBF solver.">LearnSynthQBF</a>. Hence, we refer to the documentation of <a class="el" href="classLearnSynthQBF.html" title="Implements a learning-based synthesis using a QBF solver.">LearnSynthQBF</a> for an explanation of the basic working principle. The main difference is that this class uses a reachability optimization that is inspired by the concept of inductiveness relative to a certain clause set used in IC3. Refer to the VMCAI'14 publication "SAT-Based Synthesis Methods for Safety Specs" for a detailed explanation how (and why) this works. The class <a class="el" href="classLearnSynthQBF.html" title="Implements a learning-based synthesis using a QBF solver.">LearnSynthQBF</a> computes counterexamples by solving: exists x,i: forall c: exists x',tmp: F(x) &amp; T(x,i,c,x') &amp; !F(x') <br/>
 and generalizes them by checking exists x: forall i: exists c,x',tmp: s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 repeatedly, where s is the counterexample and F is the current over-approximation of the winning region.</p>
<p>We know that F(x) is never left by the final implementation. Hence, F is an over-approximation of the reachable states. Now if a state s is not initial and !s &amp; F &amp; T =&gt; !s', then we know by induction that the state s is unreachable. We can disregard unreachable states both in the computation of counterexamples as well as during the generalization. This is done by gluing the constraints !s &amp; F &amp; T =&gt; !s' and !I(s) to the generalization and check queries as following. The check query becomes: <br/>
 &#160; exists x*,i*,c*,x,i: forall c: exists x',tmp: (I(x) | (x* != x) &amp; F(x*) &amp; T(x*, i*, c*, x)) &amp; F(x) &amp; T(x,i,c,x') &amp; !F(x') <br/>
 where x*, i* and c* are the previous-state copy of x,i,c. The query now says: find a counterexample-state x that is either initial or has a predecessor x* in F such that x* is different from x. (Otherwise the counterexample-state is unreachable.) The generalization query becomes: <br/>
 &#160; exists x*,i*,c*,x: forall i: exists c,x',tmp: (I(x) | F(x*) &amp; !s* &amp; T(x*, i*, c*, x)) &amp; s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 where x*, i* and c* are the previous-state copy of x,i,c. The query now says: a state that prevents generalization must be either initial or have a predecessor in F &amp; !s. Otherwise it is unreachable and we do not care. This means that we can remove states that are winning for the protagonist from the winning region of they are unreachalbe in the final implementation.</p>
<p>The modification of the generalization is called optimization RG in the VMCAI paper. The modification of the counterexample-computation is called optimization RC. Depending on the command-line parameters (&ndash;mode) this class performs either just one or both optimizations. Experiments suggest that optimization RG is often beneficial, while optimization RC is usually not. Optimization RC leads to a winning region which cannot be turned into a circuit with the standard method.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Turning a winning region that was computed with optimization RC into a circuit is not yet implemented. However, since optimization RC does not increase the performance in our experiments (in contrast to optimization RG), this is not a severe issue at the moment. We can consider optimization RC as experiment that did not work out well. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This class is experimental. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.1.0 </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00100">100</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3e05b058bbff2f55eeb054e3968a3a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LearnSynthQBFInd::LearnSynthQBFInd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td>
          <td class="paramname"><em>impl_extractor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl_extractor</td><td>The engine to use for circuit extraction. It will be deleted by this class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">40</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="QBFSolver_8h_source.html#l00067">QBFSolver::A</a>, <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00186">CNF::add3LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00443">check_quant_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00503">check_reach_</a>, <a class="el" href="VarManager_8cpp_source.html#l00251">VarManager::createFreshPrevVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00485">current_state_is_initial_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00475">current_to_previous_map_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00511">do_reach_check_</a>, <a class="el" href="QBFSolver_8h_source.html#l00062">QBFSolver::E</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00463">gen_quant_</a>, <a class="el" href="CNF_8cpp_source.html#l00346">CNF::getClauses()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00210">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>, <a class="el" href="VarInfo_8h_source.html#l00097">VarInfo::PREV</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00494">prev_trans_or_initial_</a>, <a class="el" href="CNF_8cpp_source.html#l00286">CNF::swapWith()</a>, and <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>.</p>

</div>
</div>
<a class="anchor" id="ae7c562c17f47985549499bb1ea6d4485"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LearnSynthQBFInd::~LearnSynthQBFInd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00137">137</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBFInd_8h_source.html#l00518">impl_extractor_</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00433">qbf_solver_</a>.</p>

</div>
</div>
<a class="anchor" id="a55edd29ba2b93167b7d7b2bf6b835673"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LearnSynthQBFInd::LearnSynthQBFInd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLearnSynthQBFInd.html">LearnSynthQBFInd</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a22e56037bf21941a2a2510eabd97b279"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::computeAllBlockingClauses </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocking_clauses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes all minimal blocking clauses for a counterexample. </p>
<p>This method works like <a class="el" href="classLearnSynthQBF.html#affa7b4583cc17d01f4c82fd57e763e1f" title="Computes all minimal blocking clauses for a counterexample.">LearnSynthQBF::computeAllBlockingClauses()</a> but using inductive reasoning regarding reachable states as an optimization. That is, instead of solving <br/>
 &#160; exists x: forall i: exists c,x',tmp: s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 where s is the counterexample-state to generalize, we solve <br/>
 &#160; exists x*,i*,c*,x: forall i: exists c,x',tmp: (I(x) | F(x*) &amp; !s* &amp; T(x*, i*, c*, x)) &amp; s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 The query now says: a state that prevents generalization must be either initial or have a predecessor in F &amp; !s. Otherwise it is unreachable and we do not care. This means that we can remove states that are winning for the protagonist from the winning region of they are unreachable in the final implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>The counterexample to block. It is a full or partial cube over the state variables. </td></tr>
    <tr><td class="paramname">blocking_clauses</td><td>An empty vector. It is used to store the computed blocking clauses. The counterexample falsifies all blocking clauses in this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if one of the blocking clauses blocks the initial state. This means that the initial state is removed from the winning region, i.e., the specification is unrealizable. True is returned otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">364</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="Utils_8cpp_source.html#l00041">Utils::containsInit()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00470">generalize_clause_cnf_</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">generalizeCounterexample()</a>, <a class="el" href="Utils_8cpp_source.html#l00230">Utils::intersectionEmpty()</a>, <a class="el" href="Utils_8cpp_source.html#l00202">Utils::negateLiterals()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00089">LearnStatisticsQBF::notifyAfterCubeMin()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00083">LearnStatisticsQBF::notifyBeforeCubeMin()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00106">LearnStatisticsQBF::notifyCubeMin()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>, <a class="el" href="Utils_8cpp_source.html#l00176">Utils::remove()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00426">statistics_</a>, and <a class="el" href="Utils_8cpp_source.html#l00209">Utils::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ddc68117f68cecdfd09231562f981c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::computeBlockingClause </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocking_clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a blocking clause for a counterexample. </p>
<p>This method works like <a class="el" href="classLearnSynthQBF.html#a73856a79be3fb7e260485bcda7c31f80" title="Computes a blocking clause for a counterexample.">LearnSynthQBF::computeBlockingClause()</a> but using inductive reasoning regarding reachable states as an optimization. That is, instead of solving <br/>
 &#160; exists x: forall i: exists c,x',tmp: s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 where s is the counterexample-state to generalize, we solve <br/>
 &#160; exists x*,i*,c*,x: forall i: exists c,x',tmp: (I(x) | F(x*) &amp; !s* &amp; T(x*, i*, c*, x)) &amp; s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 The query now says: a state that prevents generalization must be either initial or have a predecessor in F &amp; !s. Otherwise it is unreachable and we do not care. This means that we can remove states that are winning for the protagonist from the winning region of they are unreachable in the final implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>The counterexample to block. It is a full or partial cube over the state variables. </td></tr>
    <tr><td class="paramname">blocking_clause</td><td>An empty vector. It is used to store the computed blocking clause. The counterexample falsifies the blocking clause. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the blocking clause blocks the initial state. This means that the initial state is removed from the winning region, i.e., the specification is unrealizable. True is returned otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00346">346</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="Utils_8cpp_source.html#l00041">Utils::containsInit()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">generalizeCounterexample()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="Utils_8cpp_source.html#l00202">Utils::negateLiterals()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00089">LearnStatisticsQBF::notifyAfterCubeMin()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00083">LearnStatisticsQBF::notifyBeforeCubeMin()</a>, <a class="el" href="Utils_8cpp_source.html#l00164">Utils::randomize()</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00426">statistics_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a771069bb5352236c509593e8f18426"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::computeCounterexampleQBF </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a counterexample-state using a QBF-solver with inductive reasoning. </p>
<p>This method works like <a class="el" href="classLearnSynthQBF.html#a04b8dd6e26d646a6f197afb362168408" title="Computes a counterexample-state using a QBF-solver.">LearnSynthQBF::computeCounterexampleQBF()</a> but using inductive reasoning regarding reachable states as an optimization. That is, instead of solving <br/>
 &#160; exists x,i: forall c: exists x',tmp: F(x) &amp; T(x,i,c,x') &amp; !F(x') <br/>
 we solve <br/>
 &#160; exists x*,i*,c*,x,i: forall c: exists x',tmp: (I(x) | (x* != x) &amp; F(x*) &amp; T(x*, i*, c*, x)) &amp; F(x) &amp; T(x,i,c,x') &amp; !F(x') <br/>
 to obtain a counterexample. The query now says: find a counterexample-state x that is either initial or has a predecessor x* in F such that x* is different from x. (Otherwise the counterexample-state is unreachable.)</p>
<p>If optimization RC is disabled (<a class="el" href="classLearnSynthQBFInd.html#af87e4a2c1d17c4c5bc398082d6d3e365" title="Enables or disables optimization RC.">do_reach_check_</a> is false), then counterexamples are computed in the standard way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>An empty vector. The computed counterexample is stored in this vector in form of a cube over the state variables. The cube does not necessarily contain all state variables. If some state variables are irrelevant, then they may be omitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a counterexample was found, false if no counterexample exists. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00335">335</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBFInd_8h_source.html#l00455">check_cnf_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00443">check_quant_</a>, <a class="el" href="classQBFSolver.html#a76fc0c757a2c039816e3e06547f06d5c">QBFSolver::isSatModel()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00075">LearnStatisticsQBF::notifyAfterComputeCube()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00069">LearnStatisticsQBF::notifyBeforeComputeCube()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00433">qbf_solver_</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00550">restrictToStates()</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00426">statistics_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>.</p>

</div>
</div>
<a class="anchor" id="a41593ccf692af8948f4b1255fb13ffe5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::computeWinningRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region and stores the result in <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>. </p>
<p>Depending on the command-line parameters (&ndash;mode) this method calls one of </p>
<ul>
<li>
<a class="el" href="classLearnSynthQBFInd.html#a9a48eb17721b9c941689795e0913dc0b" title="Uses the standard method to compute the winning region, with inductive reasoning.">computeWinningRegionOne()</a> </li>
<li>
<a class="el" href="classLearnSynthQBFInd.html#a1665e16ff8fa78f696b1e3373db96edb" title="Computes the winning region, always computing all counterexample generalizations.">computeWinningRegionAll()</a> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00178">178</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>, <a class="el" href="Utils_8cpp_source.html#l00407">Utils::debugCheckWinReg()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00633">debugCheckWinRegReach()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00511">do_reach_check_</a>, <a class="el" href="Options_8cpp_source.html#l00390">Options::getBackEndMode()</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">winning_region_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00147">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a1665e16ff8fa78f696b1e3373db96edb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::computeWinningRegionAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the winning region, always computing all counterexample generalizations. </p>
<p>This method works like <a class="el" href="classLearnSynthQBF.html#ac538cd53082bad1c8c45a7e178dfa4cb" title="Uses the standard method to compute the winning region.">LearnSynthQBF::computeWinningRegionOne()</a> but using inductive reasoning regarding reachable states as an optimization (as explained in the description of the class).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">269</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00455">check_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="Utils_8cpp_source.html#l00287">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00335">computeCounterexampleQBF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Logger_8h_source.html#l00105">Logger::DBG</a>, <a class="el" href="Utils_8cpp_source.html#l00392">Utils::debugPrint()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00470">generalize_clause_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00292">CNF::getNrOfClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00298">CNF::getNrOfLits()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00228">AIG2CNF::getSafeStates()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00036">Logger::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00085">Logger::isEnabled()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00114">LearnStatisticsQBF::logStatistics()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00426">statistics_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">winning_region_</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00421">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00178">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a48eb17721b9c941689795e0913dc0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::computeWinningRegionOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the standard method to compute the winning region, with inductive reasoning. </p>
<p>This method works like <a class="el" href="classLearnSynthQBF.html#ac538cd53082bad1c8c45a7e178dfa4cb" title="Uses the standard method to compute the winning region.">LearnSynthQBF::computeWinningRegionOne()</a> but using inductive reasoning regarding reachable states as an optimization (as explained in the description of the class).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">197</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00455">check_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="Utils_8cpp_source.html#l00287">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00346">computeBlockingClause()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00335">computeCounterexampleQBF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Logger_8h_source.html#l00105">Logger::DBG</a>, <a class="el" href="Utils_8cpp_source.html#l00392">Utils::debugPrint()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00470">generalize_clause_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00292">CNF::getNrOfClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00298">CNF::getNrOfLits()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00228">AIG2CNF::getSafeStates()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00036">Logger::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="Logger_8cpp_source.html#l00085">Logger::isEnabled()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00114">LearnStatisticsQBF::logStatistics()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00426">statistics_</a>, <a class="el" href="Utils_8cpp_source.html#l00209">Utils::swapPresentToNext()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">winning_region_</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00421">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00178">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="abb1bed24925bb028eeb33b2bfb8914a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBFInd::debugCheckWinRegReach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks a winning region computed with optimization RC for correctness. </p>
<p>We usually check the correctness of the winning region in debug-mode by calling <a class="el" href="classUtils.html#acc29602987b73022546a6d752a7e093f" title="Checks a winning region for correctness.">Utils::debugCheckWinReg()</a>. However, this method of <a class="el" href="classUtils.html" title="Contains utility functions that can be usful in various back-ends.">Utils</a> does not work for winning regions that have been computed with optimization RC enabled. In such cases we this method. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00633">633</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="QBFSolver_8h_source.html#l00067">QBFSolver::A</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="QBFSolver_8h_source.html#l00062">QBFSolver::E</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="LingelingApi_8cpp_source.html#l00051">LingelingApi::isSat()</a>, <a class="el" href="classQBFSolver.html#a53ef157391b176dfbd2a77a1e31befc3">QBFSolver::isSat()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="defines_8h_source.html#l00059">MASSERT</a>, <a class="el" href="CNF_8cpp_source.html#l00264">CNF::negate()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>, <a class="el" href="VarInfo_8h_source.html#l00097">VarInfo::PREV</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00494">prev_trans_or_initial_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00433">qbf_solver_</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">winning_region_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00178">computeWinningRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a34501e485a063d8120a2a79c39d9c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::generalizeCounterexample </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_sat</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generalizes a counterexample-state by dropping literals. </p>
<p>This method works like <a class="el" href="classLearnSynthQBF.html#a9eed607741968f74e31976e8ca40a62f" title="Generalizes a counterexample-state by dropping literals.">LearnSynthQBF::generalizeCounterexample()</a> but using inductive reasoning regarding reachable states as an optimization. That is, instead of solving <br/>
 &#160; exists x: forall i: exists c,x',tmp: s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 where s is the counterexample-state to generalize, we solve <br/>
 &#160; exists x*,i*,c*,x: forall i: exists c,x',tmp: (I(x) | F(x*) &amp; !s* &amp; T(x*, i*, c*, x)) &amp; s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 The query now says: a state that prevents generalization must be either initial or have a predecessor in F &amp; !s. Otherwise it is unreachable and we do not care. This means that we can remove states that are winning for the protagonist from the winning region of they are unreachable in the final implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>The counterexample to generalize (it will be overwritten by its own generalization). This is a complete or partial cube over the present state variables. </td></tr>
    <tr><td class="paramname">check_sat</td><td>False if ce is a counterexample (for which a generalization exists) for sure. False if this may not be the case and needs to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the passed vector is a valid (generalization of a) counterexample, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">569</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00130">CNF::addCube()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00485">current_state_is_initial_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00463">gen_quant_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00470">generalize_clause_cnf_</a>, <a class="el" href="classQBFSolver.html#a53ef157391b176dfbd2a77a1e31befc3">QBFSolver::isSat()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00433">qbf_solver_</a>, <a class="el" href="Utils_8cpp_source.html#l00176">Utils::remove()</a>, <a class="el" href="Utils_8cpp_source.html#l00170">Utils::sort()</a>, and <a class="el" href="Utils_8cpp_source.html#l00209">Utils::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">computeAllBlockingClauses()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00346">computeBlockingClause()</a>.</p>

</div>
</div>
<a class="anchor" id="a411e8fa65ea22877c0fa9180f31120f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLearnSynthQBFInd.html">LearnSynthQBFInd</a>&amp; LearnSynthQBFInd::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLearnSynthQBFInd.html">LearnSynthQBFInd</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="a106c202c2855e1d83e0074674fef51a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LearnSynthQBFInd::presentToPrevious </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the previous-state copy of a literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">literal</td><td>The literal to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous-state copy of a literal. </dd></dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">603</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBFInd_8h_source.html#l00475">current_to_previous_map_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00633">debugCheckWinRegReach()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00613">presentToPrevious()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">recomputeGenCNF()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a336d870d76716b356a2870eb1bf9b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBFInd::presentToPrevious </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube_or_clause</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the previous-state copy of a cube or clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube_or_clause</td><td>A cube or clause (in form of a vector of literals) over the present state variables. This vector is overwritten by the corresponding cube of clause over the previous-state literals (i.e., all literals are replaced by their previous-state copy). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00613">613</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>.</p>

</div>
</div>
<a class="anchor" id="a50be93ab3f6b7bd38c1f607dcb4b91b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBFInd::presentToPrevious </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>cnf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the previous-state copy of a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf</td><td>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> formula over the present state variables. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is overwritten by the corresponding <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> over the previous-state literals (i.e., all literals are replaced by their previous-state copy). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00620">620</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="CNF_8cpp_source.html#l00346">CNF::getClauses()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c7c552e1e8db8dd80e53778d42e9627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBFInd::recomputeCheckCNF </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_small_win</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recomputes the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> (of the QBF) that is used for computing counterexamples. </p>
<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> used for computing counterexamples is F &amp; T &amp; !F' if optimization RC is disabled (<a class="el" href="classLearnSynthQBFInd.html#a6854254065f912e3d5fe07a1b895f1c6" title="Says: prev_trans_or_initial_ and the current state is different from the previous.">check_reach_</a> = false) , or (I | (x* != x) &amp; F* &amp; T*) &amp; F &amp; T &amp; !F' if optimization RC in enabled (<a class="el" href="classLearnSynthQBFInd.html#a6854254065f912e3d5fe07a1b895f1c6" title="Says: prev_trans_or_initial_ and the current state is different from the previous.">check_reach_</a> = true). Here F is the current over-approximation of the winning region (in <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>). This formula is put into <a class="el" href="classLearnSynthQBFInd.html#ac90a4574da82c96888db219291368554" title="The CNF matrix of the QBF for computing counterexamples.">check_cnf_</a> by this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">take_small_win</td><td>If this parameter is true (or omitted) the <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a> is used to compute the <a class="el" href="classLearnSynthQBFInd.html#ac90a4574da82c96888db219291368554" title="The CNF matrix of the QBF for computing counterexamples.">check_cnf_</a>. Otherwise, the <a class="el" href="classLearnSynthQBFInd.html#a333c9336ba28a2c41f252a3051a59581" title="The current over-approximation of the winning region in an uncompressed form.">winning_region_large_</a> is used. The difference between these two winning region versions is as follows. From time to we remove redundant clauses (clauses implied by other clauses) from <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a> but not from <a class="el" href="classLearnSynthQBFInd.html#a333c9336ba28a2c41f252a3051a59581" title="The current over-approximation of the winning region in an uncompressed form.">winning_region_large_</a>. Hence, <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a> is often smaller, but <a class="el" href="classLearnSynthQBFInd.html#a333c9336ba28a2c41f252a3051a59581" title="The current over-approximation of the winning region in an uncompressed form.">winning_region_large_</a> may contain clauses the solver may have to learn when using <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">490</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00455">check_cnf_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00503">check_reach_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00511">do_reach_check_</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="CNF_8cpp_source.html#l00264">CNF::negate()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>, <a class="el" href="VarManager_8cpp_source.html#l00063">VarManager::resetToLastPush()</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">winning_region_</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00421">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1ed892480cb3404d5ff1e7ee35b5a9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBFInd::recomputeGenCNF </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_small_win</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recomputes the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> (of the QBF) that is used for generalizing counterexamples. </p>
<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> used for generalizing counterexamples is (I | F* &amp; T*) &amp; F &amp; T &amp; F' where F is the current over-approximation of the winning region (in <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">take_small_win</td><td>If this parameter is true (or omitted) the <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a> is used to compute the <a class="el" href="classLearnSynthQBFInd.html#ac90a4574da82c96888db219291368554" title="The CNF matrix of the QBF for computing counterexamples.">check_cnf_</a>. Otherwise, the <a class="el" href="classLearnSynthQBFInd.html#a333c9336ba28a2c41f252a3051a59581" title="The current over-approximation of the winning region in an uncompressed form.">winning_region_large_</a> is used. The difference between these two winning region versions is as follows. From time to we remove redundant clauses (clauses implied by other clauses) from <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a> but not from <a class="el" href="classLearnSynthQBFInd.html#a333c9336ba28a2c41f252a3051a59581" title="The current over-approximation of the winning region in an uncompressed form.">winning_region_large_</a>. Hence, <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a> is often smaller, but <a class="el" href="classLearnSynthQBFInd.html#a333c9336ba28a2c41f252a3051a59581" title="The current over-approximation of the winning region in an uncompressed form.">winning_region_large_</a> may contain clauses the solver may have to learn when using <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">522</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00470">generalize_clause_cnf_</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00494">prev_trans_or_initial_</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">winning_region_</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00421">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f02719c7a3b6d928337f310dabff478"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBFInd::reduceExistingClauses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to drop literals from clauses in the winning region. </p>
<p>This method examines all clauses (in <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>) that have already been computed and checks if more literals can be dropped. This is done in the same way as for dropping literals when generalizing a counterexample.</p>
<p>The intuition behind this method is that, even if a literal could not be dropped before, it could be dropped at a later point in time because the winning region has been refined in the meantime. However, in practice, typically only very few additional literals can be dropped, so this method often does not pay off. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">452</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="CNF_8cpp_source.html#l00123">CNF::addNegClauseAsCube()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00485">current_state_is_initial_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00463">gen_quant_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00470">generalize_clause_cnf_</a>, <a class="el" href="CNF_8cpp_source.html#l00346">CNF::getClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00292">CNF::getNrOfClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00298">CNF::getNrOfLits()</a>, <a class="el" href="classQBFSolver.html#a53ef157391b176dfbd2a77a1e31befc3">QBFSolver::isSat()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00089">LearnStatisticsQBF::notifyAfterCubeMin()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00083">LearnStatisticsQBF::notifyBeforeCubeMin()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00433">qbf_solver_</a>, <a class="el" href="Utils_8cpp_source.html#l00176">Utils::remove()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00426">statistics_</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">winning_region_</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00421">winning_region_large_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>.</p>

</div>
</div>
<a class="anchor" id="a75417fbbe8b1bedbd1ef158299606929"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearnSynthQBFInd::restrictToStates </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts a vector of literals (a cube or clause) to state-variables only. </p>
<p>That is, all literals that do not talk about present state variables are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of literals (the cube or clause) to restricts to state-variables only. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00550">550</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="VarManager_8cpp_source.html#l00267">VarManager::getInfo()</a>, <a class="el" href="VarInfo_8cpp_source.html#l00079">VarInfo::getKind()</a>, <a class="el" href="VarManager_8cpp_source.html#l00320">VarManager::getPresErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, and <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00335">computeCounterexampleQBF()</a>.</p>

</div>
</div>
<a class="anchor" id="a6709343a109f82c427dcbc4a576d9c03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes this back-end. </p>
<p>In contrast to the corresponding method of <a class="el" href="classLearnSynthQBF.html" title="Implements a learning-based synthesis using a QBF solver.">LearnSynthQBF</a>, this method applies some inductive reachability reasoning as an optimization (attempt). The reachability optimization is inspired by the concept of inductiveness relative to a certain clause set used in IC3. Refer to the VMCAI'14 publication "SAT-Based Synthesis Methods for Safety
Specs" for a detailed explanation how (and why) this works. The method <a class="el" href="classLearnSynthQBF.html#aed85bb2fe317a5fdc7eef71fe598c606" title="Executes this back-end.">LearnSynthQBF::run()</a> computes counterexamples by solving: <br/>
 &#160; exists x,i: forall c: exists x',tmp: F(x) &amp; T(x,i,c,x') &amp; !F(x') <br/>
 and generalizes them by checking <br/>
 &#160; exists x: forall i: exists c,x',tmp: s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 repeatedly, where s is the counterexample and F is the current over-approximation of the winning region.</p>
<p>We know that F(x) is never left by the final implementation. Hence, F is an over-approximation of the reachable states. Now if a state s is not initial and !s &amp; F &amp; T =&gt; !s', then we know by induction that the state s is unreachable. We can disregard unreachable states both in the computation of counterexamples as well as during the generalization. This is done by gluing the constraints !s &amp; F &amp; T =&gt; !s' and !I(s) to the generalization and check queries as following. The check query becomes: <br/>
 &#160; exists x*,i*,c*,x,i: forall c: exists x',tmp: (I(x) | (x* != x) &amp; F(x*) &amp; T(x*, i*, c*, x)) &amp; F(x) &amp; T(x,i,c,x') &amp; !F(x') <br/>
 where x*, i* and c* are the previous-state copy of x,i,c. The query now says: find a counterexample-state x that is either initial or has a predecessor x* in F such that x* is different from x. (Otherwise the counterexample-state is unreachable.) The generalization query becomes: <br/>
 &#160; exists x*,i*,c*,x: forall i: exists c,x',tmp: (I(x) | F(x*) &amp; !s* &amp; T(x*, i*, c*, x)) &amp; s &amp; F(x) &amp; T(x,i,c,x') &amp; F(x') <br/>
 where x*, i* and c* are the previous-state copy of x,i,c. The query now says: a state that prevents generalization must be either initial or have a predecessor in F &amp; !s. Otherwise it is unreachable and we do not care. This means that we can remove states that are winning for the protagonist from the winning region of they are unreachable in the final implementation.</p>
<p>The modification of the generalization is called optimization RG in the VMCAI paper. The modification of the counterexample-computation is called optimization RC. Depending on the command-line parameters (&ndash;mode) this class performs either just one or both optimizations. Experiments suggest that optimization RG is often beneficial, while optimization RC is usually not.</p>
<dl class="section note"><dt>Note</dt><dd>When optimization RC in enabled, we cannot extract a circuit from the winning region at the moment. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classBackEnd.html#a099e717dc71e9cc2d838b1ca86340590">BackEnd</a>.</p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00147">147</a> of file <a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a>.</p>

<p>References <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00178">computeWinningRegion()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00511">do_reach_check_</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">CNFImplExtractor::extractCircuit()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00518">impl_extractor_</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="Logger_8h_source.html#l00302">L_INF</a>, <a class="el" href="Logger_8h_source.html#l00285">L_RES</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00290">CNFImplExtractor::logStatistics()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00114">LearnStatisticsQBF::logStatistics()</a>, <a class="el" href="defines_8h_source.html#l00059">MASSERT</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00062">LearnStatisticsQBF::notifyWinRegEnd()</a>, <a class="el" href="LearnStatisticsQBF_8cpp_source.html#l00056">LearnStatisticsQBF::notifyWinRegStart()</a>, <a class="el" href="VarManager_8cpp_source.html#l00055">VarManager::push()</a>, <a class="el" href="LearnSynthQBFInd_8h_source.html#l00426">statistics_</a>, and <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">winning_region_</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="ac90a4574da82c96888db219291368554"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBFInd::check_cnf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> matrix of the QBF for computing counterexamples. </p>
<p>If optimization RC in enabled (<a class="el" href="classLearnSynthQBFInd.html#af87e4a2c1d17c4c5bc398082d6d3e365" title="Enables or disables optimization RC.">do_reach_check_</a> is true), then this <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is <br/>
 &#160; (I | (x* != x) &amp; F* &amp; T*) &amp; F &amp; T &amp; !F' <br/>
 otherwise (if <a class="el" href="classLearnSynthQBFInd.html#af87e4a2c1d17c4c5bc398082d6d3e365" title="Enables or disables optimization RC.">do_reach_check_</a> is false) it is <br/>
 &#160; F &amp; T &amp; !F' <br/>
 where F is the current over-approximation of the winning region (store in <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>). </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00455">455</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00335">computeCounterexampleQBF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">recomputeCheckCNF()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9287e0b57dbf85dab6e7f7caf30cd13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;<a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>, <a class="el" href="classQBFSolver.html#ac091e263cb55286cc07b2451bcf4d3c7">QBFSolver::Quant</a>&gt; &gt; LearnSynthQBFInd::check_quant_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The quantifier prefix of the QBF for computing counterexamples. </p>
<p>If optimization RC in enabled (<a class="el" href="classLearnSynthQBFInd.html#af87e4a2c1d17c4c5bc398082d6d3e365" title="Enables or disables optimization RC.">do_reach_check_</a> is true), then this quantifier prefix is <br/>
 &#160; exists x*,i*,c*,x,i: forall c: exists x',tmp: <br/>
 otherwise (if <a class="el" href="classLearnSynthQBFInd.html#af87e4a2c1d17c4c5bc398082d6d3e365" title="Enables or disables optimization RC.">do_reach_check_</a> is false) it is <br/>
 &#160; exists x,i: forall c: exists x',tmp: <br/>
 </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00443">443</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00335">computeCounterexampleQBF()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd()</a>.</p>

</div>
</div>
<a class="anchor" id="a6854254065f912e3d5fe07a1b895f1c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBFInd::check_reach_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Says: <a class="el" href="classLearnSynthQBFInd.html#ad99eafb7ee9134115f9fbe986e5eb0c5" title="Says: the current state is initial or the previous transition relation holds.">prev_trans_or_initial_</a> and the current state is different from the previous. </p>
<p>If the optimization RC is disabled (<a class="el" href="classLearnSynthQBFInd.html#af87e4a2c1d17c4c5bc398082d6d3e365" title="Enables or disables optimization RC.">do_reach_check_</a> is false) then this <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is simply TRUE. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is an important building block for <a class="el" href="classLearnSynthQBFInd.html#ac90a4574da82c96888db219291368554" title="The CNF matrix of the QBF for computing counterexamples.">check_cnf_</a> (the part that stays constant over all iterations). Hence, it is computed once and copied whenever needed. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00503">503</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">recomputeCheckCNF()</a>.</p>

</div>
</div>
<a class="anchor" id="a36e64e8ac156ca4978e73be5493de782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LearnSynthQBFInd::current_state_is_initial_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A literal that is true if the current state is initial and false otherwise. </p>
<p>The clauses assigning the literal are part of <a class="el" href="classLearnSynthQBFInd.html#ad99eafb7ee9134115f9fbe986e5eb0c5" title="Says: the current state is initial or the previous transition relation holds.">prev_trans_or_initial_</a>. Since <a class="el" href="classLearnSynthQBFInd.html#ad99eafb7ee9134115f9fbe986e5eb0c5" title="Says: the current state is initial or the previous transition relation holds.">prev_trans_or_initial_</a> is part of <a class="el" href="classLearnSynthQBFInd.html#ac90a4574da82c96888db219291368554" title="The CNF matrix of the QBF for computing counterexamples.">check_cnf_</a> and <a class="el" href="classLearnSynthQBFInd.html#ad61b112cfcc60506f7b21c9ea9267b37" title="The CNF matrix of the QBF for generalizing counterexamples.">generalize_clause_cnf_</a>, this literal is also assigned by <a class="el" href="classLearnSynthQBFInd.html#ac90a4574da82c96888db219291368554" title="The CNF matrix of the QBF for computing counterexamples.">check_cnf_</a> (if optimization RC is enabled, i.e., if <a class="el" href="classLearnSynthQBFInd.html#af87e4a2c1d17c4c5bc398082d6d3e365" title="Enables or disables optimization RC.">do_reach_check_</a> is true) and <a class="el" href="classLearnSynthQBFInd.html#ad61b112cfcc60506f7b21c9ea9267b37" title="The CNF matrix of the QBF for generalizing counterexamples.">generalize_clause_cnf_</a>. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00485">485</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="a8047ab13c44736c39c11f9c0b48e29cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LearnSynthQBFInd::current_to_previous_map_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A map from present-state variables to their previous-state copy. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00475">475</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00603">presentToPrevious()</a>.</p>

</div>
</div>
<a class="anchor" id="af87e4a2c1d17c4c5bc398082d6d3e365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LearnSynthQBFInd::do_reach_check_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables optimization RC. </p>
<p>Optimization RC (inductive reachability checks during the computation of counterexamples) is enabled if this flag is true, otherwise it is disabled. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00511">511</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00178">computeWinningRegion()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">recomputeCheckCNF()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00147">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a20b68cc735e4bbc0cc7030329acb4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;<a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>, <a class="el" href="classQBFSolver.html#ac091e263cb55286cc07b2451bcf4d3c7">QBFSolver::Quant</a>&gt; &gt; LearnSynthQBFInd::gen_quant_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The quantifier prefix of the QBF for generalizing counterexamples. </p>
<p>This quantifier prefix is always exists x*,i*,c*,x: forall i: exists c,x',tmp: </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00463">463</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="ad61b112cfcc60506f7b21c9ea9267b37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBFInd::generalize_clause_cnf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> matrix of the QBF for generalizing counterexamples. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is always (I | F* &amp; T*) &amp; F &amp; T &amp; F', where F is the <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00470">470</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">recomputeGenCNF()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c285416b6f27e86bdda92fd578327b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a>* LearnSynthQBFInd::impl_extractor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The engine to use for circuit extraction. </p>
<p>It will be deleted by this class (in the destructor). </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00518">518</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00147">run()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00137">~LearnSynthQBFInd()</a>.</p>

</div>
</div>
<a class="anchor" id="ad99eafb7ee9134115f9fbe986e5eb0c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBFInd::prev_trans_or_initial_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Says: the current state is initial or the previous transition relation holds. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> expresses that the current state is initial or the previous-state copy of the transition relation holds. This is an important building block for both <a class="el" href="classLearnSynthQBFInd.html#ac90a4574da82c96888db219291368554" title="The CNF matrix of the QBF for computing counterexamples.">check_cnf_</a> and <a class="el" href="classLearnSynthQBFInd.html#ad61b112cfcc60506f7b21c9ea9267b37" title="The CNF matrix of the QBF for generalizing counterexamples.">generalize_clause_cnf_</a>. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00494">494</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00633">debugCheckWinRegReach()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00040">LearnSynthQBFInd()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">recomputeGenCNF()</a>.</p>

</div>
</div>
<a class="anchor" id="ada2a2526b313b2ba4bb9d717fb63362d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQBFSolver.html">QBFSolver</a>* LearnSynthQBFInd::qbf_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The QBF-solver used for all queries. </p>
<p>The type of solver is selected with command-line arguments. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00433">433</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00335">computeCounterexampleQBF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00633">debugCheckWinRegReach()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00137">~LearnSynthQBFInd()</a>.</p>

</div>
</div>
<a class="anchor" id="af83f4253aeedaed56cb789369b054724"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLearnStatisticsQBF.html">LearnStatisticsQBF</a> LearnSynthQBFInd::statistics_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores and maintains statistics and performance measures. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00426">426</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00346">computeBlockingClause()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00335">computeCounterexampleQBF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00147">run()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8ce6031137413e90e0626bbdc734be0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBFInd::winning_region_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current over-approximation of the winning region. </p>
<p>Only when <a class="el" href="classLearnSynthQBFInd.html#a41593ccf692af8948f4b1255fb13ffe5" title="Computes the winning region and stores the result in winning_region_.">computeWinningRegion()</a> is done, this field will store the correct winning region. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00409">409</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00178">computeWinningRegion()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00633">debugCheckWinRegReach()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">recomputeGenCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00147">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a333c9336ba28a2c41f252a3051a59581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearnSynthQBFInd::winning_region_large_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current over-approximation of the winning region in an uncompressed form. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is logically equivalent to <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a>. However, <a class="el" href="classLearnSynthQBFInd.html#ab8ce6031137413e90e0626bbdc734be0" title="The current over-approximation of the winning region.">winning_region_</a> is 'compressed' from time to time by removing redundant clauses (clauses that are implied by other clauses in the winning region). This field stores the uncompressed version of the winning region. Having the uncompressed winning region can be good because throwing away redundant clauses is not always beneficial. The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> get smaller, but the solver may have to re-discover the removed clauses. </p>

<p>Definition at line <a class="el" href="LearnSynthQBFInd_8h_source.html#l00421">421</a> of file <a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00490">recomputeCheckCNF()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00522">recomputeGenCNF()</a>, and <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">reduceExistingClauses()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="LearnSynthQBFInd_8h_source.html">LearnSynthQBFInd.h</a></li>
<li>src/<a class="el" href="LearnSynthQBFInd_8cpp_source.html">LearnSynthQBFInd.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 15 2014 12:30:22 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
