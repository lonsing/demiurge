<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>demiurge: LearningImplExtractor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classLearningImplExtractor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LearningImplExtractor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements different learning-based methods for circuit extraction.  
 <a href="classLearningImplExtractor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LearningImplExtractor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLearningImplExtractor.png" usemap="#LearningImplExtractor_map" alt=""/>
  <map id="LearningImplExtractor_map" name="LearningImplExtractor_map">
<area href="classCNFImplExtractor.html" title="An interface for all classes that can construct circuits from a CNF winning region. " alt="CNFImplExtractor" shape="rect" coords="0,0,135,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a453451da144f6fef1f8769bc9522f3aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a453451da144f6fef1f8769bc9522f3aa">LearningImplExtractor</a> ()</td></tr>
<tr class="memdesc:a453451da144f6fef1f8769bc9522f3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a453451da144f6fef1f8769bc9522f3aa">More...</a><br/></td></tr>
<tr class="separator:a453451da144f6fef1f8769bc9522f3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c70a32f0f4268be784e8081681e65d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#ae5c70a32f0f4268be784e8081681e65d">~LearningImplExtractor</a> ()</td></tr>
<tr class="memdesc:ae5c70a32f0f4268be784e8081681e65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ae5c70a32f0f4268be784e8081681e65d">More...</a><br/></td></tr>
<tr class="separator:ae5c70a32f0f4268be784e8081681e65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13a1fc00465f95812df4673743e16eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#ad13a1fc00465f95812df4673743e16eb">run</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;winning_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_winning_region)</td></tr>
<tr class="memdesc:ad13a1fc00465f95812df4673743e16eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs this circuit extractor.  <a href="#ad13a1fc00465f95812df4673743e16eb">More...</a><br/></td></tr>
<tr class="separator:ad13a1fc00465f95812df4673743e16eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad329eedd50e443f44edc99db8c2e2613"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCNFImplExtractor.html#ad329eedd50e443f44edc99db8c2e2613">extractCircuit</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;winning_region)</td></tr>
<tr class="memdesc:ad329eedd50e443f44edc99db8c2e2613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a circuit from the winning region.  <a href="#ad329eedd50e443f44edc99db8c2e2613">More...</a><br/></td></tr>
<tr class="separator:ad329eedd50e443f44edc99db8c2e2613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9694425af3f1a76d8b21ace3c435d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCNFImplExtractor.html#a5e9694425af3f1a76d8b21ace3c435d9">extractCircuit</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;winning_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_winning_region)</td></tr>
<tr class="memdesc:a5e9694425af3f1a76d8b21ace3c435d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a circuit from the winning region and its negation.  <a href="#a5e9694425af3f1a76d8b21ace3c435d9">More...</a><br/></td></tr>
<tr class="separator:a5e9694425af3f1a76d8b21ace3c435d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae098749e201b22294a70f6e0a4a58f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCNFImplExtractor.html#aae098749e201b22294a70f6e0a4a58f0">logStatistics</a> ()</td></tr>
<tr class="memdesc:aae098749e201b22294a70f6e0a4a58f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs statistical information about circuit extraction.  <a href="#aae098749e201b22294a70f6e0a4a58f0">More...</a><br/></td></tr>
<tr class="separator:aae098749e201b22294a70f6e0a4a58f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad21828d816dfdbf672f6e595589ef6e7"><td class="memItemLeft" align="right" valign="top">static aiger *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCNFImplExtractor.html#ad21828d816dfdbf672f6e595589ef6e7">optimizeWithABC</a> (aiger *circuit)</td></tr>
<tr class="memdesc:ad21828d816dfdbf672f6e595589ef6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes a combinatorial AIGER circuit with ABC.  <a href="#ad21828d816dfdbf672f6e595589ef6e7">More...</a><br/></td></tr>
<tr class="separator:ad21828d816dfdbf672f6e595589ef6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a009b5382cc9a65cd7c7dfbbc73815bac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a009b5382cc9a65cd7c7dfbbc73815bac">runLearningQBF</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region)</td></tr>
<tr class="memdesc:a009b5382cc9a65cd7c7dfbbc73815bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements circuit extraction with non-incremental QBF-based <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning.  <a href="#a009b5382cc9a65cd7c7dfbbc73815bac">More...</a><br/></td></tr>
<tr class="separator:a009b5382cc9a65cd7c7dfbbc73815bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edc5671d6f56dea4145512385063681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a3edc5671d6f56dea4145512385063681">runLearningQBFInc</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region)</td></tr>
<tr class="memdesc:a3edc5671d6f56dea4145512385063681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements circuit extraction with incremental QBF-based <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning.  <a href="#a3edc5671d6f56dea4145512385063681">More...</a><br/></td></tr>
<tr class="separator:a3edc5671d6f56dea4145512385063681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61a9c39a6cb6e6e04eeb3ca876e50be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#aa61a9c39a6cb6e6e04eeb3ca876e50be">runLearningExp</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region)</td></tr>
<tr class="memdesc:aa61a9c39a6cb6e6e04eeb3ca876e50be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as runLearningQBFInc, but using universal expansion and a SAT solver.  <a href="#aa61a9c39a6cb6e6e04eeb3ca876e50be">More...</a><br/></td></tr>
<tr class="separator:aa61a9c39a6cb6e6e04eeb3ca876e50be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39668b94568dde5459d979684d99253f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a39668b94568dde5459d979684d99253f">runLearningJiangSAT</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region, bool second_run=false, bool min_cores=true)</td></tr>
<tr class="memdesc:a39668b94568dde5459d979684d99253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses SAT-based <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning with Jiang-resubstitution.  <a href="#a39668b94568dde5459d979684d99253f">More...</a><br/></td></tr>
<tr class="separator:a39668b94568dde5459d979684d99253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036ab2a3921696d31fb55139427d2114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a036ab2a3921696d31fb55139427d2114">runLearningJiangSATInc1</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region, bool second_run=false, bool min_cores=true)</td></tr>
<tr class="memdesc:a036ab2a3921696d31fb55139427d2114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classLearningImplExtractor.html#a39668b94568dde5459d979684d99253f" title="Uses SAT-based CNF learning with Jiang-resubstitution. ">runLearningJiangSAT</a> but with more aggressive incremental solving.  <a href="#a036ab2a3921696d31fb55139427d2114">More...</a><br/></td></tr>
<tr class="separator:a036ab2a3921696d31fb55139427d2114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee6e07a5c9907195c1af8cba613dbd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a2ee6e07a5c9907195c1af8cba613dbd1">runLearningJiangSATInc2</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region, bool second_run=false, bool min_cores=true)</td></tr>
<tr class="memdesc:a2ee6e07a5c9907195c1af8cba613dbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classLearningImplExtractor.html#a036ab2a3921696d31fb55139427d2114" title="Like runLearningJiangSAT but with more aggressive incremental solving. ">runLearningJiangSATInc1</a> but with even more aggressive incremental solving.  <a href="#a2ee6e07a5c9907195c1af8cba613dbd1">More...</a><br/></td></tr>
<tr class="separator:a2ee6e07a5c9907195c1af8cba613dbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad214c79ae2c0e56a47ad97ad2e5c3765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#ad214c79ae2c0e56a47ad97ad2e5c3765">runLearningJiangSATTmp</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region, bool second_run=false, bool min_cores=true)</td></tr>
<tr class="memdesc:ad214c79ae2c0e56a47ad97ad2e5c3765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses SAT-based <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning with Jiang-resubstitution and temporary variables.  <a href="#ad214c79ae2c0e56a47ad97ad2e5c3765">More...</a><br/></td></tr>
<tr class="separator:ad214c79ae2c0e56a47ad97ad2e5c3765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41484b6bb6da18e50d31830a18e63e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#ad41484b6bb6da18e50d31830a18e63e9">runLearningJiangSATTmpCtrl</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region, bool second_run=false, bool min_cores=true)</td></tr>
<tr class="memdesc:ad41484b6bb6da18e50d31830a18e63e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classLearningImplExtractor.html#ad214c79ae2c0e56a47ad97ad2e5c3765" title="Uses SAT-based CNF learning with Jiang-resubstitution and temporary variables. ">runLearningJiangSATTmp</a>, but also allows dependencies on control signals.  <a href="#ad41484b6bb6da18e50d31830a18e63e9">More...</a><br/></td></tr>
<tr class="separator:ad41484b6bb6da18e50d31830a18e63e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce27f574afbb4504b7acd82196314d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a5ce27f574afbb4504b7acd82196314d7">runLearningJiangSATTmpCtrlInc2</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;win_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_win_region, bool second_run=false, bool min_cores=true)</td></tr>
<tr class="memdesc:a5ce27f574afbb4504b7acd82196314d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines <a class="el" href="classLearningImplExtractor.html#ad41484b6bb6da18e50d31830a18e63e9" title="Like runLearningJiangSATTmp, but also allows dependencies on control signals. ">runLearningJiangSATTmpCtrl</a> and runLearningJiangSATInc2.  <a href="#a5ce27f574afbb4504b7acd82196314d7">More...</a><br/></td></tr>
<tr class="separator:a5ce27f574afbb4504b7acd82196314d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af747a4869a3ca8a8e77e39c435b94ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#af747a4869a3ca8a8e77e39c435b94ce8">makeEq</a> (int var, <a class="el" href="classCNF.html">CNF</a> impl)</td></tr>
<tr class="memdesc:af747a4869a3ca8a8e77e39c435b94ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> that assigns a variable to the result of some other <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>.  <a href="#af747a4869a3ca8a8e77e39c435b94ce8">More...</a><br/></td></tr>
<tr class="separator:af747a4869a3ca8a8e77e39c435b94ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae491299fffa2b1dcb6ccce010b0fc5f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#ae491299fffa2b1dcb6ccce010b0fc5f7">makeEq2</a> (int var, <a class="el" href="classCNF.html">CNF</a> impl)</td></tr>
<tr class="memdesc:ae491299fffa2b1dcb6ccce010b0fc5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative implementation of <a class="el" href="classLearningImplExtractor.html#af747a4869a3ca8a8e77e39c435b94ce8" title="Creates a CNF that assigns a variable to the result of some other CNF. ">makeEq</a>, which seems to be slower.  <a href="#ae491299fffa2b1dcb6ccce010b0fc5f7">More...</a><br/></td></tr>
<tr class="separator:ae491299fffa2b1dcb6ccce010b0fc5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70515dea9636bbcd9fe3e31bdf47e110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a70515dea9636bbcd9fe3e31bdf47e110">addToStandAloneAiger</a> (int ctrl_var, const <a class="el" href="classCNF.html">CNF</a> &amp;solution)</td></tr>
<tr class="memdesc:a70515dea9636bbcd9fe3e31bdf47e110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the solution for one output function to the AIGER circuit we have so far.  <a href="#a70515dea9636bbcd9fe3e31bdf47e110">More...</a><br/></td></tr>
<tr class="separator:a70515dea9636bbcd9fe3e31bdf47e110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88143aa67de5be8848f643cfb2947834"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a88143aa67de5be8848f643cfb2947834">cnfToAig</a> (int cnf_lit)</td></tr>
<tr class="memdesc:a88143aa67de5be8848f643cfb2947834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> literal into an AIGER literal as used in <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>.  <a href="#a88143aa67de5be8848f643cfb2947834">More...</a><br/></td></tr>
<tr class="separator:a88143aa67de5be8848f643cfb2947834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9d325813c0f792321a932f358cfe78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a8f9d325813c0f792321a932f358cfe78">makeAnd</a> (int in1, int in2)</td></tr>
<tr class="memdesc:a8f9d325813c0f792321a932f358cfe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the AND between two AIGER literals and returns the resulting literal.  <a href="#a8f9d325813c0f792321a932f358cfe78">More...</a><br/></td></tr>
<tr class="separator:a8f9d325813c0f792321a932f358cfe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25260410178b107783cbc10fdf69c52d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a25260410178b107783cbc10fdf69c52d">makeOr</a> (int in1, int in2)</td></tr>
<tr class="memdesc:a25260410178b107783cbc10fdf69c52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the OR between two AIGER literals and returns the resulting literal.  <a href="#a25260410178b107783cbc10fdf69c52d">More...</a><br/></td></tr>
<tr class="separator:a25260410178b107783cbc10fdf69c52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b95b5433b25e475efaaba9c553c4e63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a8b95b5433b25e475efaaba9c553c4e63">insertMissingAndFromTrans</a> ()</td></tr>
<tr class="memdesc:a8b95b5433b25e475efaaba9c553c4e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies missing AND gates from the spec.  <a href="#a8b95b5433b25e475efaaba9c553c4e63">More...</a><br/></td></tr>
<tr class="separator:a8b95b5433b25e475efaaba9c553c4e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14318d81871fc52f0d17fd5d82708e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#aa14318d81871fc52f0d17fd5d82708e3">logDetailedStatistics</a> ()</td></tr>
<tr class="memdesc:aa14318d81871fc52f0d17fd5d82708e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs the detailed statistics collected in the <a class="el" href="classLearningExtractorStatistics.html" title="A class to collect performance measures for the LearningImplExtractor. ">LearningExtractorStatistics</a>.  <a href="#aa14318d81871fc52f0d17fd5d82708e3">More...</a><br/></td></tr>
<tr class="separator:aa14318d81871fc52f0d17fd5d82708e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0970602635f3356712d57ebb28d12c0d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCNFImplExtractor.html#a0970602635f3356712d57ebb28d12c0d">insertIntoSpec</a> (aiger *standalone_circuit) const </td></tr>
<tr class="memdesc:a0970602635f3356712d57ebb28d12c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a circuit defining the control signals and inserts it into the spec.  <a href="#a0970602635f3356712d57ebb28d12c0d">More...</a><br/></td></tr>
<tr class="separator:a0970602635f3356712d57ebb28d12c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4147358129fcfb9e72a0ee27d7c16f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQBFSolver.html">QBFSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a4147358129fcfb9e72a0ee27d7c16f51">qbf_solver_</a></td></tr>
<tr class="memdesc:a4147358129fcfb9e72a0ee27d7c16f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The QBF solver to use (as selected by the user with command-line arguments).  <a href="#a4147358129fcfb9e72a0ee27d7c16f51">More...</a><br/></td></tr>
<tr class="separator:a4147358129fcfb9e72a0ee27d7c16f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987219dd3114957f2bd0d9df77a9d7fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a987219dd3114957f2bd0d9df77a9d7fc">next_free_aig_lit_</a></td></tr>
<tr class="memdesc:a987219dd3114957f2bd0d9df77a9d7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next unused AIGER literal in <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>.  <a href="#a987219dd3114957f2bd0d9df77a9d7fc">More...</a><br/></td></tr>
<tr class="separator:a987219dd3114957f2bd0d9df77a9d7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f7c47bf3e84fa5a70930e01a18deb2"><td class="memItemLeft" align="right" valign="top">aiger *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2">standalone_circuit_</a></td></tr>
<tr class="memdesc:a17f7c47bf3e84fa5a70930e01a18deb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The synthesis result as stand-alone circuit.  <a href="#a17f7c47bf3e84fa5a70930e01a18deb2">More...</a><br/></td></tr>
<tr class="separator:a17f7c47bf3e84fa5a70930e01a18deb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d096ab7181fd608d6ee033f8c9ab8d3"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a2d096ab7181fd608d6ee033f8c9ab8d3">cnf_var_to_standalone_aig_var_</a></td></tr>
<tr class="memdesc:a2d096ab7181fd608d6ee033f8c9ab8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from variables as they occur in CNFs to the corresponding AIGER literals.  <a href="#a2d096ab7181fd608d6ee033f8c9ab8d3">More...</a><br/></td></tr>
<tr class="separator:a2d096ab7181fd608d6ee033f8c9ab8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4835eb5fc2df396272af43380ecc82"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a5a4835eb5fc2df396272af43380ecc82">ip_</a></td></tr>
<tr class="memdesc:a5a4835eb5fc2df396272af43380ecc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of uncontrollable input variables followed by the present state variables.  <a href="#a5a4835eb5fc2df396272af43380ecc82">More...</a><br/></td></tr>
<tr class="separator:a5a4835eb5fc2df396272af43380ecc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94459731d569bdd6bb0f3895fb9c184"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#ab94459731d569bdd6bb0f3895fb9c184">ipc_</a></td></tr>
<tr class="memdesc:ab94459731d569bdd6bb0f3895fb9c184"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of uncontrollable inputs, state variables, and control signals.  <a href="#ab94459731d569bdd6bb0f3895fb9c184">More...</a><br/></td></tr>
<tr class="separator:ab94459731d569bdd6bb0f3895fb9c184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018564c4a67dfb228357008a8a50aef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLearningExtractorStatistics.html">LearningExtractorStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a018564c4a67dfb228357008a8a50aef4">statistics</a></td></tr>
<tr class="memdesc:a018564c4a67dfb228357008a8a50aef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for collecting performance data and statistics.  <a href="#a018564c4a67dfb228357008a8a50aef4">More...</a><br/></td></tr>
<tr class="separator:a018564c4a67dfb228357008a8a50aef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8be06d42fd3c4b569ec22cfcf2f508e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCNFImplExtractor.html#ab8be06d42fd3c4b569ec22cfcf2f508e">extraction_cpu_time_</a></td></tr>
<tr class="memdesc:ab8be06d42fd3c4b569ec22cfcf2f508e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The circuit extraction time in CPU-seconds.  <a href="#ab8be06d42fd3c4b569ec22cfcf2f508e">More...</a><br/></td></tr>
<tr class="separator:ab8be06d42fd3c4b569ec22cfcf2f508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06413cf08f868357d64545b3041aa18"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCNFImplExtractor.html#ae06413cf08f868357d64545b3041aa18">extraction_real_time_</a></td></tr>
<tr class="memdesc:ae06413cf08f868357d64545b3041aa18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classCNFImplExtractor.html#ab8be06d42fd3c4b569ec22cfcf2f508e" title="The circuit extraction time in CPU-seconds. ">extraction_cpu_time_</a> but real-time.  <a href="#ae06413cf08f868357d64545b3041aa18">More...</a><br/></td></tr>
<tr class="separator:ae06413cf08f868357d64545b3041aa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a12fcc34f855b823c407235b64673c4c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#a12fcc34f855b823c407235b64673c4c2">LearningImplExtractor</a> (const <a class="el" href="classLearningImplExtractor.html">LearningImplExtractor</a> &amp;other)</td></tr>
<tr class="memdesc:a12fcc34f855b823c407235b64673c4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a12fcc34f855b823c407235b64673c4c2">More...</a><br/></td></tr>
<tr class="separator:a12fcc34f855b823c407235b64673c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa15ed8fb085576deb3d15a55fe32e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLearningImplExtractor.html">LearningImplExtractor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLearningImplExtractor.html#adfa15ed8fb085576deb3d15a55fe32e0">operator=</a> (const <a class="el" href="classLearningImplExtractor.html">LearningImplExtractor</a> &amp;other)</td></tr>
<tr class="memdesc:adfa15ed8fb085576deb3d15a55fe32e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#adfa15ed8fb085576deb3d15a55fe32e0">More...</a><br/></td></tr>
<tr class="separator:adfa15ed8fb085576deb3d15a55fe32e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements different learning-based methods for circuit extraction. </p>
<p>This class implements different learning-based methods for circuit extraction. All methods are based on the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning algorithm from the paper Ruediger Ehlers, Robert Koenighofer, Georg Hofferek: Symbolically synthesizing small circuits. FMCAD 2012: 91.2.0 Some methods use QBF-solving, some incremental QBF solving, and some incremental SAT solving with various optimizations. The method that should be used is defined by the command-line option &ndash;circuit-mode or -n.</p>
<p>The general flow is as follows. </p>
<ol>
<li>
We compute a combinational (no latches) stand-alone circuit that computes the control signals based on the uncontrollable inputs and state variables in AIGER format. </li>
<li>
We optimize this stand-alone circuit using ABC. </li>
<li>
The optimized circuit is inserted into the original specification as requited by the rules of the SYNTComp competition. </li>
</ol>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.2.0 </dd></dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8h_source.html#l00064">64</a> of file <a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a453451da144f6fef1f8769bc9522f3aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LearningImplExtractor::LearningImplExtractor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">48</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="LearningImplExtractor_8h_source.html#l00408">cnf_var_to_standalone_aig_var_</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="VarManager_8cpp_source.html#l00267">VarManager::getInfo()</a>, <a class="el" href="VarInfo_8cpp_source.html#l00099">VarInfo::getLitInAIG()</a>, <a class="el" href="VarInfo_8cpp_source.html#l00105">VarInfo::getName()</a>, <a class="el" href="VarManager_8cpp_source.html#l00320">VarManager::getPresErrorStateVar()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">AIG2CNF::getTmpDepsTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00417">ip_</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00426">ipc_</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00316">AIG2CNF::isTrueInTrans()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00381">next_free_aig_lit_</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, and <a class="el" href="LearningImplExtractor_8h_source.html#l00396">standalone_circuit_</a>.</p>

</div>
</div>
<a class="anchor" id="ae5c70a32f0f4268be784e8081681e65d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LearningImplExtractor::~LearningImplExtractor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00121">121</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="LearningImplExtractor_8h_source.html#l00376">qbf_solver_</a>, and <a class="el" href="LearningImplExtractor_8h_source.html#l00396">standalone_circuit_</a>.</p>

</div>
</div>
<a class="anchor" id="a12fcc34f855b823c407235b64673c4c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LearningImplExtractor::LearningImplExtractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLearningImplExtractor.html">LearningImplExtractor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a70515dea9636bbcd9fe3e31bdf47e110"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::addToStandAloneAiger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ctrl_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the solution for one output function to the AIGER circuit we have so far. </p>
<p>The AIGER circuit we have so far is built up in <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. This method adds an output function (in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>) for one control signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrl_var</td><td>The control signal for which we would like to add an output function. </td></tr>
    <tr><td class="paramname">solution</td><td>The output function (in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>) defining the control signal. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">1742</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="LearningImplExtractor_8cpp_source.html#l01778">cnfToAig()</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01788">makeAnd()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01797">makeOr()</a>, and <a class="el" href="LearningImplExtractor_8h_source.html#l00396">standalone_circuit_</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">runLearningExp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">runLearningQBF()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00284">runLearningQBFInc()</a>.</p>

</div>
</div>
<a class="anchor" id="a88143aa67de5be8848f643cfb2947834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LearningImplExtractor::cnfToAig </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnf_lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> literal into an AIGER literal as used in <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf_lit</td><td>The literal as it occurs in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> formulas. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding AIGER index of the literal as it is used in the <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. </dd></dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01778">1778</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="LearningImplExtractor_8h_source.html#l00408">cnf_var_to_standalone_aig_var_</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">insertMissingAndFromTrans()</a>.</p>

</div>
</div>
<a class="anchor" id="ad329eedd50e443f44edc99db8c2e2613"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CNFImplExtractor::extractCircuit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>winning_region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a circuit from the winning region. </p>
<p>How this is done (interpolation, learning, etc.) depends on the concrete implementation of this abstract class. The result is written into the output file specified by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">winning_region</td><td>The winning region from which the circuit should be extracted. For circuit extraction we need both the winning region and its negation. The negation is computed inside this function. If you already have a negation, use the other circuit extraction method of this class. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classStoreImplExtractor.html#a08437db801013d0b3208bbf099239fac">StoreImplExtractor</a>.</p>

<p>Definition at line <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">85</a> of file <a class="el" href="CNFImplExtractor_8cpp_source.html">CNFImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="Utils_8cpp_source.html#l00305">Utils::compressStateCNF()</a>, <a class="el" href="CNFImplExtractor_8h_source.html#l00145">CNFImplExtractor::extraction_cpu_time_</a>, <a class="el" href="CNFImplExtractor_8h_source.html#l00150">CNFImplExtractor::extraction_real_time_</a>, <a class="el" href="Stopwatch_8cpp_source.html#l00041">Stopwatch::getCPUTimeSec()</a>, <a class="el" href="Stopwatch_8cpp_source.html#l00055">Stopwatch::getRealTimeSec()</a>, <a class="el" href="CNF_8cpp_source.html#l00272">CNF::negate()</a>, <a class="el" href="classCNFImplExtractor.html#a8251ce58869f9f8ded159f1fa07ab334">CNFImplExtractor::run()</a>, and <a class="el" href="Stopwatch_8cpp_source.html#l00033">Stopwatch::start()</a>.</p>

<p>Referenced by <a class="el" href="LoadSynth_8cpp_source.html#l00051">LoadSynth::run()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00073">LearnSynthQBFInc::run()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00067">TemplateSynth::run()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00121">IFM13Synth::run()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00092">LearnSynthQBF::run()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00135">LearnSynthSAT::run()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00147">LearnSynthQBFInd::run()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00391">ParallelLearner::run()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9694425af3f1a76d8b21ace3c435d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CNFImplExtractor::extractCircuit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>winning_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_winning_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a circuit from the winning region and its negation. </p>
<p>How this is done (interpolation, learning, etc.) depends on the concrete implementation of this abstract class. The result is written into the output file specified by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">winning_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_winning_region</td><td>The negation of the winning region. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="CNFImplExtractor_8cpp_source.html#l00102">102</a> of file <a class="el" href="CNFImplExtractor_8cpp_source.html">CNFImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNFImplExtractor_8h_source.html#l00145">CNFImplExtractor::extraction_cpu_time_</a>, <a class="el" href="CNFImplExtractor_8h_source.html#l00150">CNFImplExtractor::extraction_real_time_</a>, <a class="el" href="Stopwatch_8cpp_source.html#l00041">Stopwatch::getCPUTimeSec()</a>, <a class="el" href="Stopwatch_8cpp_source.html#l00055">Stopwatch::getRealTimeSec()</a>, <a class="el" href="classCNFImplExtractor.html#a8251ce58869f9f8ded159f1fa07ab334">CNFImplExtractor::run()</a>, and <a class="el" href="Stopwatch_8cpp_source.html#l00033">Stopwatch::start()</a>.</p>

</div>
</div>
<a class="anchor" id="a0970602635f3356712d57ebb28d12c0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t CNFImplExtractor::insertIntoSpec </td>
          <td>(</td>
          <td class="paramtype">aiger *&#160;</td>
          <td class="paramname"><em>standalone_circuit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a circuit defining the control signals and inserts it into the spec. </p>
<p>This method takes as argument an aiger circuit of the following form: </p>
<ul>
<li>
The circuit is combinational, i.e., has no latches. </li>
<li>
The inputs of the circuit are: the uncontrollable inputs from the spec (in the order in which they appear in the spec) followed by the state-signals (the output of the latches in the spec, in the order in which they appear in the spec). </li>
<li>
The outputs of the circuit are the controllable inputs in the order in which they are defined in the spec. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">standalone_circuit</td><td>A circuit defining the control signals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of additional AND gates introduced into the spec. </dd></dl>

<p>Definition at line <a class="el" href="CNFImplExtractor_8cpp_source.html#l00149">149</a> of file <a class="el" href="CNFImplExtractor_8cpp_source.html">CNFImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="Options_8cpp_source.html#l00344">Options::getAigInFileName()</a>, <a class="el" href="Options_8cpp_source.html#l00363">Options::getAigOutFileName()</a>, <a class="el" href="VarManager_8cpp_source.html#l00267">VarManager::getInfo()</a>, <a class="el" href="VarInfo_8cpp_source.html#l00099">VarInfo::getLitInAIG()</a>, <a class="el" href="VarManager_8cpp_source.html#l00338">VarManager::getMaxAIGVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00320">VarManager::getPresErrorStateVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, and <a class="el" href="StringUtils_8cpp_source.html#l00064">StringUtils::toLowerCaseIn()</a>.</p>

<p>Referenced by <a class="el" href="ParExtractor_8cpp_source.html#l00084">ParExtractor::run()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>, and <a class="el" href="QBFCertImplExtractor_8cpp_source.html#l00063">QBFCertImplExtractor::run()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b95b5433b25e475efaaba9c553c4e63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::insertMissingAndFromTrans </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies missing AND gates from the spec. </p>
<p>This method is only used for an optimization in the methods <a class="el" href="classLearningImplExtractor.html#ad214c79ae2c0e56a47ad97ad2e5c3765" title="Uses SAT-based CNF learning with Jiang-resubstitution and temporary variables. ">runLearningJiangSATTmp</a>, <a class="el" href="classLearningImplExtractor.html#ad41484b6bb6da18e50d31830a18e63e9" title="Like runLearningJiangSATTmp, but also allows dependencies on control signals. ">runLearningJiangSATTmpCtrl</a>, and <a class="el" href="classLearningImplExtractor.html#a5ce27f574afbb4504b7acd82196314d7" title="Combines runLearningJiangSATTmpCtrl and runLearningJiangSATInc2. ">runLearningJiangSATTmpCtrlInc2</a>. These methods allow solutions to depend on temporary variables that appear in the original specification. The rules for SYNTComp do not allow to refer to such temporary variables from the specification in the final solution. Hence, this method simply copies the AND gates from the specification into the <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">1806</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="VarManager_8cpp_source.html#l00274">VarManager::aigLitToCnfLit()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00408">cnf_var_to_standalone_aig_var_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01778">cnfToAig()</a>, <a class="el" href="Options_8cpp_source.html#l00344">Options::getAigInFileName()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00271">AIG2CNF::getTmpDeps()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00396">standalone_circuit_</a>, and <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">runLearningJiangSATTmpCtrl()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">runLearningJiangSATTmpCtrlInc2()</a>.</p>

</div>
</div>
<a class="anchor" id="aa14318d81871fc52f0d17fd5d82708e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::logDetailedStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs the detailed statistics collected in the <a class="el" href="classLearningExtractorStatistics.html" title="A class to collect performance measures for the LearningImplExtractor. ">LearningExtractorStatistics</a>. </p>

<p>Reimplemented from <a class="el" href="classCNFImplExtractor.html#abe790c767f6c71a52ef8b0a61ab39eaa">CNFImplExtractor</a>.</p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01865">1865</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00131">LearningExtractorStatistics::logStatistics()</a>, and <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>.</p>

</div>
</div>
<a class="anchor" id="aae098749e201b22294a70f6e0a4a58f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CNFImplExtractor::logStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs statistical information about circuit extraction. </p>
<p>This method logs the overall execution time plus whatever detailed information is collected by the concrete implementation of this class. </p>

<p>Definition at line <a class="el" href="CNFImplExtractor_8cpp_source.html#l00290">290</a> of file <a class="el" href="CNFImplExtractor_8cpp_source.html">CNFImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNFImplExtractor_8h_source.html#l00145">CNFImplExtractor::extraction_cpu_time_</a>, <a class="el" href="CNFImplExtractor_8h_source.html#l00150">CNFImplExtractor::extraction_real_time_</a>, <a class="el" href="Logger_8h_source.html#l00336">L_LOG</a>, and <a class="el" href="CNFImplExtractor_8cpp_source.html#l00298">CNFImplExtractor::logDetailedStatistics()</a>.</p>

<p>Referenced by <a class="el" href="LoadSynth_8cpp_source.html#l00051">LoadSynth::run()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00073">LearnSynthQBFInc::run()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00067">TemplateSynth::run()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00121">IFM13Synth::run()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00092">LearnSynthQBF::run()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00135">LearnSynthSAT::run()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00147">LearnSynthQBFInd::run()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00391">ParallelLearner::run()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f9d325813c0f792321a932f358cfe78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LearningImplExtractor::makeAnd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the AND between two AIGER literals and returns the resulting literal. </p>
<p>This method extends the <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a> with logic to compute the AND between two AIGER literals. The literal that represents the result of the AND is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in1</td><td>The first operand of the AND: an AIGER literal from <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. </td></tr>
    <tr><td class="paramname">in2</td><td>The second operand of the AND: an AIGER literal from <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The literal that represents the result of the AND. </dd></dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01788">1788</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="LearningImplExtractor_8h_source.html#l00381">next_free_aig_lit_</a>, and <a class="el" href="LearningImplExtractor_8h_source.html#l00396">standalone_circuit_</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>.</p>

</div>
</div>
<a class="anchor" id="af747a4869a3ca8a8e77e39c435b94ce8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearningImplExtractor::makeEq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a>&#160;</td>
          <td class="paramname"><em>impl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> that assigns a variable to the result of some other <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. </p>
<p>This method creates a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> that for (var &lt;-&gt; impl), where var is a variable and impl is a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. It is used to say that a certain control signal is now defined by a function that has been computed in <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The variable to set equal to the result of the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> impl. </td></tr>
    <tr><td class="paramname">impl</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> that should define the value of var. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representation of (var &lt;-&gt; impl). </dd></dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">1654</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00272">CNF::negate()</a>, and <a class="el" href="CNF_8cpp_source.html#l00294">CNF::swapWith()</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">runLearningExp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">runLearningQBF()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00284">runLearningQBFInc()</a>.</p>

</div>
</div>
<a class="anchor" id="ae491299fffa2b1dcb6ccce010b0fc5f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> LearningImplExtractor::makeEq2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a>&#160;</td>
          <td class="paramname"><em>impl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alternative implementation of <a class="el" href="classLearningImplExtractor.html#af747a4869a3ca8a8e77e39c435b94ce8" title="Creates a CNF that assigns a variable to the result of some other CNF. ">makeEq</a>, which seems to be slower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The variable to set equal to the result of the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> impl. </td></tr>
    <tr><td class="paramname">impl</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> that should define the value of var. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representation of (var &lt;-&gt; impl). </dd></dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01691">1691</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00186">CNF::add3LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, and <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>.</p>

</div>
</div>
<a class="anchor" id="a25260410178b107783cbc10fdf69c52d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LearningImplExtractor::makeOr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the OR between two AIGER literals and returns the resulting literal. </p>
<p>This method extends the <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a> with logic to compute the OR between two AIGER literals. The literal that represents the result of the OR is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in1</td><td>The first operand of the OR: an AIGER literal from <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. </td></tr>
    <tr><td class="paramname">in2</td><td>The second operand of the OR: an AIGER literal from <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The literal that represents the result of the OR. </dd></dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01797">1797</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="LearningImplExtractor_8h_source.html#l00381">next_free_aig_lit_</a>, and <a class="el" href="LearningImplExtractor_8h_source.html#l00396">standalone_circuit_</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>.</p>

</div>
</div>
<a class="anchor" id="adfa15ed8fb085576deb3d15a55fe32e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLearningImplExtractor.html">LearningImplExtractor</a>&amp; LearningImplExtractor::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLearningImplExtractor.html">LearningImplExtractor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="ad21828d816dfdbf672f6e595589ef6e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">aiger * CNFImplExtractor::optimizeWithABC </td>
          <td>(</td>
          <td class="paramtype">aiger *&#160;</td>
          <td class="paramname"><em>circuit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimizes a combinatorial AIGER circuit with ABC. </p>
<dl class="section note"><dt>Note</dt><dd>The returned structure must be deleted by the caller. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to optimize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimized version of the circuit. The returned aiger structure must be deleted by the caller. </dd></dl>

<p>Definition at line <a class="el" href="CNFImplExtractor_8cpp_source.html#l00112">112</a> of file <a class="el" href="CNFImplExtractor_8cpp_source.html">CNFImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="Options_8cpp_source.html#l00481">Options::getTPDirName()</a>, <a class="el" href="Options_8cpp_source.html#l00471">Options::getUniqueTmpFileName()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, and <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>, <a class="el" href="QBFCertImplExtractor_8cpp_source.html#l00063">QBFCertImplExtractor::run()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l01128">ParExtractorQBFWorker::runQBF()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00294">ParExtractorWorker::runSAT()</a>, and <a class="el" href="ParExtractor_8cpp_source.html#l00553">ParExtractorWorker::runSATDep()</a>.</p>

</div>
</div>
<a class="anchor" id="ad13a1fc00465f95812df4673743e16eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>winning_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_winning_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs this circuit extractor. </p>
<p>Depending on the selected method (using the command &ndash;circuit-mode or -n), one of the methods runLearningX is called with appropriate parameters. Finally, ABC is used to optimize the resulting circuit, and the implementation is inserted into the specification (as required by the SYNTComp rules).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">winning_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_winning_region</td><td>The negation of the winning region. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classCNFImplExtractor.html#a8251ce58869f9f8ded159f1fa07ab334">CNFImplExtractor</a>.</p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">130</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNFImplExtractor_8cpp_source.html#l00149">CNFImplExtractor::insertIntoSpec()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00117">LearningExtractorStatistics::notifyAfterABC()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00110">LearningExtractorStatistics::notifyBeforeABC()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00125">LearningExtractorStatistics::notifyFinalSize()</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00112">CNFImplExtractor::optimizeWithABC()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">runLearningExp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">runLearningQBF()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00284">runLearningQBFInc()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00396">standalone_circuit_</a>, and <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>.</p>

</div>
</div>
<a class="anchor" id="aa61a9c39a6cb6e6e04eeb3ca876e50be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningExp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as runLearningQBFInc, but using universal expansion and a SAT solver. </p>
<p>Although using SAT solvers instead of QBF appears to pay off when computing the winning region, this does not seem to hold true here: this method is relatively slow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">367</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="Utils_8cpp_source.html#l00502">Utils::compressNextStateCNF()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="UnivExpander_8cpp_source.html#l00954">UnivExpander::extrExp()</a>, <a class="el" href="Options_8cpp_source.html#l00523">Options::getSATSolverExtr()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00417">ip_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, and <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a39668b94568dde5459d979684d99253f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningJiangSAT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>second_run</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_cores</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses SAT-based <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning with Jiang-resubstitution. </p>
<p>This method also implements the same <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning algorithm as <a class="el" href="classLearningImplExtractor.html#a009b5382cc9a65cd7c7dfbbc73815bac" title="Implements circuit extraction with non-incremental QBF-based CNF learning. ">runLearningQBF</a>. The difference is that this method uses a SAT solver instead of a QBF solver. In order to avoid solving a quantifier alternation, the method handles output signals just like inputs (temporarily) as explained in the paper: Jie-Hong Roland Jiang, Hsuan-Po Lin, Wei-Lun Hung: Interpolating functions from large Boolean relations. ICCAD 2009: 779-784. Once a working solution has been computed, this method can also run a second minimization round, where it tries to simplify the solution further. This second optimization round can be enabled or disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
    <tr><td class="paramname">second_run</td><td>A flag to control whether a second optimization round should be performed after a working solution is already available. This costs time, but can lead to smaller circuits. If the parameter is omitted, then this step will NOT be performed. Personal feeling: it usually does not pay off. </td></tr>
    <tr><td class="paramname">min_cores</td><td>A flag that controls whether the SAT solver should compute minimal unsatisfiable cores, or just regular ones. Especially if the second_run flag is true, it may make sense to set this flag to false to be faster in the first round. However, often having min_cores=false makes things slower (and leads to larger circuits). That's why true is the default value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">436</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="SatSolver_8cpp_source.html#l00047">SatSolver::doMinCores()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="Options_8cpp_source.html#l00523">Options::getSATSolverExtr()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#a5b39c45cd2a1abfe96c681515dfddb77">SatSolver::incAddUnitClause()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00426">ipc_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00528">CNF::renameVars()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>, and <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a036ab2a3921696d31fb55139427d2114"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningJiangSATInc1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>second_run</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_cores</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classLearningImplExtractor.html#a39668b94568dde5459d979684d99253f" title="Uses SAT-based CNF learning with Jiang-resubstitution. ">runLearningJiangSAT</a> but with more aggressive incremental solving. </p>
<p>The method <a class="el" href="classLearningImplExtractor.html#a39668b94568dde5459d979684d99253f" title="Uses SAT-based CNF learning with Jiang-resubstitution. ">runLearningJiangSAT</a> uses incremental solving, but only it has two different solver instances per control signal: one for computing problematic situations, and one for generalizing them using an unsatisfiable core computation. This method uses incremental soling in a more aggressive way. It uses only two solver instances, one for computing problematic situations across all control signals, and one for generalizing them across all iterations. This is achieved by introducing activation variables that activate or deactivate different parts of the formula, depending on the control signal we are currently synthesizing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
    <tr><td class="paramname">second_run</td><td>A flag to control whether a second optimization round should be performed after a working solution is already available. This costs time, but can lead to smaller circuits. If the parameter is omitted, then this step will NOT be performed. Personal feeling: it usually does not pay off. </td></tr>
    <tr><td class="paramname">min_cores</td><td>A flag that controls whether the SAT solver should compute minimal unsatisfiable cores, or just regular ones. Especially if the second_run flag is true, it may make sense to set this flag to false to be faster in the first round. However, often having min_cores=false makes things slower (and leads to larger circuits). That's why true is the default value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">1249</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00186">CNF::add3LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="SatSolver_8cpp_source.html#l00047">SatSolver::doMinCores()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="Options_8cpp_source.html#l00523">Options::getSATSolverExtr()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00417">ip_</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00426">ipc_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00528">CNF::renameVars()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>, and <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ee6e07a5c9907195c1af8cba613dbd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningJiangSATInc2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>second_run</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_cores</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classLearningImplExtractor.html#a036ab2a3921696d31fb55139427d2114" title="Like runLearningJiangSAT but with more aggressive incremental solving. ">runLearningJiangSATInc1</a> but with even more aggressive incremental solving. </p>
<p>While the method <a class="el" href="classLearningImplExtractor.html#a036ab2a3921696d31fb55139427d2114" title="Like runLearningJiangSAT but with more aggressive incremental solving. ">runLearningJiangSATInc1</a> uses two solver instances to compute all control signals, this method uses only one instance. This is achieved by introducing even more activation variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
    <tr><td class="paramname">second_run</td><td>A flag to control whether a second optimization round should be performed after a working solution is already available. This costs time, but can lead to smaller circuits. If the parameter is omitted, then this step will NOT be performed. Personal feeling: it usually does not pay off. </td></tr>
    <tr><td class="paramname">min_cores</td><td>A flag that controls whether the SAT solver should compute minimal unsatisfiable cores, or just regular ones. Especially if the second_run flag is true, it may make sense to set this flag to false to be faster in the first round. However, often having min_cores=false makes things slower (and leads to larger circuits). That's why true is the default value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">1456</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00186">CNF::add3LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="SatSolver_8cpp_source.html#l00047">SatSolver::doMinCores()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="Options_8cpp_source.html#l00523">Options::getSATSolverExtr()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00417">ip_</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00426">ipc_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00528">CNF::renameVars()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>, and <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<a class="anchor" id="ad214c79ae2c0e56a47ad97ad2e5c3765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningJiangSATTmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>second_run</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_cores</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses SAT-based <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning with Jiang-resubstitution and temporary variables. </p>
<p>This method is very similar to <a class="el" href="classLearningImplExtractor.html#a39668b94568dde5459d979684d99253f" title="Uses SAT-based CNF learning with Jiang-resubstitution. ">runLearningJiangSAT</a>. The only difference is that this method also allows control signals to depend on temporary variables from the original input file (the specification), as long as these temporary variables do not depend on the respective control signal. Since the rules for SYNTComp do not allow such dependencies in the final output, they are removed again simply by copying the respective parts of the original input file before producing the output file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
    <tr><td class="paramname">second_run</td><td>A flag to control whether a second optimization round should be performed after a working solution is already available. This costs time, but can lead to smaller circuits. If the parameter is omitted, then this step will NOT be performed. Personal feeling: it usually does not pay off. </td></tr>
    <tr><td class="paramname">min_cores</td><td>A flag that controls whether the SAT solver should compute minimal unsatisfiable cores, or just regular ones. Especially if the second_run flag is true, it may make sense to set this flag to false to be faster in the first round. However, often having min_cores=false makes things slower (and leads to larger circuits). That's why true is the default value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">604</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="Utils_8cpp_source.html#l00195">Utils::contains()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="SatSolver_8cpp_source.html#l00047">SatSolver::doMinCores()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="Options_8cpp_source.html#l00523">Options::getSATSolverExtr()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">AIG2CNF::getTmpDepsTrans()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#a5b39c45cd2a1abfe96c681515dfddb77">SatSolver::incAddUnitClause()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">insertMissingAndFromTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00426">ipc_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="Utils_8cpp_source.html#l00168">Utils::randomize()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00528">CNF::renameVars()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>, and <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<a class="anchor" id="ad41484b6bb6da18e50d31830a18e63e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningJiangSATTmpCtrl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>second_run</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_cores</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classLearningImplExtractor.html#ad214c79ae2c0e56a47ad97ad2e5c3765" title="Uses SAT-based CNF learning with Jiang-resubstitution and temporary variables. ">runLearningJiangSATTmp</a>, but also allows dependencies on control signals. </p>
<p>This method is very similar to <a class="el" href="classLearningImplExtractor.html#ad214c79ae2c0e56a47ad97ad2e5c3765" title="Uses SAT-based CNF learning with Jiang-resubstitution and temporary variables. ">runLearningJiangSATTmp</a>. The only difference is that this method also even more dependencies between control signals. If a certain already computed control signal A does not depend on a yet to compute control signal B, then B is allowed to depend on A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
    <tr><td class="paramname">second_run</td><td>A flag to control whether a second optimization round should be performed after a working solution is already available. This costs time, but can lead to smaller circuits. If the parameter is omitted, then this step will NOT be performed. Personal feeling: it usually does not pay off. </td></tr>
    <tr><td class="paramname">min_cores</td><td>A flag that controls whether the SAT solver should compute minimal unsatisfiable cores, or just regular ones. Especially if the second_run flag is true, it may make sense to set this flag to false to be faster in the first round. However, often having min_cores=false makes things slower (and leads to larger circuits). That's why true is the default value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">792</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="Utils_8cpp_source.html#l00195">Utils::contains()</a>, <a class="el" href="CNF_8cpp_source.html#l00544">CNF::contains()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="defines_8h_source.html#l00138">DASSERT</a>, <a class="el" href="SatSolver_8cpp_source.html#l00047">SatSolver::doMinCores()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="Options_8cpp_source.html#l00523">Options::getSATSolverExtr()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">AIG2CNF::getTmpDepsTrans()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#a5b39c45cd2a1abfe96c681515dfddb77">SatSolver::incAddUnitClause()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">insertMissingAndFromTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00426">ipc_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="Utils_8cpp_source.html#l00168">Utils::randomize()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00528">CNF::renameVars()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>, and <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ce27f574afbb4504b7acd82196314d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningJiangSATTmpCtrlInc2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>second_run</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_cores</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines <a class="el" href="classLearningImplExtractor.html#ad41484b6bb6da18e50d31830a18e63e9" title="Like runLearningJiangSATTmp, but also allows dependencies on control signals. ">runLearningJiangSATTmpCtrl</a> and runLearningJiangSATInc2. </p>
<p>This method is like <a class="el" href="classLearningImplExtractor.html#ad41484b6bb6da18e50d31830a18e63e9" title="Like runLearningJiangSATTmp, but also allows dependencies on control signals. ">runLearningJiangSATTmpCtrl</a>, but uses incremental solving more aggressively, just like <a class="el" href="classLearningImplExtractor.html#a2ee6e07a5c9907195c1af8cba613dbd1" title="Like runLearningJiangSATInc1 but with even more aggressive incremental solving. ">runLearningJiangSATInc2</a>. This is achieved by introducing acitvation variables that enable or disable different parts of the formula.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
    <tr><td class="paramname">second_run</td><td>A flag to control whether a second optimization round should be performed after a working solution is already available. This costs time, but can lead to smaller circuits. If the parameter is omitted, then this step will NOT be performed. Personal feeling: it usually does not pay off. </td></tr>
    <tr><td class="paramname">min_cores</td><td>A flag that controls whether the SAT solver should compute minimal unsatisfiable cores, or just regular ones. Especially if the second_run flag is true, it may make sense to set this flag to false to be faster in the first round. However, often having min_cores=false makes things slower (and leads to larger circuits). That's why true is the default value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">1024</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="Utils_8cpp_source.html#l00195">Utils::contains()</a>, <a class="el" href="CNF_8cpp_source.html#l00544">CNF::contains()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="defines_8h_source.html#l00138">DASSERT</a>, <a class="el" href="SatSolver_8cpp_source.html#l00047">SatSolver::doMinCores()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="Options_8cpp_source.html#l00523">Options::getSATSolverExtr()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00278">AIG2CNF::getTmpDepsTrans()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00223">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">insertMissingAndFromTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00426">ipc_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="Utils_8cpp_source.html#l00220">Utils::negateLiterals()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="Utils_8cpp_source.html#l00168">Utils::randomize()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00528">CNF::renameVars()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>, and <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a009b5382cc9a65cd7c7dfbbc73815bac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningQBF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements circuit extraction with non-incremental QBF-based <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning. </p>
<p>This is a more or less straightforward implementation of the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning method from the paper Ruediger Ehlers, Robert Koenighofer, Georg Hofferek: Symbolically synthesizing small circuits. FMCAD 2012: 91.2.0 using a QBF solver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">202</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="QBFSolver_8h_source.html#l00067">QBFSolver::A</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00130">CNF::addCube()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="QBFSolver_8h_source.html#l00062">QBFSolver::E</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00417">ip_</a>, <a class="el" href="classQBFSolver.html#a53ef157391b176dfbd2a77a1e31befc3">QBFSolver::isSat()</a>, <a class="el" href="classQBFSolver.html#a76fc0c757a2c039816e3e06547f06d5c">QBFSolver::isSatModel()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00376">qbf_solver_</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, and <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a3edc5671d6f56dea4145512385063681"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LearningImplExtractor::runLearningQBFInc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>win_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_win_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements circuit extraction with incremental QBF-based <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> learning. </p>
<p>This method is very similar to <a class="el" href="classLearningImplExtractor.html#a009b5382cc9a65cd7c7dfbbc73815bac" title="Implements circuit extraction with non-incremental QBF-based CNF learning. ">runLearningQBF</a>. The difference is that this one uses incremental QBF solving using DepQBF via its API. This method will always use DepQBF, no matter which solver the user selects via command-line arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">win_region</td><td>The winning region from which the circuit should be extracted. </td></tr>
    <tr><td class="paramname">neg_win_region</td><td>The negation of the winning region. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8cpp_source.html#l00284">284</a> of file <a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a>.</p>

<p>References <a class="el" href="QBFSolver_8h_source.html#l00067">QBFSolver::A</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="QBFSolver_8h_source.html#l00062">QBFSolver::E</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="DepQBFApi_8cpp_source.html#l00427">DepQBFApi::incAddCNF()</a>, <a class="el" href="DepQBFApi_8cpp_source.html#l00500">DepQBFApi::incAddNegCubeAsClause()</a>, <a class="el" href="DepQBFApi_8cpp_source.html#l00656">DepQBFApi::incIsSatCore()</a>, <a class="el" href="DepQBFApi_8cpp_source.html#l00612">DepQBFApi::incIsSatModel()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00417">ip_</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01654">makeEq()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00087">LearningExtractorStatistics::notifyAfterClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00101">LearningExtractorStatistics::notifyAfterClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00074">LearningExtractorStatistics::notifyAfterCtrlSignal()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00081">LearningExtractorStatistics::notifyBeforeClauseComp()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00095">LearningExtractorStatistics::notifyBeforeClauseMin()</a>, <a class="el" href="LearningExtractorStatistics_8cpp_source.html#l00061">LearningExtractorStatistics::notifyBeforeCtrlSignal()</a>, <a class="el" href="Utils_8cpp_source.html#l00180">Utils::remove()</a>, <a class="el" href="CNF_8cpp_source.html#l00433">CNF::setVarValue()</a>, <a class="el" href="DepQBFApi_8cpp_source.html#l00320">DepQBFApi::startIncrementalSession()</a>, <a class="el" href="LearningImplExtractor_8h_source.html#l00431">statistics</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, and <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2d096ab7181fd608d6ee033f8c9ab8d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LearningImplExtractor::cnf_var_to_standalone_aig_var_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A map from variables as they occur in CNFs to the corresponding AIGER literals. </p>
<p>This vector maps variables as they occur in CNFs to the corresponding AIGER literals as they occur in the <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. Use <a class="el" href="classLearningImplExtractor.html#a88143aa67de5be8848f643cfb2947834" title="Transforms a CNF literal into an AIGER literal as used in standalone_circuit_. ">cnfToAig</a> to transform literals.</p>
<dl class="section note"><dt>Note</dt><dd>The AIGER literal numbering scheme in the <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a> is different from the numbering scheme in the original specification. The reason is that we want to avoid big 'holes' of unused AIGER literals right from the beginning. </dd></dl>

<p>Definition at line <a class="el" href="LearningImplExtractor_8h_source.html#l00408">408</a> of file <a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l01778">cnfToAig()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">insertMissingAndFromTrans()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">LearningImplExtractor()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8be06d42fd3c4b569ec22cfcf2f508e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CNFImplExtractor::extraction_cpu_time_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The circuit extraction time in CPU-seconds. </p>

<p>Definition at line <a class="el" href="CNFImplExtractor_8h_source.html#l00145">145</a> of file <a class="el" href="CNFImplExtractor_8h_source.html">CNFImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">CNFImplExtractor::extractCircuit()</a>, and <a class="el" href="CNFImplExtractor_8cpp_source.html#l00290">CNFImplExtractor::logStatistics()</a>.</p>

</div>
</div>
<a class="anchor" id="ae06413cf08f868357d64545b3041aa18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t CNFImplExtractor::extraction_real_time_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classCNFImplExtractor.html#ab8be06d42fd3c4b569ec22cfcf2f508e" title="The circuit extraction time in CPU-seconds. ">extraction_cpu_time_</a> but real-time. </p>

<p>Definition at line <a class="el" href="CNFImplExtractor_8h_source.html#l00150">150</a> of file <a class="el" href="CNFImplExtractor_8h_source.html">CNFImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">CNFImplExtractor::extractCircuit()</a>, and <a class="el" href="CNFImplExtractor_8cpp_source.html#l00290">CNFImplExtractor::logStatistics()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a4835eb5fc2df396272af43380ecc82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LearningImplExtractor::ip_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of uncontrollable input variables followed by the present state variables. </p>
<p>This vector contains the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> version of the uncontrollable input variables followed by the present state variables. This vector of variables is used often, and thus stored here as a field. </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8h_source.html#l00417">417</a> of file <a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">LearningImplExtractor()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">runLearningExp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">runLearningQBF()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00284">runLearningQBFInc()</a>.</p>

</div>
</div>
<a class="anchor" id="ab94459731d569bdd6bb0f3895fb9c184"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LearningImplExtractor::ipc_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of uncontrollable inputs, state variables, and control signals. </p>
<p>This vector contains the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> version of the uncontrollable input variables followed by the present state variables, followed by the control signals. This vector of variables is used often, and thus stored here as a field. </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8h_source.html#l00426">426</a> of file <a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">LearningImplExtractor()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">runLearningJiangSATTmpCtrl()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">runLearningJiangSATTmpCtrlInc2()</a>.</p>

</div>
</div>
<a class="anchor" id="a987219dd3114957f2bd0d9df77a9d7fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LearningImplExtractor::next_free_aig_lit_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next unused AIGER literal in <a class="el" href="classLearningImplExtractor.html#a17f7c47bf3e84fa5a70930e01a18deb2" title="The synthesis result as stand-alone circuit. ">standalone_circuit_</a>. </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8h_source.html#l00381">381</a> of file <a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">LearningImplExtractor()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01788">makeAnd()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l01797">makeOr()</a>.</p>

</div>
</div>
<a class="anchor" id="a4147358129fcfb9e72a0ee27d7c16f51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQBFSolver.html">QBFSolver</a>* LearningImplExtractor::qbf_solver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The QBF solver to use (as selected by the user with command-line arguments). </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8h_source.html#l00376">376</a> of file <a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">runLearningQBF()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00121">~LearningImplExtractor()</a>.</p>

</div>
</div>
<a class="anchor" id="a17f7c47bf3e84fa5a70930e01a18deb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">aiger* LearningImplExtractor::standalone_circuit_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The synthesis result as stand-alone circuit. </p>
<p>This AIGER circuit is combinatorial, i.e., has no latches. The inputs of the circuit are: the uncontrollable inputs from the spec (in the order in which they appear in the spec) followed by the state-signals (the output of the latches in the spec, in the order in which they appear in the spec). The outputs of the circuit are the controllable inputs in the order in which they are defined in the spec.</p>
<p>This circuit will be built up by one of the methods runLearningX. Then, it will be optimized using ABC. Finally, it will be inserted into the original specification, as required by the rules for SYNTComp. </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8h_source.html#l00396">396</a> of file <a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l01742">addToStandAloneAiger()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01806">insertMissingAndFromTrans()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00048">LearningImplExtractor()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01788">makeAnd()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01797">makeOr()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00121">~LearningImplExtractor()</a>.</p>

</div>
</div>
<a class="anchor" id="a018564c4a67dfb228357008a8a50aef4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLearningExtractorStatistics.html">LearningExtractorStatistics</a> LearningImplExtractor::statistics</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper for collecting performance data and statistics. </p>

<p>Definition at line <a class="el" href="LearningImplExtractor_8h_source.html#l00431">431</a> of file <a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a>.</p>

<p>Referenced by <a class="el" href="LearningImplExtractor_8cpp_source.html#l01865">logDetailedStatistics()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00130">run()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">runLearningExp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">runLearningQBF()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00284">runLearningQBFInc()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="LearningImplExtractor_8h_source.html">LearningImplExtractor.h</a></li>
<li>src/<a class="el" href="LearningImplExtractor_8cpp_source.html">LearningImplExtractor.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 26 2015 08:54:54 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
