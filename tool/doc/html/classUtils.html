<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>demiurge: Utils Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classUtils-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Utils Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains utility functions that can be usful in various back-ends.  
 <a href="classUtils.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Utils_8h_source.html">Utils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adef5db58221c7a04397de10ec0b13fb6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#adef5db58221c7a04397de10ec0b13fb6">containsInit</a> (const vector&lt; int &gt; &amp;cube)</td></tr>
<tr class="memdesc:adef5db58221c7a04397de10ec0b13fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a cube (in form of a vector of literals) contains the initial state.  <a href="#adef5db58221c7a04397de10ec0b13fb6">More...</a><br/></td></tr>
<tr class="separator:adef5db58221c7a04397de10ec0b13fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ae74e9866b8ca0863c9507e46df007"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a02ae74e9866b8ca0863c9507e46df007">containsInit</a> (const set&lt; int &gt; &amp;cube)</td></tr>
<tr class="memdesc:a02ae74e9866b8ca0863c9507e46df007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a cube (in form of a set of literals) contains the initial state.  <a href="#a02ae74e9866b8ca0863c9507e46df007">More...</a><br/></td></tr>
<tr class="separator:a02ae74e9866b8ca0863c9507e46df007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb9e182ca1da6a1050338928083f632"><td class="memItemLeft" align="right" valign="top">static vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a9eb9e182ca1da6a1050338928083f632">extract</a> (const vector&lt; int &gt; &amp;cube_or_clause, <a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a> kind)</td></tr>
<tr class="memdesc:a9eb9e182ca1da6a1050338928083f632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts literals that are of a given type from a cube or clause.  <a href="#a9eb9e182ca1da6a1050338928083f632">More...</a><br/></td></tr>
<tr class="separator:a9eb9e182ca1da6a1050338928083f632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c060a97bf0e9e5e08bf33b512633ac3"><td class="memItemLeft" align="right" valign="top">static vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a9c060a97bf0e9e5e08bf33b512633ac3">extractPresIn</a> (const vector&lt; int &gt; &amp;cube_or_clause)</td></tr>
<tr class="memdesc:a9c060a97bf0e9e5e08bf33b512633ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts present-state literals and input literals from a cube or clause.  <a href="#a9c060a97bf0e9e5e08bf33b512633ac3">More...</a><br/></td></tr>
<tr class="separator:a9c060a97bf0e9e5e08bf33b512633ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9251f04947864aaaac7e459987913429"><td class="memItemLeft" align="right" valign="top">static vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a9251f04947864aaaac7e459987913429">extractNextAsPresent</a> (const vector&lt; int &gt; &amp;cube_or_clause)</td></tr>
<tr class="memdesc:a9251f04947864aaaac7e459987913429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts next-state literals and returns the present-state copy.  <a href="#a9251f04947864aaaac7e459987913429">More...</a><br/></td></tr>
<tr class="separator:a9251f04947864aaaac7e459987913429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f2b014ac53ca027864c57e24a60195"><td class="memItemLeft" align="right" valign="top">static vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a21f2b014ac53ca027864c57e24a60195">extract</a> (const vector&lt; int &gt; &amp;cube_or_clause, const vector&lt; int &gt; &amp;vars)</td></tr>
<tr class="memdesc:a21f2b014ac53ca027864c57e24a60195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts certain literals from a cube or clause.  <a href="#a21f2b014ac53ca027864c57e24a60195">More...</a><br/></td></tr>
<tr class="separator:a21f2b014ac53ca027864c57e24a60195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71efa1aa570b356a328e95008fb65ad8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a71efa1aa570b356a328e95008fb65ad8">randomize</a> (vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="memdesc:a71efa1aa570b356a328e95008fb65ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes the order (not the value) of a given vector of integers.  <a href="#a71efa1aa570b356a328e95008fb65ad8">More...</a><br/></td></tr>
<tr class="separator:a71efa1aa570b356a328e95008fb65ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2843ae3d849c66ebd72baea26fbd7580"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a2843ae3d849c66ebd72baea26fbd7580">sort</a> (vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="memdesc:a2843ae3d849c66ebd72baea26fbd7580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a vector of integers in ascending order.  <a href="#a2843ae3d849c66ebd72baea26fbd7580">More...</a><br/></td></tr>
<tr class="separator:a2843ae3d849c66ebd72baea26fbd7580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b142132eb40445f51b1f1bb89b85f3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a15b142132eb40445f51b1f1bb89b85f3">remove</a> (vector&lt; int &gt; &amp;vec, int elem)</td></tr>
<tr class="memdesc:a15b142132eb40445f51b1f1bb89b85f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a certain element from a vector.  <a href="#a15b142132eb40445f51b1f1bb89b85f3">More...</a><br/></td></tr>
<tr class="separator:a15b142132eb40445f51b1f1bb89b85f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84611c8a027ac12426219cb4d59765aa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a84611c8a027ac12426219cb4d59765aa">contains</a> (const vector&lt; int &gt; &amp;vec, int elem)</td></tr>
<tr class="memdesc:a84611c8a027ac12426219cb4d59765aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a vector contains a certain element.  <a href="#a84611c8a027ac12426219cb4d59765aa">More...</a><br/></td></tr>
<tr class="separator:a84611c8a027ac12426219cb4d59765aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc062d4cf872c0d69924116879715ab"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a5dc062d4cf872c0d69924116879715ab">eq</a> (const vector&lt; int &gt; &amp;v1, const vector&lt; int &gt; &amp;v2, int start_idx=0)</td></tr>
<tr class="memdesc:a5dc062d4cf872c0d69924116879715ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two vectors contain the same set of elements.  <a href="#a5dc062d4cf872c0d69924116879715ab">More...</a><br/></td></tr>
<tr class="separator:a5dc062d4cf872c0d69924116879715ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7584589e0d06005fe893fdb9244483a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#ae7584589e0d06005fe893fdb9244483a">negateLiterals</a> (vector&lt; int &gt; &amp;cube_or_clause)</td></tr>
<tr class="memdesc:ae7584589e0d06005fe893fdb9244483a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates all literals in a cube or clause.  <a href="#ae7584589e0d06005fe893fdb9244483a">More...</a><br/></td></tr>
<tr class="separator:ae7584589e0d06005fe893fdb9244483a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0d236cf00a61a34ef5c48bcb08a1ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a8e0d236cf00a61a34ef5c48bcb08a1ec">swapPresentToNext</a> (vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="memdesc:a8e0d236cf00a61a34ef5c48bcb08a1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all current-state literals by their next-state copy.  <a href="#a8e0d236cf00a61a34ef5c48bcb08a1ec">More...</a><br/></td></tr>
<tr class="separator:a8e0d236cf00a61a34ef5c48bcb08a1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a513b0ad3b22b3b857060219c222d6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#aa6a513b0ad3b22b3b857060219c222d6">intersectionEmpty</a> (const vector&lt; int &gt; &amp;x, const set&lt; int &gt; &amp;y)</td></tr>
<tr class="memdesc:aa6a513b0ad3b22b3b857060219c222d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a vector and a set have an empty intersection.  <a href="#aa6a513b0ad3b22b3b857060219c222d6">More...</a><br/></td></tr>
<tr class="separator:aa6a513b0ad3b22b3b857060219c222d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae957d76f82e729f9d127cf05cb61320d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#ae957d76f82e729f9d127cf05cb61320d">intersectionEmpty</a> (const set&lt; int &gt; &amp;x, const set&lt; int &gt; &amp;y)</td></tr>
<tr class="memdesc:ae957d76f82e729f9d127cf05cb61320d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the intersection of two sets is empty.  <a href="#ae957d76f82e729f9d127cf05cb61320d">More...</a><br/></td></tr>
<tr class="separator:ae957d76f82e729f9d127cf05cb61320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dca8125b6addaa1f0331664ab6142e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#ab5dca8125b6addaa1f0331664ab6142e">isSubset</a> (const vector&lt; int &gt; &amp;subset, const vector&lt; int &gt; &amp;superset)</td></tr>
<tr class="memdesc:ab5dca8125b6addaa1f0331664ab6142e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if one vector forms a subset of another one.  <a href="#ab5dca8125b6addaa1f0331664ab6142e">More...</a><br/></td></tr>
<tr class="separator:ab5dca8125b6addaa1f0331664ab6142e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e713aa386834b587e2695855fbc27a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#ac4e713aa386834b587e2695855fbc27a">compressStateCNF</a> (<a class="el" href="classCNF.html">CNF</a> &amp;cnf, bool hardcore=false)</td></tr>
<tr class="memdesc:ac4e713aa386834b587e2695855fbc27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses a state-CNF by removing clauses that are implied by others.  <a href="#ac4e713aa386834b587e2695855fbc27a">More...</a><br/></td></tr>
<tr class="separator:ac4e713aa386834b587e2695855fbc27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bc8cf6342b8f182597aa53cf72d9d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#ad6bc8cf6342b8f182597aa53cf72d9d3">negateStateCNF</a> (<a class="el" href="classCNF.html">CNF</a> &amp;cnf)</td></tr>
<tr class="memdesc:ad6bc8cf6342b8f182597aa53cf72d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the state-variables without introducing temporary variables.  <a href="#ad6bc8cf6342b8f182597aa53cf72d9d3">More...</a><br/></td></tr>
<tr class="separator:ad6bc8cf6342b8f182597aa53cf72d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd64e5ea20bd4579427734a9ede171d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#acd64e5ea20bd4579427734a9ede171d8">negateViaAig</a> (<a class="el" href="classCNF.html">CNF</a> &amp;cnf)</td></tr>
<tr class="memdesc:acd64e5ea20bd4579427734a9ede171d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> by transforming into AIGER and back.  <a href="#acd64e5ea20bd4579427734a9ede171d8">More...</a><br/></td></tr>
<tr class="separator:acd64e5ea20bd4579427734a9ede171d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddf6a703833a37aae073e12d114a6c8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a5ddf6a703833a37aae073e12d114a6c8">compressNextStateCNF</a> (<a class="el" href="classCNF.html">CNF</a> &amp;ps_cnf, <a class="el" href="classCNF.html">CNF</a> &amp;ns_cnf, bool hardcore=false)</td></tr>
<tr class="memdesc:a5ddf6a703833a37aae073e12d114a6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses a state-CNF by removing implied clauses and computes the next-state <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>.  <a href="#a5ddf6a703833a37aae073e12d114a6c8">More...</a><br/></td></tr>
<tr class="separator:a5ddf6a703833a37aae073e12d114a6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48658c2b3c7f71261146210c7861b60"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#ae48658c2b3c7f71261146210c7861b60">getCurrentMemUsage</a> ()</td></tr>
<tr class="memdesc:ae48658c2b3c7f71261146210c7861b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current memory usage as debug message in kB.  <a href="#ae48658c2b3c7f71261146210c7861b60">More...</a><br/></td></tr>
<tr class="separator:ae48658c2b3c7f71261146210c7861b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaccd2a53073b17e3409eab8e98db0c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#adeaccd2a53073b17e3409eab8e98db0c">debugPrint</a> (const vector&lt; int &gt; &amp;vec, string prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:adeaccd2a53073b17e3409eab8e98db0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a vector of literals (mainly for debugging purposes).  <a href="#adeaccd2a53073b17e3409eab8e98db0c">More...</a><br/></td></tr>
<tr class="separator:adeaccd2a53073b17e3409eab8e98db0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc29602987b73022546a6d752a7e093f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#acc29602987b73022546a6d752a7e093f">debugCheckWinReg</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;winning_region)</td></tr>
<tr class="memdesc:acc29602987b73022546a6d752a7e093f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a winning region for correctness.  <a href="#acc29602987b73022546a6d752a7e093f">More...</a><br/></td></tr>
<tr class="separator:acc29602987b73022546a6d752a7e093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448f5356530d2e88fa9928f4ed857238"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a448f5356530d2e88fa9928f4ed857238">debugCheckWinReg</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;winning_region, const <a class="el" href="classCNF.html">CNF</a> &amp;neg_winning_region)</td></tr>
<tr class="memdesc:a448f5356530d2e88fa9928f4ed857238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a winning region and its negation for correctness.  <a href="#a448f5356530d2e88fa9928f4ed857238">More...</a><br/></td></tr>
<tr class="separator:a448f5356530d2e88fa9928f4ed857238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69b7f70358d1c1616aab1560c7363cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#af69b7f70358d1c1616aab1560c7363cd">debugPrintCurrentMemUsage</a> ()</td></tr>
<tr class="memdesc:af69b7f70358d1c1616aab1560c7363cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the current memory usage as debug message.  <a href="#af69b7f70358d1c1616aab1560c7363cd">More...</a><br/></td></tr>
<tr class="separator:af69b7f70358d1c1616aab1560c7363cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a452e78692c87ed5c7c993b6c6ac4981a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a452e78692c87ed5c7c993b6c6ac4981a">Utils</a> ()</td></tr>
<tr class="memdesc:a452e78692c87ed5c7c993b6c6ac4981a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a452e78692c87ed5c7c993b6c6ac4981a">More...</a><br/></td></tr>
<tr class="separator:a452e78692c87ed5c7c993b6c6ac4981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d842a927296003dd7088fc1e4e2a367"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a0d842a927296003dd7088fc1e4e2a367">~Utils</a> ()</td></tr>
<tr class="memdesc:a0d842a927296003dd7088fc1e4e2a367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a0d842a927296003dd7088fc1e4e2a367">More...</a><br/></td></tr>
<tr class="separator:a0d842a927296003dd7088fc1e4e2a367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80726f8ec2ed2707a8bfd4fd355ef27a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a80726f8ec2ed2707a8bfd4fd355ef27a">Utils</a> (const <a class="el" href="classUtils.html">Utils</a> &amp;other)</td></tr>
<tr class="memdesc:a80726f8ec2ed2707a8bfd4fd355ef27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a80726f8ec2ed2707a8bfd4fd355ef27a">More...</a><br/></td></tr>
<tr class="separator:a80726f8ec2ed2707a8bfd4fd355ef27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed61b802f94ec15000c458e9aae4f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtils.html">Utils</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtils.html#a0ed61b802f94ec15000c458e9aae4f19">operator=</a> (const <a class="el" href="classUtils.html">Utils</a> &amp;other)</td></tr>
<tr class="memdesc:a0ed61b802f94ec15000c458e9aae4f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a0ed61b802f94ec15000c458e9aae4f19">More...</a><br/></td></tr>
<tr class="separator:a0ed61b802f94ec15000c458e9aae4f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains utility functions that can be usful in various back-ends. </p>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.2.0 </dd></dl>

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00045">45</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a452e78692c87ed5c7c993b6c6ac4981a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Utils::Utils </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The constructor is private and not implemented. Use the static methods. </p>

</div>
</div>
<a class="anchor" id="a0d842a927296003dd7088fc1e4e2a367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Utils::~Utils </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The constructor is private and not implemented. Use the static methods. </p>

</div>
</div>
<a class="anchor" id="a80726f8ec2ed2707a8bfd4fd355ef27a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Utils::Utils </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtils.html">Utils</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5ddf6a703833a37aae073e12d114a6c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::compressNextStateCNF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>ps_cnf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_cnf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hardcore</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses a state-CNF by removing implied clauses and computes the next-state <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. </p>
<p>This method is similar to <a class="el" href="classUtils.html#ac4e713aa386834b587e2695855fbc27a" title="Compresses a state-CNF by removing clauses that are implied by others. ">compressStateCNF()</a>. The difference is that this method also computes a compact representation of the next-state copy of passed state-CNF. When compressing the next-state copy, clauses are removed if they are already implied by existing clauses or the present-state copy of the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. That is, the compression of the next-state copy is only valid if the current-state copy is going to be asserted in the solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps_cnf</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> formula to compress. We assume that this <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> only talks about the present-state variables. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is compressed, similar as done by <a class="el" href="classUtils.html#ac4e713aa386834b587e2695855fbc27a" title="Compresses a state-CNF by removing clauses that are implied by others. ">compressStateCNF()</a>. </td></tr>
    <tr><td class="paramname">ns_cnf</td><td>An empty <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is filled with the compression of the next-state copy of ps_cnf. The resulting ns_cnf is only valid under the assumption that ps_cnf is asserted. </td></tr>
    <tr><td class="paramname">hardcore</td><td>Set this parameter to true if you do not only want to remove clauses but also literals from clauses. This is more expensive, but can produce smaller <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representations. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00502">502</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="VarManager_8cpp_source.html#l00300">VarManager::getAllNonTempVars()</a>, <a class="el" href="CNF_8cpp_source.html#l00306">CNF::getNrOfClauses()</a>, <a class="el" href="Options_8cpp_source.html#l00510">Options::getSATSolver()</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="Utils_8cpp_source.html#l00220">negateLiterals()</a>, <a class="el" href="CNF_8cpp_source.html#l00207">CNF::removeSmallest()</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, and <a class="el" href="CNF_8cpp_source.html#l00294">CNF::swapWith()</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l00309">UnivExpander::resetSolverIExp()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">LearningImplExtractor::runLearningExp()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4e713aa386834b587e2695855fbc27a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::compressStateCNF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>cnf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hardcore</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses a state-CNF by removing clauses that are implied by others. </p>
<p>This is done by incremental SAT-solving and is usually quite fast (at least compared to QBF solving).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> formula to compress. </td></tr>
    <tr><td class="paramname">hardcore</td><td>Set this parameter to true if you do not only want to remove clauses but also literals from clauses. This is more expensive, but can produce smaller <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> representations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> was modified, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00305">305</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="CNF_8cpp_source.html#l00306">CNF::getNrOfClauses()</a>, <a class="el" href="Options_8cpp_source.html#l00510">Options::getSATSolver()</a>, <a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">SatSolver::incAddClause()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">SatSolver::incIsSat()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="Utils_8cpp_source.html#l00220">negateLiterals()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="CNF_8cpp_source.html#l00207">CNF::removeSmallest()</a>, and <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">LearnSynthQBF::computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00408">LearnSynthQBFInc::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">LearnSynthQBF::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">LearnSynthQBFInd::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00565">LearnSynthQBFInc::computeWinningRegionAllPool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00122">LearnSynthQBFInc::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">LearnSynthQBF::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">LearnSynthQBFInd::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00273">LearnSynthQBFInc::computeWinningRegionOnePool()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01045">ClauseExplorerSAT::considerNewInfoFromOthers()</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">CNFImplExtractor::extractCircuit()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02299">TemplExplorer::findWinRegCNFTempl()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00560">ParallelLearner::triggerExplorerRestart()</a>.</p>

</div>
</div>
<a class="anchor" id="a84611c8a027ac12426219cb4d59765aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::contains </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a vector contains a certain element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector in which the element should be searched. </td></tr>
    <tr><td class="paramname">elem</td><td>The element to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vector contains the element, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00195">195</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l02080">IFM13Explorer::addBlockedState()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02700">TemplExplorer::exclude()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="Utils_8cpp_source.html#l00153">extract()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01332">CounterGenSAT::generalizeCeFuther()</a>, <a class="el" href="DepQBFExt_8cpp_source.html#l00106">DepQBFExt::parseModel()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>, and <a class="el" href="ParExtractor_8cpp_source.html#l00553">ParExtractorWorker::runSATDep()</a>.</p>

</div>
</div>
<a class="anchor" id="adef5db58221c7a04397de10ec0b13fb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::containsInit </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a cube (in form of a vector of literals) contains the initial state. </p>
<p>In our synthesis problems, there is exactly one initial state of the system (this is a restriction imposed by the AIGER format which serves as input for our tool). Furthermore, the initial state is always characterized by having all state bits set to FALSE. However, this may change with future AIGER versions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube</td><td>The cube (a conjuction of literals) in form of a vector of literals over the current-state variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the cube contains the initial state (i.e., the initial state satisfies the cube, i.e., the cube contains only negated literals). False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00045">45</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00765">LearnSynthQBFInc::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">LearnSynthQBF::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">LearnSynthQBFInd::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00733">LearnSynthQBFInc::computeBlockingClause()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00432">LearnSynthQBF::computeBlockingClause()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00346">LearnSynthQBFInd::computeBlockingClause()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01564">ClauseMinimizerQBF::minimizeClausesInc()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01674">ClauseMinimizerQBF::minimizeClausesNoInc()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00229">IFM13Synth::recBlockCube()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01941">IFM13Explorer::recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="a02ae74e9866b8ca0863c9507e46df007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::containsInit </td>
          <td>(</td>
          <td class="paramtype">const set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a cube (in form of a set of literals) contains the initial state. </p>
<p>In our synthesis problems, there is exactly one initial state of the system (this is a restriction imposed by the AIGER format which serves as input for our tool). Furthermore, the initial state is always characterized by having all state bits set to FALSE. However, this may change with future AIGER versions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube</td><td>The cube (a conjuction of literals) in form of a set of literals over the current-state variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the cube contains the initial state (i.e., the initial state satisfies the cube, i.e., the cube contains only negated literals). False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00056">56</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc29602987b73022546a6d752a7e093f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::debugCheckWinReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>winning_region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks a winning region for correctness. </p>
<p>The check is only done in debug-mode. In release-mode this method does nothing. In debug-mode this method checks three properties of a winning region W. </p>
<ol>
<li>
I(x) =&gt; W(x): every initial state must be contained in the winning region </li>
<li>
W(x) =&gt; P(x): every state of the winning region must be safe </li>
<li>
forall x,i: exists c,x': W(x) =&gt; (T(x,i,c,x') &amp; W(x')): from every state in the winning region it must be possible to stay in the winning region by setting the c-signals appropriately. </li>
</ol>
<p>These three properties are sufficient for turning the winning region into a circuit. However, thise conditions are not necessary. E.g., if optimization RC is used by <a class="el" href="classLearnSynthQBFInd.html" title="Implements a learning-based synthesis with inductive reachability reasoning. ">LearnSynthQBFInd</a> or <a class="el" href="classLearnSynthSAT.html" title="Implements a learning-based synthesis using two SAT solvers. ">LearnSynthSAT</a>, the third property does not hold. Hence, these classes have special methods to check such winning regions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">winning_region</td><td>The winning region to check. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00645">645</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00272">CNF::negate()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00168">LearnSynthSAT::computeWinningRegion()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00178">LearnSynthQBFInd::computeWinningRegion()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00073">LearnSynthQBFInc::run()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00067">TemplateSynth::run()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00121">IFM13Synth::run()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00092">LearnSynthQBF::run()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00391">ParallelLearner::run()</a>.</p>

</div>
</div>
<a class="anchor" id="a448f5356530d2e88fa9928f4ed857238"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::debugCheckWinReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>winning_region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>neg_winning_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks a winning region and its negation for correctness. </p>
<p>Use this method if you have the negation of the winning region available. Otherwise, we would end up with a double-negation, which is inefficient.</p>
<p>The check is only done in debug-mode. In release-mode this method does nothing. In debug-mode this method checks three properties of a winning region W. </p>
<ol>
<li>
I(x) =&gt; W(x): every initial state must be contained in the winning region </li>
<li>
W(x) =&gt; P(x): every state of the winning region must be safe </li>
<li>
forall x,i: exists c,x': W(x) =&gt; (T(x,i,c,x') &amp; W(x')): from every state in the winning region it must be possible to stay in the winning region by setting the c-signals appropriately. </li>
</ol>
<p>These three properties are sufficient for turning the winning region into a circuit. However, thise conditions are not necessary. E.g., if optimization RC is used by <a class="el" href="classLearnSynthQBFInd.html" title="Implements a learning-based synthesis with inductive reachability reasoning. ">LearnSynthQBFInd</a> or <a class="el" href="classLearnSynthSAT.html" title="Implements a learning-based synthesis using two SAT solvers. ">LearnSynthSAT</a>, the third property does not hold. Hence, these classes have special methods to check such winning regions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">winning_region</td><td>The winning region to check. </td></tr>
    <tr><td class="paramname">neg_winning_region</td><td>The negation of the winning region to check. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00655">655</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="QBFSolver_8h_source.html#l00067">QBFSolver::A</a>, <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="QBFSolver_8h_source.html#l00062">QBFSolver::E</a>, <a class="el" href="Utils_8cpp_source.html#l00067">extract()</a>, <a class="el" href="Options_8cpp_source.html#l00491">Options::getQBFSolver()</a>, <a class="el" href="Options_8cpp_source.html#l00510">Options::getSATSolver()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00042">AIG2CNF::instance()</a>, <a class="el" href="classQBFSolver.html#a53ef157391b176dfbd2a77a1e31befc3">QBFSolver::isSat()</a>, <a class="el" href="classSatSolver.html#a82f60f60db464fbe5c66a20ad673a573">SatSolver::isSat()</a>, <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="CNF_8cpp_source.html#l00252">CNF::renameTmps()</a>, <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, and <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>.</p>

</div>
</div>
<a class="anchor" id="adeaccd2a53073b17e3409eab8e98db0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::debugPrint </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a vector of literals (mainly for debugging purposes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of literals to print. </td></tr>
    <tr><td class="paramname">prefix</td><td>An optional prefix for the debug message. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00630">630</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00408">LearnSynthQBFInc::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00267">LearnSynthQBF::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00269">LearnSynthQBFInd::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00565">LearnSynthQBFInc::computeWinningRegionAllPool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00488">LearnSynthQBFInc::computeWinningRegionAllPush()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00122">LearnSynthQBFInc::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">LearnSynthQBF::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">LearnSynthQBFInd::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00273">LearnSynthQBFInc::computeWinningRegionOnePool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00199">LearnSynthQBFInc::computeWinningRegionOnePush()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">LearnSynthQBF::computeWinningRegionOneSAT()</a>, and <a class="el" href="DepQBFApi_8cpp_source.html#l00935">DepQBFApi::debugCheckBloqqerModel()</a>.</p>

</div>
</div>
<a class="anchor" id="af69b7f70358d1c1616aab1560c7363cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::debugPrintCurrentMemUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the current memory usage as debug message. </p>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00756">756</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h_source.html#l00319">L_DBG</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00178">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a5dc062d4cf872c0d69924116879715ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::eq </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two vectors contain the same set of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The first vector for the comparison. </td></tr>
    <tr><td class="paramname">start_idx</td><td>The start index for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two vectors contain the same set of elements. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00206">206</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9eb9e182ca1da6a1050338928083f632"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Utils::extract </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube_or_clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarInfo.html#a64d1da76cf84fe674e5fef9764ef11cf">VarInfo::VarKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts literals that are of a given type from a cube or clause. </p>
<p>This method takes as argument a cube or a clause (a set of literals), and a kind of variables. It returns the same set of literals with all variables of other kind removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube_or_clause</td><td>The cube or clause from which only the desired literals should be extracted. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of literals that should be extracted. Literals of other kinds will be discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The literals of cube_or_clause that are of a given type. That is, the returned vector is a subset of cube_or_clause, where all elements are of the desired kind. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00067">67</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, and <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">LearnSynthQBF::computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00676">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="Utils_8cpp_source.html#l00655">debugCheckWinReg()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00229">IFM13Synth::recBlockCube()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01941">IFM13Explorer::recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="a21f2b014ac53ca027864c57e24a60195"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Utils::extract </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube_or_clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts certain literals from a cube or clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube_or_clause</td><td>The cube or clause to analyze. </td></tr>
    <tr><td class="paramname">vars</td><td>The variables to extract from cube_or_clause. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All literals of cube_or_clause where the corresponding variable occurs in vars. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00153">153</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="Utils_8cpp_source.html#l00195">contains()</a>.</p>

</div>
</div>
<a class="anchor" id="a9251f04947864aaaac7e459987913429"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Utils::extractNextAsPresent </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube_or_clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts next-state literals and returns the present-state copy. </p>
<p>This method takes as argument a cube or a clause (a set of literals). It returns the present-state copy of all the next-state literals in the cube or clause.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube_or_clause</td><td>The cube or clause from which the current-state copy of the next-state literals should be extracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>current-state copy of the next-state literals in cube_or_clause. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00128">128</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, and <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00229">IFM13Synth::recBlockCube()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01941">IFM13Explorer::recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c060a97bf0e9e5e08bf33b512633ac3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Utils::extractPresIn </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube_or_clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts present-state literals and input literals from a cube or clause. </p>
<p>This method takes as argument a cube or a clause (a set of literals). It returns the all literals from this set which are either present-state literals or (uncontrollable) input literals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube_or_clause</td><td>The cube or clause from which only current-state and input literals should be extracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The literals of cube_or_clause that are either current-state literals or inputs. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00090">90</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, and <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00229">IFM13Synth::recBlockCube()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01941">IFM13Explorer::recBlockCube()</a>.</p>

</div>
</div>
<a class="anchor" id="ae48658c2b3c7f71261146210c7861b60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Utils::getCurrentMemUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current memory usage as debug message in kB. </p>
<dl class="section return"><dt>Returns</dt><dd>The current memory usage as debug message in kB. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00597">597</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="UnivExpander_8cpp_source.html#l01439">UnivExpander::initSolverIData()</a>, and <a class="el" href="UnivExpander_8cpp_source.html#l00309">UnivExpander::resetSolverIExp()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6a513b0ad3b22b3b857060219c222d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::intersectionEmpty </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a vector and a set have an empty intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector to check. </td></tr>
    <tr><td class="paramname">y</td><td>The set to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the intersection of the vector and the set is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00248">248</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00765">LearnSynthQBFInc::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">LearnSynthQBF::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">LearnSynthQBFInd::computeAllBlockingClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>.</p>

</div>
</div>
<a class="anchor" id="ae957d76f82e729f9d127cf05cb61320d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::intersectionEmpty </td>
          <td>(</td>
          <td class="paramtype">const set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the intersection of two sets is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first set for the check. </td></tr>
    <tr><td class="paramname">y</td><td>The second set for the check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the intersection is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00265">265</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5dca8125b6addaa1f0331664ab6142e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::isSubset </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>superset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if one vector forms a subset of another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subset</td><td>The potential subset in the check. </td></tr>
    <tr><td class="paramname">superset</td><td>The potential superset in the check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'subset' is really a subset of 'superset', false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00282">282</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, and <a class="el" href="CNF_8cpp_source.html#l00366">CNF::simplify()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7584589e0d06005fe893fdb9244483a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::negateLiterals </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube_or_clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates all literals in a cube or clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube_or_clause</td><td>The cube or clause in which all literals should be negated. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00220">220</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01390">CounterGenSAT::bored()</a>, <a class="el" href="Utils_8cpp_source.html#l00502">compressNextStateCNF()</a>, <a class="el" href="Utils_8cpp_source.html#l00305">compressStateCNF()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00765">LearnSynthQBFInc::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">LearnSynthQBF::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">LearnSynthQBFInd::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00733">LearnSynthQBFInc::computeBlockingClause()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00432">LearnSynthQBF::computeBlockingClause()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00346">LearnSynthQBFInd::computeBlockingClause()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00356">LearnSynthSAT::computeWinningRegionPlainExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01802">LearnSynthSAT::computeWinningRegionRGRCExp()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00335">TemplateSynth::findWinRegANDNetwork()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01332">CounterGenSAT::generalizeCeFuther()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01564">ClauseMinimizerQBF::minimizeClausesInc()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01674">ClauseMinimizerQBF::minimizeClausesNoInc()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00865">LearnSynthQBFInc::reduceExistingClauses()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00294">ParExtractorWorker::runSAT()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00553">ParExtractorWorker::runSATDep()</a>, <a class="el" href="TemplateSynth_8cpp_source.html#l00607">TemplateSynth::syntSAT()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l02544">TemplExplorer::syntSAT()</a>.</p>

</div>
</div>
<a class="anchor" id="ad6bc8cf6342b8f182597aa53cf72d9d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::negateStateCNF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>cnf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> over the state-variables without introducing temporary variables. </p>
<p>The negation of the passed <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is computed via computational learning. It uses a SAT solver in an incremental fashion. This is more expensive than simply calling cnf.negate(), but it does not introduce temporary variables, and hence may lead to a smaller <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> formula to negate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00371">371</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00137">CNF::addNegCubeAsClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="Options_8cpp_source.html#l00510">Options::getSATSolver()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">SatSolver::incAddCNF()</a>, <a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">SatSolver::incAddNegCubeAsClause()</a>, <a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">SatSolver::incIsSatModelOrCore()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="CNF_8cpp_source.html#l00272">CNF::negate()</a>, <a class="el" href="VarManager_8cpp_source.html#l00082">VarManager::pop()</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="VarManager_8cpp_source.html#l00055">VarManager::push()</a>, and <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">SatSolver::startIncrementalSession()</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01820">IFM13Explorer::exploreClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="acd64e5ea20bd4579427734a9ede171d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::negateViaAig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>cnf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> by transforming into AIGER and back. </p>
<p>This method performs the following 3 steps to negate a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>: (1) the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> is transformed into AIGER format, (2) optimized with ABC, and (3) transformed back into <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a>. The new <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> has one (fresh) temporary variable per AIGER gate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form. ">CNF</a> formula to negate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00410">410</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00169">CNF::add1LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00186">CNF::add3LitClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00571">CNF::appendVarsTo()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="CNF_8cpp_source.html#l00360">CNF::getClauses()</a>, <a class="el" href="Options_8cpp_source.html#l00481">Options::getTPDirName()</a>, <a class="el" href="Options_8cpp_source.html#l00471">Options::getUniqueTmpFileName()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00068">Options::instance()</a>, and <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a0ed61b802f94ec15000c458e9aae4f19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtils.html">Utils</a>&amp; Utils::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtils.html">Utils</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="a71efa1aa570b356a328e95008fb65ad8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::randomize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomizes the order (not the value) of a given vector of integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to randomize. This vector is modified in-place, i.e., after calling this method, the order of the elements in the passed vector will be randomized. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00168">168</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00733">LearnSynthQBFInc::computeBlockingClause()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00432">LearnSynthQBF::computeBlockingClause()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00346">LearnSynthQBFInd::computeBlockingClause()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="DepQBFApi_8cpp_source.html#l00829">DepQBFApi::extractCore()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01564">ClauseMinimizerQBF::minimizeClausesInc()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01674">ClauseMinimizerQBF::minimizeClausesNoInc()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>, and <a class="el" href="ParExtractor_8cpp_source.html#l00553">ParExtractorWorker::runSATDep()</a>.</p>

</div>
</div>
<a class="anchor" id="a15b142132eb40445f51b1f1bb89b85f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Utils::remove </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a certain element from a vector. </p>
<p>This method may change the order of the elements arbitrarily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector from which the element should be removed. </td></tr>
    <tr><td class="paramname">elem</td><td>The element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the element was removed, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00180">180</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00765">LearnSynthQBFInc::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">LearnSynthQBF::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">LearnSynthQBFInd::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01154">LearnSynthSAT::computeWinningRegionRGExp()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="DepQBFApi_8cpp_source.html#l00829">DepQBFApi::extractCore()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01332">CounterGenSAT::generalizeCeFuther()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">LearnSynthQBF::generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">LearnSynthQBFInd::generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00972">LearnSynthQBFInc::generalizeCounterexampleFurther()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01173">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="LingelingApi_8cpp_source.html#l00276">LingelingApi::incIsSatModelOrCore()</a>, <a class="el" href="PicoSatApi_8cpp_source.html#l00266">PicoSatApi::incIsSatModelOrCore()</a>, <a class="el" href="MiniSatApi_8cpp_source.html#l00346">MiniSatApi::incIsSatModelOrCore()</a>, <a class="el" href="PicoSatApi_8cpp_source.html#l00073">PicoSatApi::isSatModelOrCore()</a>, <a class="el" href="LingelingApi_8cpp_source.html#l00072">LingelingApi::isSatModelOrCore()</a>, <a class="el" href="MiniSatApi_8cpp_source.html#l00144">MiniSatApi::isSatModelOrCore()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01564">ClauseMinimizerQBF::minimizeClausesInc()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01674">ClauseMinimizerQBF::minimizeClausesNoInc()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00532">LearnSynthQBF::reduceExistingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00452">LearnSynthQBFInd::reduceExistingClauses()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00367">LearningImplExtractor::runLearningExp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00436">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01249">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01456">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00604">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00792">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01024">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00202">LearningImplExtractor::runLearningQBF()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00284">LearningImplExtractor::runLearningQBFInc()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l01128">ParExtractorQBFWorker::runQBF()</a>, <a class="el" href="ParExtractor_8cpp_source.html#l00294">ParExtractorWorker::runSAT()</a>, and <a class="el" href="ParExtractor_8cpp_source.html#l00553">ParExtractorWorker::runSATDep()</a>.</p>

</div>
</div>
<a class="anchor" id="a2843ae3d849c66ebd72baea26fbd7580"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::sort </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts a vector of integers in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to sort. This vector is modified in-place, i.e., after calling this method, this vector will be sorted. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00174">174</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00960">LearnSynthQBFInc::generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">LearnSynthQBF::generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">LearnSynthQBFInd::generalizeCounterexample()</a>, and <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00972">LearnSynthQBFInc::generalizeCounterexampleFurther()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e0d236cf00a61a34ef5c48bcb08a1ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::swapPresentToNext </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all current-state literals by their next-state copy. </p>
<dl class="section note"><dt>Note</dt><dd>The passed vector of literals must only contain current-state literals. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of literals in which all current-state literals (it must only talk about current-state literals) should be replaced by their next-state copy. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Utils_8cpp_source.html#l00227">227</a> of file <a class="el" href="Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p>References <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="defines_8h_source.html#l00116">MASSERT</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, and <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00351">IFM13Synth::addBlockedState()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02080">IFM13Explorer::addBlockedState()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00405">IFM13Synth::addLose()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l02136">IFM13Explorer::addLose()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00765">LearnSynthQBFInc::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00450">LearnSynthQBF::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00364">LearnSynthQBFInd::computeAllBlockingClauses()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00733">LearnSynthQBFInc::computeBlockingClause()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00408">LearnSynthQBFInc::computeWinningRegionAll()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00565">LearnSynthQBFInc::computeWinningRegionAllPool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00488">LearnSynthQBFInc::computeWinningRegionAllPush()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00122">LearnSynthQBFInc::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00135">LearnSynthQBF::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00197">LearnSynthQBFInd::computeWinningRegionOne()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00273">LearnSynthQBFInc::computeWinningRegionOnePool()</a>, <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00199">LearnSynthQBFInc::computeWinningRegionOnePush()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">LearnSynthQBF::computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00206">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00471">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00953">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01589">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l01380">LearnSynthSAT::computeWinningRegionRGRecy()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00782">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01332">CounterGenSAT::generalizeCeFuther()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00627">LearnSynthQBF::generalizeCounterexample()</a>, <a class="el" href="LearnSynthQBFInd_8cpp_source.html#l00569">LearnSynthQBFInd::generalizeCounterexample()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01674">ClauseMinimizerQBF::minimizeClausesNoInc()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00177">IFM13Synth::propagateBlockedStates()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01884">IFM13Explorer::propagateBlockedStates()</a>, and <a class="el" href="LearnSynthQBFInc_8cpp_source.html#l00865">LearnSynthQBFInc::reduceExistingClauses()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="Utils_8h_source.html">Utils.h</a></li>
<li>src/<a class="el" href="Utils_8cpp_source.html">Utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 26 2015 08:54:58 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
