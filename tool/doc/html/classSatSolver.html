<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>demiurge: SatSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classSatSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SatSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract interface for all SAT-solver implementations.  
 <a href="classSatSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SatSolver_8h_source.html">SatSolver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SatSolver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSatSolver.png" usemap="#SatSolver_map" alt=""/>
  <map id="SatSolver_map" name="SatSolver_map">
<area href="classLingelingApi.html" title="Interfaces the Lingeling SAT-solver via its API." alt="LingelingApi" shape="rect" coords="0,56,82,80"/>
<area href="classMiniSatApi.html" title="Interfaces the MiniSat SAT-solver via its API." alt="MiniSatApi" shape="rect" coords="92,56,174,80"/>
<area href="classPicoSatApi.html" title="Interfaces the PicoSat SAT-solver via its API." alt="PicoSatApi" shape="rect" coords="184,56,266,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2abb0a2a75d1c3559946956ac19dc89e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a2abb0a2a75d1c3559946956ac19dc89e">SatSolver</a> (bool rand_models=false, bool min_cores=true)</td></tr>
<tr class="memdesc:a2abb0a2a75d1c3559946956ac19dc89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a2abb0a2a75d1c3559946956ac19dc89e"></a><br/></td></tr>
<tr class="memitem:aeefe936d75dbdca120805d650a12e989"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#aeefe936d75dbdca120805d650a12e989">~SatSolver</a> ()</td></tr>
<tr class="memdesc:aeefe936d75dbdca120805d650a12e989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aeefe936d75dbdca120805d650a12e989"></a><br/></td></tr>
<tr class="memitem:a159fc9658709e5aeba2844a09454b2cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a159fc9658709e5aeba2844a09454b2cb">doMinCores</a> (bool min_cores=true)</td></tr>
<tr class="memdesc:a159fc9658709e5aeba2844a09454b2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the computation of MINIMAL unsatisfiable cores.  <a href="#a159fc9658709e5aeba2844a09454b2cb"></a><br/></td></tr>
<tr class="memitem:ae229c5e277350710412fce0e867dc566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#ae229c5e277350710412fce0e867dc566">doRandModels</a> (bool rand_models=true)</td></tr>
<tr class="memdesc:ae229c5e277350710412fce0e867dc566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the randomization of satisfying assignments.  <a href="#ae229c5e277350710412fce0e867dc566"></a><br/></td></tr>
<tr class="memitem:a82f60f60db464fbe5c66a20ad673a573"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a82f60f60db464fbe5c66a20ad673a573">isSat</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;cnf)=0</td></tr>
<tr class="memdesc:a82f60f60db464fbe5c66a20ad673a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is satisfiable.  <a href="#a82f60f60db464fbe5c66a20ad673a573"></a><br/></td></tr>
<tr class="memitem:ad5cfce08969be5aaf5cd705c12c68818"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#ad5cfce08969be5aaf5cd705c12c68818">isSatModelOrCore</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;cnf, const vector&lt; int &gt; &amp;assumptions, const vector&lt; int &gt; &amp;vars_of_interest, vector&lt; int &gt; &amp;model_or_core)=0</td></tr>
<tr class="memdesc:ad5cfce08969be5aaf5cd705c12c68818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is satisfiable and extracts a model or an unsatisfiable core.  <a href="#ad5cfce08969be5aaf5cd705c12c68818"></a><br/></td></tr>
<tr class="memitem:a74603f84c3f2383a5fc44d5a8093cbea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea">startIncrementalSession</a> (const vector&lt; int &gt; &amp;vars_to_keep, bool use_push=true)=0</td></tr>
<tr class="memdesc:a74603f84c3f2383a5fc44d5a8093cbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new incremental session.  <a href="#a74603f84c3f2383a5fc44d5a8093cbea"></a><br/></td></tr>
<tr class="memitem:a8118d2900f7acf31497cd2a27ad3b713"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a8118d2900f7acf31497cd2a27ad3b713">clearIncrementalSession</a> ()=0</td></tr>
<tr class="memdesc:a8118d2900f7acf31497cd2a27ad3b713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the solver instance that is used in the incremental session.  <a href="#a8118d2900f7acf31497cd2a27ad3b713"></a><br/></td></tr>
<tr class="memitem:ab2581b192cb2c39a81a416a9f7416c9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#ab2581b192cb2c39a81a416a9f7416c9e">incAddCNF</a> (const <a class="el" href="classCNF.html">CNF</a> &amp;cnf)=0</td></tr>
<tr class="memdesc:ab2581b192cb2c39a81a416a9f7416c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> to the current incremental session.  <a href="#ab2581b192cb2c39a81a416a9f7416c9e"></a><br/></td></tr>
<tr class="memitem:a9f91c104238b6e091513e0aa46970840"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a9f91c104238b6e091513e0aa46970840">incAddClause</a> (const vector&lt; int &gt; &amp;clause)=0</td></tr>
<tr class="memdesc:a9f91c104238b6e091513e0aa46970840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new clause to the current incremental session.  <a href="#a9f91c104238b6e091513e0aa46970840"></a><br/></td></tr>
<tr class="memitem:a5b39c45cd2a1abfe96c681515dfddb77"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a5b39c45cd2a1abfe96c681515dfddb77">incAddUnitClause</a> (int lit)=0</td></tr>
<tr class="memdesc:a5b39c45cd2a1abfe96c681515dfddb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new unit clause to the current incremental session.  <a href="#a5b39c45cd2a1abfe96c681515dfddb77"></a><br/></td></tr>
<tr class="memitem:a791be541b59ef58a29a1c517fca943e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a791be541b59ef58a29a1c517fca943e7">incAdd2LitClause</a> (int lit1, int lit2)=0</td></tr>
<tr class="memdesc:a791be541b59ef58a29a1c517fca943e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new clause consisting of 2 literals to the current incremental session.  <a href="#a791be541b59ef58a29a1c517fca943e7"></a><br/></td></tr>
<tr class="memitem:abca288874a1b8ab1a90cb274eb885ace"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#abca288874a1b8ab1a90cb274eb885ace">incAdd3LitClause</a> (int lit1, int lit2, int lit3)=0</td></tr>
<tr class="memdesc:abca288874a1b8ab1a90cb274eb885ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new clause consisting of 3 literals to the current incremental session.  <a href="#abca288874a1b8ab1a90cb274eb885ace"></a><br/></td></tr>
<tr class="memitem:a1f04f34bb04174489ed18d0b62241004"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a1f04f34bb04174489ed18d0b62241004">incAddCube</a> (const vector&lt; int &gt; &amp;cube)=0</td></tr>
<tr class="memdesc:a1f04f34bb04174489ed18d0b62241004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new cube to the current incremental session.  <a href="#a1f04f34bb04174489ed18d0b62241004"></a><br/></td></tr>
<tr class="memitem:a6be2c564289a59057c4c6728a3aa9c2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a6be2c564289a59057c4c6728a3aa9c2b">incAddNegCubeAsClause</a> (const vector&lt; int &gt; &amp;cube)=0</td></tr>
<tr class="memdesc:a6be2c564289a59057c4c6728a3aa9c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the negation of a given cube (which is a clause) to the incremental session.  <a href="#a6be2c564289a59057c4c6728a3aa9c2b"></a><br/></td></tr>
<tr class="memitem:ab1aab4b96a36b2003450067a3799ae23"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#ab1aab4b96a36b2003450067a3799ae23">incIsSat</a> ()=0</td></tr>
<tr class="memdesc:ab1aab4b96a36b2003450067a3799ae23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> in the incremental session is satisfiable.  <a href="#ab1aab4b96a36b2003450067a3799ae23"></a><br/></td></tr>
<tr class="memitem:a1864787a33621efac7fc75fb6b25f080"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a1864787a33621efac7fc75fb6b25f080">incIsSat</a> (const vector&lt; int &gt; &amp;assumptions)=0</td></tr>
<tr class="memdesc:a1864787a33621efac7fc75fb6b25f080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> in the incremental session is satisfiable under assumptions.  <a href="#a1864787a33621efac7fc75fb6b25f080"></a><br/></td></tr>
<tr class="memitem:ad387fc06bacf2d48847f779c9db8461a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#ad387fc06bacf2d48847f779c9db8461a">incIsSatModelOrCore</a> (const vector&lt; int &gt; &amp;assumptions, const vector&lt; int &gt; &amp;vars_of_interest, vector&lt; int &gt; &amp;model_or_core)=0</td></tr>
<tr class="memdesc:ad387fc06bacf2d48847f779c9db8461a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> in the incremental session and computes a model or unsat core.  <a href="#ad387fc06bacf2d48847f779c9db8461a"></a><br/></td></tr>
<tr class="memitem:a29225bfab1f352cae27c68e9bda4d409"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a29225bfab1f352cae27c68e9bda4d409">incIsSatModelOrCore</a> (const vector&lt; int &gt; &amp;core_assumptions, const vector&lt; int &gt; &amp;more_assumptions, const vector&lt; int &gt; &amp;vars_of_interest, vector&lt; int &gt; &amp;model_or_core)=0</td></tr>
<tr class="memdesc:a29225bfab1f352cae27c68e9bda4d409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a satisfying assignment or core using additional assumptions.  <a href="#a29225bfab1f352cae27c68e9bda4d409"></a><br/></td></tr>
<tr class="memitem:a4da0dff7082a91429e3311d279605be4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a4da0dff7082a91429e3311d279605be4">incPush</a> ()=0</td></tr>
<tr class="memdesc:a4da0dff7082a91429e3311d279605be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the current state of the incremental session on a stack.  <a href="#a4da0dff7082a91429e3311d279605be4"></a><br/></td></tr>
<tr class="memitem:a436aae045eb04141c834df0b55947ee5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a436aae045eb04141c834df0b55947ee5">incPop</a> ()=0</td></tr>
<tr class="memdesc:a436aae045eb04141c834df0b55947ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the incremental session back to the point where <a class="el" href="classSatSolver.html#a4da0dff7082a91429e3311d279605be4" title="Stores the current state of the incremental session on a stack.">incPush()</a> was called.  <a href="#a436aae045eb04141c834df0b55947ee5"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adfeecebfd09606c82b5c57cfe5aad813"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#adfeecebfd09606c82b5c57cfe5aad813">min_cores_</a></td></tr>
<tr class="memdesc:adfeecebfd09606c82b5c57cfe5aad813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the unsat cores returned by the solver should be minimized further.  <a href="#adfeecebfd09606c82b5c57cfe5aad813"></a><br/></td></tr>
<tr class="memitem:a73fed24d8fb4da85ef82dc53ac5f28c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a73fed24d8fb4da85ef82dc53ac5f28c7">rand_models_</a></td></tr>
<tr class="memdesc:a73fed24d8fb4da85ef82dc53ac5f28c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if satisfying assignments should be randomized.  <a href="#a73fed24d8fb4da85ef82dc53ac5f28c7"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0821aa3a3fababd9b070f758b6e788cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a0821aa3a3fababd9b070f758b6e788cc">SatSolver</a> (const <a class="el" href="classSatSolver.html">SatSolver</a> &amp;other)</td></tr>
<tr class="memdesc:a0821aa3a3fababd9b070f758b6e788cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a0821aa3a3fababd9b070f758b6e788cc"></a><br/></td></tr>
<tr class="memitem:a9dc824ecbeaf4f0505403b284f6fe047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSatSolver.html">SatSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSatSolver.html#a9dc824ecbeaf4f0505403b284f6fe047">operator=</a> (const <a class="el" href="classSatSolver.html">SatSolver</a> &amp;other)</td></tr>
<tr class="memdesc:a9dc824ecbeaf4f0505403b284f6fe047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a9dc824ecbeaf4f0505403b284f6fe047"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>An abstract interface for all SAT-solver implementations. </p>
<p>This class represents an abstract interface all SAT-solver instances. You cannot instantiate objects of this class. You need to instantiate objects of one of the derived classes (e.g., <a class="el" href="classLingelingApi.html" title="Interfaces the Lingeling SAT-solver via its API.">LingelingApi</a>, <a class="el" href="classMiniSatApi.html" title="Interfaces the MiniSat SAT-solver via its API.">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html" title="Interfaces the PicoSat SAT-solver via its API.">PicoSatApi</a>) instead. Typically, you will call <a class="el" href="classOptions.html#aed3731b7c89433cd485cff35ca4bdcd7" title="Returns a fresh instance of the SAT-solver selected by the user.">Options::getSATSolver()</a> to get a concrete instance of a <a class="el" href="classSatSolver.html" title="An abstract interface for all SAT-solver implementations.">SatSolver</a> (namely the one the user selected with command-line parameters).</p>
<p>For a given <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>, a <a class="el" href="classSatSolver.html" title="An abstract interface for all SAT-solver implementations.">SatSolver</a> is able to determine satisfiability. Furthermore, in case of satisfiability, it can extract satisfying assignments. In case of unsatisfiability, it can compute an unsatisfiable core. It can be used in two different ways. In the incremental usage scenario, all information the solver has learned so far is retained. Methods for incremental solving start with 'inc'. Other methods (like <a class="el" href="classSatSolver.html#a82f60f60db464fbe5c66a20ad673a573" title="Checks if a CNF is satisfiable.">isSat()</a> or <a class="el" href="classSatSolver.html#ad5cfce08969be5aaf5cd705c12c68818" title="Checks if a CNF is satisfiable and extracts a model or an unsatisfiable core.">isSatModelOrCore()</a>) instantiate a fresh solver instance for every call.</p>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.1.0 </dd></dl>

<p>Definition at line <a class="el" href="SatSolver_8h_source.html#l00058">58</a> of file <a class="el" href="SatSolver_8h_source.html">SatSolver.h</a>.</p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2abb0a2a75d1c3559946956ac19dc89e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SatSolver::SatSolver </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rand_models</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_cores</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rand_models</td><td>A flag indicating if satisfying assignments should be randomized. This is done in a post-processing step (values are flipped randomly and then we check if this still constitutes a satisfying assignment). This is expensive. If this parameter is skipped, then satisfying assignments are not randomized. </td></tr>
    <tr><td class="paramname">min_cores</td><td>A flag indicating if unsatisfiable cores returned by the solver should be minimized further by trying to drop one literal after the other. This makes the calls slower but produces potentially smaller cubes. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SatSolver_8cpp_source.html#l00033">33</a> of file <a class="el" href="SatSolver_8cpp_source.html">SatSolver.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeefe936d75dbdca120805d650a12e989"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SatSolver::~SatSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="SatSolver_8cpp_source.html#l00041">41</a> of file <a class="el" href="SatSolver_8cpp_source.html">SatSolver.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0821aa3a3fababd9b070f758b6e788cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SatSolver::SatSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSatSolver.html">SatSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a8118d2900f7acf31497cd2a27ad3b713"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::clearIncrementalSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the solver instance that is used in the incremental session. </p>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a237754c78357ed0a84894e811806b618">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#ae53598723725fd3203e2e32411392dab">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a4200b2ca7b1694898434ae9764f5baf6">LingelingApi</a>.</p>

</div>
</div>
<a class="anchor" id="a159fc9658709e5aeba2844a09454b2cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SatSolver::doMinCores </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_cores</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the computation of MINIMAL unsatisfiable cores. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_cores</td><td>A flag indicating if unsatisfiable cores returned by the solver should be minimized further by trying to drop one literal after the other. This makes the calls slower but produces potentially smaller cubes. If the parameter is skipped the computation of minimal cores is enabled. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SatSolver_8cpp_source.html#l00047">47</a> of file <a class="el" href="SatSolver_8cpp_source.html">SatSolver.cpp</a>.</p>

<p>References <a class="el" href="SatSolver_8h_source.html#l00428">min_cores_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00180">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00328">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00508">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00359">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01172">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01379">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00527">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00715">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00947">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>.</p>

</div>
</div>
<a class="anchor" id="ae229c5e277350710412fce0e867dc566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SatSolver::doRandModels </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rand_models</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the randomization of satisfying assignments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rand_models</td><td>A flag indicating if satisfying assignments should be randomized. This is done in a post-processing step (values are flipped randomly and then we check if this still constitutes a satisfying assignment). This is expensive. If this parameter is skipped, then randomization is enabled. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SatSolver_8cpp_source.html#l00053">53</a> of file <a class="el" href="SatSolver_8cpp_source.html">SatSolver.cpp</a>.</p>

<p>References <a class="el" href="SatSolver_8h_source.html#l00433">rand_models_</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00180">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00328">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00508">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, and <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>.</p>

</div>
</div>
<a class="anchor" id="a791be541b59ef58a29a1c517fca943e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incAdd2LitClause </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lit1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lit2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new clause consisting of 2 literals to the current incremental session. </p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lit1</td><td>The first literal of the clause to add to the currently open incremental session. If this method is called after solving for the first time, be sure that the passed literal talks about a variables that have been mentioned in vars_to_keep when calling <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
    <tr><td class="paramname">lit2</td><td>The second literal of the clause to add to the currently open incremental session (must be contained in vars_to_keep as well). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a56c4758ee7466cd7fa48a682fee76fd3">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#a5c31301a2b0dfc70251f285e737a6fc2">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a54bf3198e6bb2dd3ebda768272337955">LingelingApi</a>.</p>

</div>
</div>
<a class="anchor" id="abca288874a1b8ab1a90cb274eb885ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incAdd3LitClause </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lit1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lit2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lit3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new clause consisting of 3 literals to the current incremental session. </p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lit1</td><td>The first literal of the clause to add to the currently open incremental session. If this method is called after solving for the first time, be sure that the passed literal talks about a variables that have been mentioned in vars_to_keep when calling <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
    <tr><td class="paramname">lit2</td><td>The second literal of the clause to add to the currently open incremental session (must be contained in vars_to_keep as well). </td></tr>
    <tr><td class="paramname">lit3</td><td>The third literal of the clause to add to the currently open incremental session (must be contained in vars_to_keep as well). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#aee9556c8c5de695fa5d7aa7cfde57877">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#a1daeb6e2b3bfa3eee44a7bf1b278dd86">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#ad05f795bbf472fe5386164a74a8ecd86">LingelingApi</a>.</p>

</div>
</div>
<a class="anchor" id="a9f91c104238b6e091513e0aa46970840"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incAddClause </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new clause to the current incremental session. </p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>The clause (a disjunction of literals) to add (conjunct) to the currently open incremental session. If this method is called after solving for the first time, be sure that the passed clause talks only about variables that have been mentioned in vars_to_keep when calling <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#af2115a84419b7480ff55b747f7ddd60a">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#aaafa1c5c7f1058029127a39a32ceada6">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#afb3e0d0ab541b89ef6c281145f53105f">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00351">IFM13Synth::addBlockedState()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01670">IFM13Explorer::addBlockedState()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00336">IFM13Synth::addBlockedTransition()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01655">IFM13Explorer::addBlockedTransition()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00405">IFM13Synth::addLose()</a>, <a class="el" href="Utils_8cpp_source.html#l00287">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">LearnSynthQBF::computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00204">LearnSynthQBF::computeWinningRegionOneSAT()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00180">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00328">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00508">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00177">IFM13Synth::propagateBlockedStates()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01474">IFM13Explorer::propagateBlockedStates()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2581b192cb2c39a81a416a9f7416c9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incAddCNF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>cnf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> to the current incremental session. </p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> to add to the currently open incremental session. If this method is called after solving for the first time, be sure that the passed <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> talks only about variables that have been mentioned in vars_to_keep when calling <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#ae5ffe2811e01051c5206c9e4865a7102">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#a619b3cb3b059b06c34f84d9ae123c042">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#ae9e54e64007c98add90e142a5c38d4bc">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01152">CounterGenSAT::compressBored()</a>, <a class="el" href="Utils_8cpp_source.html#l00287">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">LearnSynthQBF::computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00180">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00328">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00508">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00775">ClauseExplorerSAT::considerNewInfoFromOthers()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01210">CounterGenSAT::considerNewInfoFromOthers()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01463">IFM13Explorer::considerNewInfoFromOthers()</a>, <a class="el" href="Utils_8cpp_source.html#l00417">Utils::debugCheckWinReg()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01356">IFM13Explorer::IFM13Explorer()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth::IFM13Synth()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF::LearnSynthQBF()</a>, <a class="el" href="Utils_8cpp_source.html#l00353">Utils::negateStateCNF()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00359">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01172">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01379">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00527">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00715">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00947">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f04f34bb04174489ed18d0b62241004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incAddCube </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new cube to the current incremental session. </p>
<p>That is, all literals of the cube are added as unit clauses to the current incremental session. For instance, if the cube [2, -4, 8] is passed as argument, then this method adds the three unit clauses [2], [-4], [8].</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube</td><td>The cube (a conjunction of literals) to add (conjunct) to the currently open incremental session. All literals of this cube will be added as unit clauses. If this method is called after solving for the first time, be sure that the passed clause talks only about variables that have been mentioned in vars_to_keep when calling <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a41e16a2e8757846fa17e010c5cc1ff16">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#ae0a7dd7da9ead164560f454e29457453">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a6dc0eb0582d6afda381fc05a5820433c">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01080">CounterGenSAT::generalizeCeFuther()</a>.</p>

</div>
</div>
<a class="anchor" id="a6be2c564289a59057c4c6728a3aa9c2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incAddNegCubeAsClause </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the negation of a given cube (which is a clause) to the incremental session. </p>
<p>For instance, if the cube [2, -4, 8] is passed as argument, then this method adds the clauses [-2, 4, -8] to the current incremental session.</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube</td><td>The cube (a conjunction of literals) to negate and add (conjunct) to the currently open incremental session. If this method is called after solving for the first time, be sure that the passed cube talks only about variables that have been mentioned in vars_to_keep when calling <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a49afe5c41bb036a31f65f98621e82846">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#ace9bfbd0c8cbd62c3e92d2b208bb7b66">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#afefd24f97e49aed7cbaf25140a6b7741">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01152">CounterGenSAT::compressBored()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00328">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00508">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="Utils_8cpp_source.html#l00417">Utils::debugCheckWinReg()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01080">CounterGenSAT::generalizeCeFuther()</a>, <a class="el" href="Utils_8cpp_source.html#l00353">Utils::negateStateCNF()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00359">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01172">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01379">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00527">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00715">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00947">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b39c45cd2a1abfe96c681515dfddb77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incAddUnitClause </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new unit clause to the current incremental session. </p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lit</td><td>The (one and only) literal of the unit clause to add to the currently open incremental session. If this method is called after solving for the first time, be sure that the passed literal talks about a variables that have been mentioned in vars_to_keep when calling <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#ade09bb38667bb23f2ac993e2d6c66408">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#a0ef01830dacfd23f63928b44ff3df788">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#aa5c928ad16d2dc79d42b977237d377e0">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00359">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00527">LearningImplExtractor::runLearningJiangSATTmp()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00715">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1aab4b96a36b2003450067a3799ae23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SatSolver::incIsSat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> in the incremental session is satisfiable. </p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of satisfiability, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a4c6ba65381002eb3f90e8e0df1606759">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#a0d1237c039315d572fb0828c59435177">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a7a96e3b1078e40305f8b5e329f0a1e26">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00351">IFM13Synth::addBlockedState()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01670">IFM13Explorer::addBlockedState()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01123">CounterGenSAT::bored()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01152">CounterGenSAT::compressBored()</a>, <a class="el" href="Utils_8cpp_source.html#l00287">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01080">CounterGenSAT::generalizeCeFuther()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00177">IFM13Synth::propagateBlockedStates()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01474">IFM13Explorer::propagateBlockedStates()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00359">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01172">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01379">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00527">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00715">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00947">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>.</p>

</div>
</div>
<a class="anchor" id="a1864787a33621efac7fc75fb6b25f080"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SatSolver::incIsSat </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>assumptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> in the incremental session is satisfiable under assumptions. </p>
<p>This method checks if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> in the incremental session is satisfiable given that all literals passed in the vector 'assumptions' are true. The assumptions are not persistently added to the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> of the incremental session.</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a> must have been called before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumptions</td><td>A vector of literals. This method then checks if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> of the incremental session is satisfiable given that all literals passed in this vector are true. The assumptions are not persistently added to the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. The assumptions must be a subset of the vars_to_keep passed to <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of satisfiability, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a40421bac2739bacb68f3c7083810694b">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#abebe28c72303235d2fdc915bbf4752c0">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a192ddd0f1d27617570c759b3496ea90d">LingelingApi</a>.</p>

</div>
</div>
<a class="anchor" id="ad387fc06bacf2d48847f779c9db8461a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SatSolver::incIsSatModelOrCore </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars_of_interest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_or_core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> in the incremental session and computes a model or unsat core. </p>
<p>This method checks if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> of the incremental session is satisfiable given that all literals passed in the vector 'assumptions' is true. If this is the case, then a satisfying assignment will be written into model_or_core. You can specify which variables you want to have in the satisfying assignment using the vars_of_interest vector. The reason is that your <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> may contain thousands of temporary variables stemming from some Tseitin encoding, but usually one in only interested in the value of a few variables. In case of unsatisfiability, an unsatisfiable core is stored in model_or_core. The unsatisfiable core is a subset of the literals passed in 'assumptions' such that the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is still unsatisfiable when these literals hold.</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumptions</td><td>A vector of literals. This method then checks if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> of the incremental session is satisfiable given that all literals passed in this vector are true. The assumptions are not persistently added to the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. The assumptions must be a subset of the vars_to_keep passed to <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
    <tr><td class="paramname">vars_of_interest</td><td>The variables for which you want to have a value in case of satisfiability. vars_of_interest must be a subset of the vars_to_keep passed to <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
    <tr><td class="paramname">model_or_core</td><td>An empty vector. Depending on the outcome of the call, either a satisfying assignment (a cube over the variables passed in vars_of_interest) or an unsatisfiable core (a subset of the literals passed in 'assumptions') will be written into this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of satisfiability (of the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> of the incremental session in conjunction conjuncted with all assumptions), false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#afb886d40bb45b5cf2fadb7aee1a06b3e">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#aa8c0dbf4587ff4666ce20fd325364c4a">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a5f70806ab80cb622f4f7286f66284c4e">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="Utils_8cpp_source.html#l00287">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">LearnSynthQBF::computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00180">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00328">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00508">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="Utils_8cpp_source.html#l00417">Utils::debugCheckWinReg()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00422">IFM13Synth::genAndBlockTrans()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01743">IFM13Explorer::genAndBlockTrans()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01080">CounterGenSAT::generalizeCeFuther()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01065">CounterGenSAT::generalizeCounterexample()</a>, <a class="el" href="Utils_8cpp_source.html#l00353">Utils::negateStateCNF()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00229">IFM13Synth::recBlockCube()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01531">IFM13Explorer::recBlockCube()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00359">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01172">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01379">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00527">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00715">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00947">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>.</p>

</div>
</div>
<a class="anchor" id="a29225bfab1f352cae27c68e9bda4d409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SatSolver::incIsSatModelOrCore </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>more_assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars_of_interest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_or_core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a satisfying assignment or core using additional assumptions. </p>
<p>In contrast to the previous method, this one allows to define two sets of assumptions. The core_assumptions are used as basis for extracting an unsatisfiable core in case of unsatisfiability. The more_assumptions are assumed but not considered for the computation of unsatisfiable cores. This is convenient to avoid calls to <a class="el" href="classSatSolver.html#a4da0dff7082a91429e3311d279605be4" title="Stores the current state of the incremental session on a stack.">incPush()</a> and <a class="el" href="classSatSolver.html#a436aae045eb04141c834df0b55947ee5" title="Restores the incremental session back to the point where incPush() was called.">incPop()</a> when temporarily working under assumptions that should not be minimized for the unsatisfiable core.</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core_assumptions</td><td>A vector of literals. This method then checks if the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> of the incremental session is satisfiable given that all literals passed in this vector and all literals passed in more_assumptions are true. However, for computing the the unsatisfiable core, only the core_assumptions will be minimized and the more_assumptions stay as they are. That is, in case of unsatisfiability, model_or_core will contain a subset X of the core_assumptions such that X &amp; more_assumptions &amp; incremental_cnf is still unsatisfiable. core_assumptions must be a subset of the vars_to_keep passed to <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
    <tr><td class="paramname">more_assumptions</td><td>A vector of assumptions that are assumed, but not minimized when an unsatisfiable core is computed. That is, in case of unsatisfiability, model_or_core will contain a subset X of the core_assumptions such that X &amp; more_assumptions &amp; incremental_cnf is still unsatisfiable. more_assumptions must be a subset of the vars_to_keep passed to <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
    <tr><td class="paramname">vars_of_interest</td><td>The variables for which you want to have a value in case of satisfiability. vars_of_interest must be a subset of the vars_to_keep passed to <a class="el" href="classSatSolver.html#a74603f84c3f2383a5fc44d5a8093cbea" title="Starts a new incremental session.">startIncrementalSession()</a>. </td></tr>
    <tr><td class="paramname">model_or_core</td><td>An empty vector. Depending on the outcome of the call, either a satisfying assignment (a cube over the variables passed in vars_of_interest) or an unsatisfiable core (a subset of the literals passed in 'core_assumptions') will be written into this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of satisfiability (of the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> of the incremental session in conjunction conjuncted with all assumptions), false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a776b2b0563b52f52152dcec931b7f557">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#ada5b2d2ba3cf20b0ab007a62cc73028a">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a95680a60e64dccddbe007ef7d4c8a960">LingelingApi</a>.</p>

</div>
</div>
<a class="anchor" id="a436aae045eb04141c834df0b55947ee5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incPop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores the incremental session back to the point where <a class="el" href="classSatSolver.html#a4da0dff7082a91429e3311d279605be4" title="Stores the current state of the incremental session on a stack.">incPush()</a> was called. </p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface). </p>

<p>Implemented in <a class="el" href="classMiniSatApi.html#af388f97db15f77baeb420a8fef74ca6a">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#a045c7a5229d4e45095922e1315c5c282">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#afe43e1243338a332803fff470eedbf7a">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01080">CounterGenSAT::generalizeCeFuther()</a>.</p>

</div>
</div>
<a class="anchor" id="a4da0dff7082a91429e3311d279605be4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::incPush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the current state of the incremental session on a stack. </p>
<p>The state can be restored later by calling <a class="el" href="classSatSolver.html#a436aae045eb04141c834df0b55947ee5" title="Restores the incremental session back to the point where incPush() was called.">incPop()</a>.</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface). </p>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a27013ace25320f68252bef5ba9f2e9ad">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#a523f9de3a59f927cb6ad0729e1caaac7">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a91c858d2a36a4fbe580909a793802a76">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01080">CounterGenSAT::generalizeCeFuther()</a>.</p>

</div>
</div>
<a class="anchor" id="a82f60f60db464fbe5c66a20ad673a573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SatSolver::isSat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>cnf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is satisfiable. </p>
<p>This method is not incremental. At aver call to this method, a new solver instance is created and deleted afterwards. This method does not interfere with an incremental session that may be open in parallel.</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> formula for which we want to know if it is satisfiable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of satisfiability, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a73b93ecb947723a96ef6fbd436640e12">MiniSatApi</a>, <a class="el" href="classLingelingApi.html#a38358f64ded244e2e3d843d0565f0177">LingelingApi</a>, and <a class="el" href="classPicoSatApi.html#a46ea721c61e298d87403476607ba9fe6">PicoSatApi</a>.</p>

<p>Referenced by <a class="el" href="IFM13Synth_8cpp_source.html#l00502">IFM13Synth::debugCheckInvariants()</a>, <a class="el" href="Utils_8cpp_source.html#l00417">Utils::debugCheckWinReg()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01295">ClauseMinimizerQBF::minimizeClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5cfce08969be5aaf5cd705c12c68818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SatSolver::isSatModelOrCore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>cnf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars_of_interest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_or_core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is satisfiable and extracts a model or an unsatisfiable core. </p>
<p>This method is not incremental. At aver call to this method, a new solver instance is created and deleted afterwards. This method does not interfere with an incremental session that may be open in parallel. This method checks if the passed <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is satisfiable given that all literals passed in the vector 'assumptions' is true. If this is the case, then a satisfying assignment will be written into model_or_core. You can specify which variables you want to have in the satisfying assignment using the vars_of_interest vector. The reason is that you <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> may contain thousands of temporary variables stemming from some Tseitin encoding, but usually one in only interested in the value of a few variables. In case of unsatisfiability, an unsatisfiable core is stored in model_or_core. The unsatisfiable core is a subset of the literals passed in 'assumptions' such that the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is still unsatisfiable when these literals hold.</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf</td><td>The <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> formula for which we want to know if it is satisfiable (in conjunction with the assumptions). </td></tr>
    <tr><td class="paramname">assumptions</td><td>A vector of literals. These literals are conjuncted to the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> before solving. If you do not have any assumptions but want to decide the satisfiability of the cnf only, then simply leave this vector empty. </td></tr>
    <tr><td class="paramname">vars_of_interest</td><td>The variables for which you want to have a value in case of satisfiability. </td></tr>
    <tr><td class="paramname">model_or_core</td><td>An empty vector. Depending on the outcome of the call, either a satisfying assignment (a cube over the variables passed in vars_of_interest) or an unsatisfiable core (a subset of the literals passed in 'assumptions') will be written into this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of satisfiability (of the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> conjuncted with all assumptions), false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#a7f846d8c4a5a652cb83460852c09dfb3">MiniSatApi</a>, <a class="el" href="classLingelingApi.html#a8f147b59f0ebabc35a20d295f28d499f">LingelingApi</a>, and <a class="el" href="classPicoSatApi.html#a00dda1bd348d46bbfbf506f7735946da">PicoSatApi</a>.</p>

</div>
</div>
<a class="anchor" id="a9dc824ecbeaf4f0505403b284f6fe047"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSatSolver.html">SatSolver</a>&amp; SatSolver::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSatSolver.html">SatSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="a74603f84c3f2383a5fc44d5a8093cbea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SatSolver::startIncrementalSession </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars_to_keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_push</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a new incremental session. </p>
<p>Every instance of this class can have at most one open incremental session. If there is an old open incremental session it will be closed before. An incremental session allows you to execute sequences of calls, where the information the solver learned in previous calls is retained and may speedup later calls. You can add new clauses between calls, but you cannot remove clauses.</p>
<p>This is an abstract method which must be implemented in all derived classes (all classes implementing this interface).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars_to_keep</td><td>A set of variables the solver should not optimize away. Clauses added later in an incremental session can only talk about variables contained in this vector. </td></tr>
    <tr><td class="paramname">use_push</td><td>A hint to the solver if you are ever going to use <a class="el" href="classSatSolver.html#a4da0dff7082a91429e3311d279605be4" title="Stores the current state of the incremental session on a stack.">incPush()</a> or <a class="el" href="classSatSolver.html#a436aae045eb04141c834df0b55947ee5" title="Restores the incremental session back to the point where incPush() was called.">incPop()</a>. Some solver implementations (like <a class="el" href="classMiniSatApi.html" title="Interfaces the MiniSat SAT-solver via its API.">MiniSatApi</a>) do not support push and and pop natively, so we have to make a workaround. This workaround is expensive and we can safe some computation time if we skip it when we will not need it. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMiniSatApi.html#afe6f184e440ffe7f9b3a86045c15b450">MiniSatApi</a>, <a class="el" href="classPicoSatApi.html#a5e32634944d14142ab0e2c4fdeb12d85">PicoSatApi</a>, and <a class="el" href="classLingelingApi.html#a844da6cbdf38b7cc8abd0b1710350be2">LingelingApi</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01152">CounterGenSAT::compressBored()</a>, <a class="el" href="Utils_8cpp_source.html#l00287">Utils::compressStateCNF()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00345">LearnSynthQBF::computeCounterexampleSAT()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00180">LearnSynthSAT::computeWinningRegionPlain()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00328">LearnSynthSAT::computeWinningRegionPlainDep()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00508">LearnSynthSAT::computeWinningRegionPlainDep2()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00759">LearnSynthSAT::computeWinningRegionRG()</a>, <a class="el" href="LearnSynthSAT_8cpp_source.html#l00943">LearnSynthSAT::computeWinningRegionRGRC()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00775">ClauseExplorerSAT::considerNewInfoFromOthers()</a>, <a class="el" href="Utils_8cpp_source.html#l00417">Utils::debugCheckWinReg()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01356">IFM13Explorer::IFM13Explorer()</a>, <a class="el" href="IFM13Synth_8cpp_source.html#l00054">IFM13Synth::IFM13Synth()</a>, <a class="el" href="LearnSynthQBF_8cpp_source.html#l00040">LearnSynthQBF::LearnSynthQBF()</a>, <a class="el" href="Utils_8cpp_source.html#l00353">Utils::negateStateCNF()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00359">LearningImplExtractor::runLearningJiangSAT()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01172">LearningImplExtractor::runLearningJiangSATInc1()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l01379">LearningImplExtractor::runLearningJiangSATInc2()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00527">LearningImplExtractor::runLearningJiangSATTmp()</a>, <a class="el" href="LearningImplExtractor_8cpp_source.html#l00715">LearningImplExtractor::runLearningJiangSATTmpCtrl()</a>, and <a class="el" href="LearningImplExtractor_8cpp_source.html#l00947">LearningImplExtractor::runLearningJiangSATTmpCtrlInc2()</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="adfeecebfd09606c82b5c57cfe5aad813"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SatSolver::min_cores_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if the unsat cores returned by the solver should be minimized further. </p>

<p>Definition at line <a class="el" href="SatSolver_8h_source.html#l00428">428</a> of file <a class="el" href="SatSolver_8h_source.html">SatSolver.h</a>.</p>

<p>Referenced by <a class="el" href="SatSolver_8cpp_source.html#l00047">doMinCores()</a>, <a class="el" href="LingelingApi_8cpp_source.html#l00264">LingelingApi::incIsSatModelOrCore()</a>, <a class="el" href="PicoSatApi_8cpp_source.html#l00255">PicoSatApi::incIsSatModelOrCore()</a>, <a class="el" href="MiniSatApi_8cpp_source.html#l00331">MiniSatApi::incIsSatModelOrCore()</a>, <a class="el" href="LingelingApi_8cpp_source.html#l00072">LingelingApi::isSatModelOrCore()</a>, <a class="el" href="PicoSatApi_8cpp_source.html#l00073">PicoSatApi::isSatModelOrCore()</a>, and <a class="el" href="MiniSatApi_8cpp_source.html#l00144">MiniSatApi::isSatModelOrCore()</a>.</p>

</div>
</div>
<a class="anchor" id="a73fed24d8fb4da85ef82dc53ac5f28c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SatSolver::rand_models_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if satisfying assignments should be randomized. </p>

<p>Definition at line <a class="el" href="SatSolver_8h_source.html#l00433">433</a> of file <a class="el" href="SatSolver_8h_source.html">SatSolver.h</a>.</p>

<p>Referenced by <a class="el" href="SatSolver_8cpp_source.html#l00053">doRandModels()</a>, <a class="el" href="LingelingApi_8cpp_source.html#l00264">LingelingApi::incIsSatModelOrCore()</a>, <a class="el" href="PicoSatApi_8cpp_source.html#l00255">PicoSatApi::incIsSatModelOrCore()</a>, <a class="el" href="MiniSatApi_8cpp_source.html#l00331">MiniSatApi::incIsSatModelOrCore()</a>, <a class="el" href="LingelingApi_8cpp_source.html#l00072">LingelingApi::isSatModelOrCore()</a>, <a class="el" href="PicoSatApi_8cpp_source.html#l00073">PicoSatApi::isSatModelOrCore()</a>, and <a class="el" href="MiniSatApi_8cpp_source.html#l00144">MiniSatApi::isSatModelOrCore()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="SatSolver_8h_source.html">SatSolver.h</a></li>
<li>src/<a class="el" href="SatSolver_8cpp_source.html">SatSolver.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 15 2014 12:30:23 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
