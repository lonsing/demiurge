<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>demiurge: ParallelLearner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">demiurge
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">A synthesis tool for safety specifications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classParallelLearner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ParallelLearner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The coordinator of the parallelized implementation.  
 <a href="classParallelLearner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ParallelLearner:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classParallelLearner.png" usemap="#ParallelLearner_map" alt=""/>
  <map id="ParallelLearner_map" name="ParallelLearner_map">
<area href="classBackEnd.html" title="An interface for the back-ends." alt="BackEnd" shape="rect" coords="0,0,100,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af19878077a2dff8ade1de01be095137d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#af19878077a2dff8ade1de01be095137d">ParallelLearner</a> (size_t nr_of_threads, <a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *impl_extractor)</td></tr>
<tr class="memdesc:af19878077a2dff8ade1de01be095137d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af19878077a2dff8ade1de01be095137d"></a><br/></td></tr>
<tr class="memitem:a42d85a531cab28bdcb345c37a0b08730"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a42d85a531cab28bdcb345c37a0b08730">~ParallelLearner</a> ()</td></tr>
<tr class="memdesc:a42d85a531cab28bdcb345c37a0b08730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desctructor.  <a href="#a42d85a531cab28bdcb345c37a0b08730"></a><br/></td></tr>
<tr class="memitem:a93acb74e7c8504d0ef2bd3697441b745"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a93acb74e7c8504d0ef2bd3697441b745">run</a> ()</td></tr>
<tr class="memdesc:a93acb74e7c8504d0ef2bd3697441b745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the back-end.  <a href="#a93acb74e7c8504d0ef2bd3697441b745"></a><br/></td></tr>
<tr class="memitem:a10b8346745051c95f05a1bc8356fcf8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a10b8346745051c95f05a1bc8356fcf8d">notifyNewWinRegClause</a> (const vector&lt; int &gt; &amp;clause, int src)</td></tr>
<tr class="memdesc:a10b8346745051c95f05a1bc8356fcf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all worker-threads that a new clause of the winning region is available.  <a href="#a10b8346745051c95f05a1bc8356fcf8d"></a><br/></td></tr>
<tr class="memitem:a0a8405e4fb7331f3f3df2711fdaebdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a0a8405e4fb7331f3f3df2711fdaebdab">notifyNewUselessInputClause</a> (const vector&lt; int &gt; &amp;clause, int level)</td></tr>
<tr class="memdesc:a0a8405e4fb7331f3f3df2711fdaebdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all ClauseExplorerSAT-threads that a new U-clause is available.  <a href="#a0a8405e4fb7331f3f3df2711fdaebdab"></a><br/></td></tr>
<tr class="memitem:a8c59cc455059943f8f9cdb8a60526f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a8c59cc455059943f8f9cdb8a60526f5c">notifyNewCounterexample</a> (const vector&lt; int &gt; &amp;ce, const vector&lt; int &gt; &amp;gen)</td></tr>
<tr class="memdesc:a8c59cc455059943f8f9cdb8a60526f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new counterexample to the <a class="el" href="classParallelLearner.html" title="The coordinator of the parallelized implementation.">ParallelLearner</a>'s database.  <a href="#a8c59cc455059943f8f9cdb8a60526f5c"></a><br/></td></tr>
<tr class="memitem:a2b8e4330afb7e99c19d2d7da15c30cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a2b8e4330afb7e99c19d2d7da15c30cc3">triggerExplorerRestart</a> ()</td></tr>
<tr class="memdesc:a2b8e4330afb7e99c19d2d7da15c30cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a new restart point and notifies it to all ClauseExplorerSAT-instances.  <a href="#a2b8e4330afb7e99c19d2d7da15c30cc3"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a757f8817809cce5c0408cdc41d6db1b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a757f8817809cce5c0408cdc41d6db1b8">result_</a></td></tr>
<tr class="memdesc:a757f8817809cce5c0408cdc41d6db1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer number containing the realizability verdict.  <a href="#a757f8817809cce5c0408cdc41d6db1b8"></a><br/></td></tr>
<tr class="memitem:a7c8383543ff98d7a0356a237756dcdd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a7c8383543ff98d7a0356a237756dcdd6">winning_region_</a></td></tr>
<tr class="memdesc:a7c8383543ff98d7a0356a237756dcdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current version of the winning region.  <a href="#a7c8383543ff98d7a0356a237756dcdd6"></a><br/></td></tr>
<tr class="memitem:a196a4500dfd66a4b9110659b4a10dead"><td class="memItemLeft" align="right" valign="top">mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a196a4500dfd66a4b9110659b4a10dead">winning_region_lock_</a></td></tr>
<tr class="memdesc:a196a4500dfd66a4b9110659b4a10dead"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock that protects the <a class="el" href="classParallelLearner.html#a7c8383543ff98d7a0356a237756dcdd6" title="The current version of the winning region.">winning_region_</a> from race-conditions.  <a href="#a196a4500dfd66a4b9110659b4a10dead"></a><br/></td></tr>
<tr class="memitem:aba6b363071d9a39d7b368cec5b629c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#aba6b363071d9a39d7b368cec5b629c25">unminimized_clauses_</a></td></tr>
<tr class="memdesc:aba6b363071d9a39d7b368cec5b629c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">All clauses of the winning region that have not yet been minimized.  <a href="#aba6b363071d9a39d7b368cec5b629c25"></a><br/></td></tr>
<tr class="memitem:aa16d364d9fdd0c2fe5180ee1b023a4ec"><td class="memItemLeft" align="right" valign="top">mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#aa16d364d9fdd0c2fe5180ee1b023a4ec">unminimized_clauses_lock_</a></td></tr>
<tr class="memdesc:aa16d364d9fdd0c2fe5180ee1b023a4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock that protects the <a class="el" href="classParallelLearner.html#aba6b363071d9a39d7b368cec5b629c25" title="All clauses of the winning region that have not yet been minimized.">unminimized_clauses_</a> from race-conditions.  <a href="#aa16d364d9fdd0c2fe5180ee1b023a4ec"></a><br/></td></tr>
<tr class="memitem:a974943e3e2145b3407f689b64acdd33f"><td class="memItemLeft" align="right" valign="top">list&lt; pair&lt; vector&lt; int &gt;<br class="typebreak"/>
, vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a974943e3e2145b3407f689b64acdd33f">counterexamples_</a></td></tr>
<tr class="memdesc:a974943e3e2145b3407f689b64acdd33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counterexample-cubes together with their computed generalizations.  <a href="#a974943e3e2145b3407f689b64acdd33f"></a><br/></td></tr>
<tr class="memitem:a454c81908f2d3cb4c24b042739adc4ec"><td class="memItemLeft" align="right" valign="top">mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a454c81908f2d3cb4c24b042739adc4ec">counterexamples_lock_</a></td></tr>
<tr class="memdesc:a454c81908f2d3cb4c24b042739adc4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock that protects the <a class="el" href="classParallelLearner.html#a974943e3e2145b3407f689b64acdd33f" title="The counterexample-cubes together with their computed generalizations.">counterexamples_</a> from race-conditions.  <a href="#a454c81908f2d3cb4c24b042739adc4ec"></a><br/></td></tr>
<tr class="memitem:abdd409a5ef29bd4ba6b7213e9d4a067b"><td class="memItemLeft" align="right" valign="top">mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#abdd409a5ef29bd4ba6b7213e9d4a067b">var_man_lock_</a></td></tr>
<tr class="memdesc:abdd409a5ef29bd4ba6b7213e9d4a067b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock that must be hold when the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created.">VarManager</a> is modified.  <a href="#abdd409a5ef29bd4ba6b7213e9d4a067b"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5bc71a2c35fa976d792bf0e80de31a39"><td class="memItemLeft" align="right" valign="top">static mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a5bc71a2c35fa976d792bf0e80de31a39">print_lock_</a></td></tr>
<tr class="memdesc:a5bc71a2c35fa976d792bf0e80de31a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock used to synchronize the printing of debugging messages.  <a href="#a5bc71a2c35fa976d792bf0e80de31a39"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2b87f1f2526786a4402d695026272d33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a2b87f1f2526786a4402d695026272d33">computePreviousTrans</a> ()</td></tr>
<tr class="memdesc:a2b87f1f2526786a4402d695026272d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to compute the previous-state copy of the transition relation.  <a href="#a2b87f1f2526786a4402d695026272d33"></a><br/></td></tr>
<tr class="memitem:aa97595b50d1bba411824c2a60337e081"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#aa97595b50d1bba411824c2a60337e081">presentToPrevious</a> (int literal) const </td></tr>
<tr class="memdesc:aa97595b50d1bba411824c2a60337e081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the previous-state copy of a literal.  <a href="#aa97595b50d1bba411824c2a60337e081"></a><br/></td></tr>
<tr class="memitem:ae3330a141c8ba3ca7c5687824dbf4edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#ae3330a141c8ba3ca7c5687824dbf4edc">presentToPrevious</a> (vector&lt; int &gt; &amp;cube_or_clause) const </td></tr>
<tr class="memdesc:ae3330a141c8ba3ca7c5687824dbf4edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the previous-state copy of a cube or clause.  <a href="#ae3330a141c8ba3ca7c5687824dbf4edc"></a><br/></td></tr>
<tr class="memitem:acce71499ce9d8672116139f231376151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#acce71499ce9d8672116139f231376151">presentToPrevious</a> (<a class="el" href="classCNF.html">CNF</a> &amp;cnf) const </td></tr>
<tr class="memdesc:acce71499ce9d8672116139f231376151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the previous-state copy of a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>.  <a href="#acce71499ce9d8672116139f231376151"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aebaf891aada574da650732795f041dbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#aebaf891aada574da650732795f041dbe">use_ind_</a></td></tr>
<tr class="memdesc:aebaf891aada574da650732795f041dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating if optimization RG should be used.  <a href="#aebaf891aada574da650732795f041dbe"></a><br/></td></tr>
<tr class="memitem:a170a0abad017845877039684507e7a66"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a170a0abad017845877039684507e7a66">nr_of_threads_</a></td></tr>
<tr class="memdesc:a170a0abad017845877039684507e7a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of threads to instantiate and execute.  <a href="#a170a0abad017845877039684507e7a66"></a><br/></td></tr>
<tr class="memitem:a0e8b5dd12c8ae14089d3ce3117da3c16"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classClauseExplorerSAT.html">ClauseExplorerSAT</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a0e8b5dd12c8ae14089d3ce3117da3c16">clause_explorers_</a></td></tr>
<tr class="memdesc:a0e8b5dd12c8ae14089d3ce3117da3c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ClauseExplorerSAT-instances to execute in a separate thread.  <a href="#a0e8b5dd12c8ae14089d3ce3117da3c16"></a><br/></td></tr>
<tr class="memitem:a614707a21f36d75a9fd06be57ee421d0"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classIFM13Explorer.html">IFM13Explorer</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a614707a21f36d75a9fd06be57ee421d0">ifm_explorers_</a></td></tr>
<tr class="memdesc:a614707a21f36d75a9fd06be57ee421d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IFM13Explorer-instances to execute in a separate thread.  <a href="#a614707a21f36d75a9fd06be57ee421d0"></a><br/></td></tr>
<tr class="memitem:adb5aa1e016e04c607073eaf90d994dc7"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classClauseMinimizerQBF.html">ClauseMinimizerQBF</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#adb5aa1e016e04c607073eaf90d994dc7">clause_minimizers_</a></td></tr>
<tr class="memdesc:adb5aa1e016e04c607073eaf90d994dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ClauseMinimizerQBF-instances to execute in a separate thread.  <a href="#adb5aa1e016e04c607073eaf90d994dc7"></a><br/></td></tr>
<tr class="memitem:a46cc16764d7ea8ffafe8d1b696c35df3"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classCounterGenSAT.html">CounterGenSAT</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a46cc16764d7ea8ffafe8d1b696c35df3">ce_generalizers_</a></td></tr>
<tr class="memdesc:a46cc16764d7ea8ffafe8d1b696c35df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CounterGenSAT-instances to execute in a separate thread.  <a href="#a46cc16764d7ea8ffafe8d1b696c35df3"></a><br/></td></tr>
<tr class="memitem:abfb2e28ec1a0f8775d3f14f75415a8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLearnStatisticsSAT.html">LearnStatisticsSAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#abfb2e28ec1a0f8775d3f14f75415a8bd">statistics_</a></td></tr>
<tr class="memdesc:abfb2e28ec1a0f8775d3f14f75415a8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores and maintains statistics and performance measures.  <a href="#abfb2e28ec1a0f8775d3f14f75415a8bd"></a><br/></td></tr>
<tr class="memitem:ac73d9338262855f61f23a65d1df0647c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNF.html">CNF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#ac73d9338262855f61f23a65d1df0647c">prev_trans_or_initial_</a></td></tr>
<tr class="memdesc:ac73d9338262855f61f23a65d1df0647c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Says: the current state is initial or the previous transition relation holds.  <a href="#ac73d9338262855f61f23a65d1df0647c"></a><br/></td></tr>
<tr class="memitem:a6f8dfda6aa8640345057023ed85882b9"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a6f8dfda6aa8640345057023ed85882b9">current_to_previous_map_</a></td></tr>
<tr class="memdesc:a6f8dfda6aa8640345057023ed85882b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from present-state variables to their previous-state copy.  <a href="#a6f8dfda6aa8640345057023ed85882b9"></a><br/></td></tr>
<tr class="memitem:ae9293a4afd3c52690bcac2ad03884121"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#ae9293a4afd3c52690bcac2ad03884121">current_state_is_initial_</a></td></tr>
<tr class="memdesc:ae9293a4afd3c52690bcac2ad03884121"><td class="mdescLeft">&#160;</td><td class="mdescRight">A literal that is true if the current state is initial and false otherwise.  <a href="#ae9293a4afd3c52690bcac2ad03884121"></a><br/></td></tr>
<tr class="memitem:a58b6113b54eb7c91bbf15546d575f5e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a58b6113b54eb7c91bbf15546d575f5e8">impl_extractor_</a></td></tr>
<tr class="memdesc:a58b6113b54eb7c91bbf15546d575f5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The engine to use for circuit extraction.  <a href="#a58b6113b54eb7c91bbf15546d575f5e8"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7857993d63e497f5c946030c3127a578"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a7857993d63e497f5c946030c3127a578">ParallelLearner</a> (const <a class="el" href="classParallelLearner.html">ParallelLearner</a> &amp;other)</td></tr>
<tr class="memdesc:a7857993d63e497f5c946030c3127a578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a7857993d63e497f5c946030c3127a578"></a><br/></td></tr>
<tr class="memitem:a870e6d78e50b8aed63555e797ff6cce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallelLearner.html">ParallelLearner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallelLearner.html#a870e6d78e50b8aed63555e797ff6cce4">operator=</a> (const <a class="el" href="classParallelLearner.html">ParallelLearner</a> &amp;other)</td></tr>
<tr class="memdesc:a870e6d78e50b8aed63555e797ff6cce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a870e6d78e50b8aed63555e797ff6cce4"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The coordinator of the parallelized implementation. </p>
<p>This class implements a parallelized version of the learning-based synthesis methods. The idea is to combine various different techniques to refine an over-approximation of the winning region with new clauses. There is a lot of flexibility to play with. We can have threads discovering new clauses with SAT- or QBF-based learning techniques, we can have threads minimizing existing clauses with a QBF solver, etc. All threads share a common clause database. If (new or refined) clauses are discovered, they are communicated to all threads such that all of them can benefit from the new clauses in the next call. The threads performing actual work are implemented in other classes. This class is just the coordinator which starts the worker-threads and forwards information about new clauses to the worker-threads.</p>
<p>The parallel implementation has two advantages. First, it exploits hardware parallelism (modern CPUs have many cores), which means (potentially) shorter computation times. Second, it is an easy way of combining different methods. With one thread, one would have come up with points where to switch from one method to the other and back. Hence, it may also be useful to use the parallelized implementation even if only one core is available.</p>
<p>The question which methods we should combine how in order to achieve the best speed-up is not yet fully solved. This class is just one attempt, and can be seen as a playground for combining different methods.</p>
<dl class="section author"><dt>Author</dt><dd>Robert Koenighofer (<a href="#" onclick="location.href='mai'+'lto:'+'rob'+'er'+'t.k'+'oe'+'nig'+'ho'+'fer'+'@i'+'aik'+'.t'+'ugr'+'az'+'.at'; return false;">rober<span style="display: none;">.nosp@m.</span>t.ko<span style="display: none;">.nosp@m.</span>enigh<span style="display: none;">.nosp@m.</span>ofer<span style="display: none;">.nosp@m.</span>@iaik<span style="display: none;">.nosp@m.</span>.tug<span style="display: none;">.nosp@m.</span>raz.a<span style="display: none;">.nosp@m.</span>t</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.1.0 </dd></dl>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00078">78</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af19878077a2dff8ade1de01be095137d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParallelLearner::ParallelLearner </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr_of_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a> *&#160;</td>
          <td class="paramname"><em>impl_extractor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr_of_threads</td><td>The number of threads to create. This does not have to be the number of cores in your CPU. It can also make sense to combine several methods running in several threads on one single core. The methods can complement each other and achieve a speedup compared to one single method in isolation. </td></tr>
    <tr><td class="paramname">impl_extractor</td><td>The engine to use for circuit extraction. It will be deleted by this class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00116">116</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="ParallelLearner_8h_source.html#l00333">ce_generalizers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00318">clause_explorers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00328">clause_minimizers_</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00407">computePreviousTrans()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00361">current_state_is_initial_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00354">current_to_previous_map_</a>, <a class="el" href="Options_8cpp_source.html#l00390">Options::getBackEndMode()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00323">ifm_explorers_</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="defines_8h_source.html#l00059">MASSERT</a>, <a class="el" href="ParallelLearner_8h_source.html#l00349">prev_trans_or_initial_</a>, and <a class="el" href="ParallelLearner_8h_source.html#l00308">use_ind_</a>.</p>

</div>
</div>
<a class="anchor" id="a42d85a531cab28bdcb345c37a0b08730"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParallelLearner::~ParallelLearner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Desctructor. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00226">226</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="ParallelLearner_8h_source.html#l00333">ce_generalizers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00318">clause_explorers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00328">clause_minimizers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00323">ifm_explorers_</a>, and <a class="el" href="ParallelLearner_8h_source.html#l00368">impl_extractor_</a>.</p>

</div>
</div>
<a class="anchor" id="a7857993d63e497f5c946030c3127a578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParallelLearner::ParallelLearner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallelLearner.html">ParallelLearner</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a2b87f1f2526786a4402d695026272d33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParallelLearner::computePreviousTrans </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function to compute the previous-state copy of the transition relation. </p>
<p>This is needed if optimization RG is enabled (see <a class="el" href="classLearnSynthQBFInd.html" title="Implements a learning-based synthesis with inductive reachability reasoning.">LearnSynthQBFInd</a>). </p>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00407">407</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00177">CNF::add2LitClause()</a>, <a class="el" href="VarManager_8cpp_source.html#l00251">VarManager::createFreshPrevVar()</a>, <a class="el" href="VarManager_8cpp_source.html#l00219">VarManager::createFreshTmpVar()</a>, <a class="el" href="VarInfo_8h_source.html#l00074">VarInfo::CTRL</a>, <a class="el" href="ParallelLearner_8h_source.html#l00361">current_state_is_initial_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00354">current_to_previous_map_</a>, <a class="el" href="CNF_8cpp_source.html#l00346">CNF::getClauses()</a>, <a class="el" href="VarManager_8cpp_source.html#l00332">VarManager::getMaxCNFVar()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00210">AIG2CNF::getTrans()</a>, <a class="el" href="VarManager_8cpp_source.html#l00281">VarManager::getVarsOfType()</a>, <a class="el" href="VarInfo_8h_source.html#l00069">VarInfo::INPUT</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="VarInfo_8h_source.html#l00064">VarInfo::NEXT_STATE</a>, <a class="el" href="VarInfo_8h_source.html#l00059">VarInfo::PRES_STATE</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00444">presentToPrevious()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00349">prev_trans_or_initial_</a>, <a class="el" href="CNF_8cpp_source.html#l00286">CNF::swapWith()</a>, and <a class="el" href="VarInfo_8h_source.html#l00081">VarInfo::TMP</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c59cc455059943f8f9cdb8a60526f5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParallelLearner::notifyNewCounterexample </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new counterexample to the <a class="el" href="classParallelLearner.html" title="The coordinator of the parallelized implementation.">ParallelLearner</a>'s database. </p>
<p>A counterexample is a state-input combination with which the antagonist can enforce to leave the winning region. The counterexample is stored together with a generalization (some literals dropped) that has already been computed. This information can then be used by CounterGenSAT-threads. They take such a counterexample and compute all other generalizations (generalizations other than 'gen').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ce</td><td>This is a cube of the current-state variables and the uncontrollable inputs. With this state-input combination, the antagonist can enforce to leave the winning region. That is, there are no control-values such that the successor state is in the winning region again. </td></tr>
    <tr><td class="paramname">gen</td><td>One generalization of the counterexample. This is a subset of the literals of ce such that no control-values can lead to a successor state inside the winning region. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00370">370</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="ParallelLearner_8h_source.html#l00333">ce_generalizers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00239">counterexamples_</a>, and <a class="el" href="ParallelLearner_8h_source.html#l00247">counterexamples_lock_</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a8405e4fb7331f3f3df2711fdaebdab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParallelLearner::notifyNewUselessInputClause </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies all ClauseExplorerSAT-threads that a new U-clause is available. </p>
<p>In essence, the <a class="el" href="classClauseExplorerSAT.html" title="Implements the method of LearnSynthSAT in a parallelized way.">ClauseExplorerSAT</a> implements the same SAT-based learning method as <a class="el" href="classLearnSynthSAT.html" title="Implements a learning-based synthesis using two SAT solvers.">LearnSynthSAT</a>. It has just a few additional features which allow the implementation to communicate with others. A U-clause states that a certain state-input is useless for the antagonist in trying to leave the winning region (see <a class="el" href="classLearnSynthSAT.html" title="Implements a learning-based synthesis using two SAT solvers.">LearnSynthSAT</a> for details). If one <a class="el" href="classClauseExplorerSAT.html" title="Implements the method of LearnSynthSAT in a parallelized way.">ClauseExplorerSAT</a> discovers such a clause, it communicates it to all other ClauseExplorerSAT-instances such that they can also benefit from it and do not need to re-discover the same fact again. For that to work, all <a class="el" href="classClauseExplorerSAT.html" title="Implements the method of LearnSynthSAT in a parallelized way.">ClauseExplorerSAT</a> must be synchronized to a certain extend: All <a class="el" href="classClauseExplorerSAT.html" title="Implements the method of LearnSynthSAT in a parallelized way.">ClauseExplorerSAT</a> must do solver restarts simultaneously. We pass the restart-level (the number of restarts done so far) as additional parameter so that every ClauseExplorerSAT-instances can then decide if this clause is helpful for him, or already out-dated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>A new U-clause stating that a certain state-input is useless for the antagonist in trying to leave the winning region (see <a class="el" href="classLearnSynthSAT.html" title="Implements a learning-based synthesis using two SAT solvers.">LearnSynthSAT</a> for details). </td></tr>
    <tr><td class="paramname">level</td><td>The restart level (the number of solver restarts that have already been performed. This information allows the receiver instance to decide whether or not this clause is useful for her (or if it is already out-dated). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00358">358</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="ParallelLearner_8h_source.html#l00318">clause_explorers_</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="a10b8346745051c95f05a1bc8356fcf8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParallelLearner::notifyNewWinRegClause </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies all worker-threads that a new clause of the winning region is available. </p>
<p>It also adds this clause to our global clause database <a class="el" href="classParallelLearner.html#a7c8383543ff98d7a0356a237756dcdd6" title="The current version of the winning region.">winning_region_</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>The new clause that has been discovered. </td></tr>
    <tr><td class="paramname">src</td><td>An integer number defining which kind of worker-thread discovered the clause. Some worker-threads may treat clauses from different sources in a special way. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00328">328</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00146">CNF::addClauseAndSimplify()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00333">ce_generalizers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00318">clause_explorers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00328">clause_minimizers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00323">ifm_explorers_</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00091">MIN</a>, <a class="el" href="ParallelLearner_8h_source.html#l00218">unminimized_clauses_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00226">unminimized_clauses_lock_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00200">winning_region_</a>, and <a class="el" href="ParallelLearner_8h_source.html#l00208">winning_region_lock_</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01726">IFM13Explorer::addLose()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01123">CounterGenSAT::bored()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l01295">ClauseMinimizerQBF::minimizeClauses()</a>.</p>

</div>
</div>
<a class="anchor" id="a870e6d78e50b8aed63555e797ff6cce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallelLearner.html">ParallelLearner</a>&amp; ParallelLearner::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallelLearner.html">ParallelLearner</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The assignment operator is disabled (set private) and not implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source for creating the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment, i.e, *this. </dd></dl>

</div>
</div>
<a class="anchor" id="aa97595b50d1bba411824c2a60337e081"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParallelLearner::presentToPrevious </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the previous-state copy of a literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">literal</td><td>The literal to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous-state copy of a literal. </dd></dl>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00444">444</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="ParallelLearner_8h_source.html#l00354">current_to_previous_map_</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00407">computePreviousTrans()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00454">presentToPrevious()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3330a141c8ba3ca7c5687824dbf4edc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParallelLearner::presentToPrevious </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cube_or_clause</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the previous-state copy of a cube or clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube_or_clause</td><td>A cube or clause (in form of a vector of literals) over the present state variables. This vector is overwritten by the corresponding cube of clause over the previous-state literals (i.e., all literals are replaced by their previous-state copy). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00454">454</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="ParallelLearner_8cpp_source.html#l00444">presentToPrevious()</a>.</p>

</div>
</div>
<a class="anchor" id="acce71499ce9d8672116139f231376151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParallelLearner::presentToPrevious </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCNF.html">CNF</a> &amp;&#160;</td>
          <td class="paramname"><em>cnf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the previous-state copy of a <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnf</td><td>A <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> formula over the present state variables. This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> is overwritten by the corresponding <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> over the previous-state literals (i.e., all literals are replaced by their previous-state copy). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00461">461</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00117">CNF::addClause()</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="CNF_8cpp_source.html#l00346">CNF::getClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00444">presentToPrevious()</a>.</p>

</div>
</div>
<a class="anchor" id="a93acb74e7c8504d0ef2bd3697441b745"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParallelLearner::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the back-end. </p>
<p>This method mainly starts the worker-threads and waits until they are finished. The <a class="el" href="classParallelLearner.html" title="The coordinator of the parallelized implementation.">ParallelLearner</a> itself does not do any work. It does not even run in an own thread. All the work is done in the worker-threads.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specification was realizable, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classBackEnd.html#a099e717dc71e9cc2d838b1ca86340590">BackEnd</a>.</p>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00249">249</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00333">ce_generalizers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00318">clause_explorers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00328">clause_minimizers_</a>, <a class="el" href="CNF_8cpp_source.html#l00111">CNF::clear()</a>, <a class="el" href="Utils_8cpp_source.html#l00407">Utils::debugCheckWinReg()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01423">IFM13Explorer::exploreClauses()</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00085">CNFImplExtractor::extractCircuit()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00323">ifm_explorers_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00368">impl_extractor_</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="Options_8cpp_source.html#l00065">Options::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="Logger_8h_source.html#l00302">L_INF</a>, <a class="el" href="Logger_8h_source.html#l00285">L_RES</a>, <a class="el" href="CNFImplExtractor_8cpp_source.html#l00290">CNFImplExtractor::logStatistics()</a>, <a class="el" href="LearnStatisticsSAT_8cpp_source.html#l00159">LearnStatisticsSAT::logStatistics()</a>, <a class="el" href="defines_8h_source.html#l00059">MASSERT</a>, <a class="el" href="LearnStatisticsSAT_8cpp_source.html#l00137">LearnStatisticsSAT::mergeWith()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01295">ClauseMinimizerQBF::minimizeClauses()</a>, <a class="el" href="LearnStatisticsSAT_8cpp_source.html#l00069">LearnStatisticsSAT::notifyWinRegEnd()</a>, <a class="el" href="LearnStatisticsSAT_8cpp_source.html#l00063">LearnStatisticsSAT::notifyWinRegStart()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00313">nr_of_threads_</a>, <a class="el" href="VarManager_8cpp_source.html#l00055">VarManager::push()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00192">result_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00340">statistics_</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00061">UNREALIZABLE</a>, and <a class="el" href="ParallelLearner_8h_source.html#l00200">winning_region_</a>.</p>

</div>
</div>
<a class="anchor" id="a2b8e4330afb7e99c19d2d7da15c30cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParallelLearner::triggerExplorerRestart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a new restart point and notifies it to all ClauseExplorerSAT-instances. </p>
<p>The <a class="el" href="classClauseExplorerSAT.html" title="Implements the method of LearnSynthSAT in a parallelized way.">ClauseExplorerSAT</a> update their next-state copy of the winning region only in a lazy manner. This allows them to use incremental SAT-solving more effectively. See <a class="el" href="classLearnSynthSAT.html" title="Implements a learning-based synthesis using two SAT solvers.">LearnSynthSAT</a> for a description. If no more solutions exists with one next-state copy of the winning region, it must be updated to the newest version. This is done by this method. A new next-state copy of the winning region is computed and communicated to all ClauseExplorerSAT-instances. It is absolutely important that all <a class="el" href="classClauseExplorerSAT.html" title="Implements the method of LearnSynthSAT in a parallelized way.">ClauseExplorerSAT</a> instances work with the same next-state copy of the winning region. Otherwise, they could not exchange U-clauses (or rather, the U-clause discovered by one thread would not make sense for the other). See also <a class="el" href="classParallelLearner.html#a0a8405e4fb7331f3f3df2711fdaebdab" title="Notifies all ClauseExplorerSAT-threads that a new U-clause is available.">notifyNewUselessInputClause()</a>. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8cpp_source.html#l00381">381</a> of file <a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a>.</p>

<p>References <a class="el" href="CNF_8cpp_source.html#l00230">CNF::addCNF()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00318">clause_explorers_</a>, <a class="el" href="Utils_8cpp_source.html#l00287">Utils::compressStateCNF()</a>, <a class="el" href="VarManager_8cpp_source.html#l00041">VarManager::instance()</a>, <a class="el" href="AIG2CNF_8cpp_source.html#l00041">AIG2CNF::instance()</a>, <a class="el" href="CNF_8cpp_source.html#l00264">CNF::negate()</a>, <a class="el" href="VarManager_8cpp_source.html#l00063">VarManager::resetToLastPush()</a>, <a class="el" href="CNF_8cpp_source.html#l00236">CNF::swapPresentToNext()</a>, <a class="el" href="ParallelLearner_8h_source.html#l00265">var_man_lock_</a>, <a class="el" href="ParallelLearner_8h_source.html#l00200">winning_region_</a>, and <a class="el" href="ParallelLearner_8h_source.html#l00208">winning_region_lock_</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="a46cc16764d7ea8ffafe8d1b696c35df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classCounterGenSAT.html">CounterGenSAT</a>*&gt; ParallelLearner::ce_generalizers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The CounterGenSAT-instances to execute in a separate thread. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00333">333</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00370">notifyNewCounterexample()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00328">notifyNewWinRegClause()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00226">~ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e8b5dd12c8ae14089d3ce3117da3c16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classClauseExplorerSAT.html">ClauseExplorerSAT</a>*&gt; ParallelLearner::clause_explorers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ClauseExplorerSAT-instances to execute in a separate thread. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00318">318</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00358">notifyNewUselessInputClause()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00328">notifyNewWinRegClause()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00381">triggerExplorerRestart()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00226">~ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="adb5aa1e016e04c607073eaf90d994dc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classClauseMinimizerQBF.html">ClauseMinimizerQBF</a>*&gt; ParallelLearner::clause_minimizers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ClauseMinimizerQBF-instances to execute in a separate thread. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00328">328</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00328">notifyNewWinRegClause()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00226">~ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="a974943e3e2145b3407f689b64acdd33f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;pair&lt;vector&lt;int&gt;, vector&lt;int&gt; &gt; &gt; ParallelLearner::counterexamples_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The counterexample-cubes together with their computed generalizations. </p>
<p>The first item of the pairs stored in this list is always the counterexample itself. The second item of the pair is the generalization that has already been computed.</p>
<p>A counterexample is a state-input combination with which the antagonist can enforce to leave the winning region. The generalization is a sub-cube of the counterexample. This information can then be used by CounterGenSAT-threads. They take such a counterexample and compute all other generalizations. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00239">239</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00370">notifyNewCounterexample()</a>.</p>

</div>
</div>
<a class="anchor" id="a454c81908f2d3cb4c24b042739adc4ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mutex ParallelLearner::counterexamples_lock_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A lock that protects the <a class="el" href="classParallelLearner.html#a974943e3e2145b3407f689b64acdd33f" title="The counterexample-cubes together with their computed generalizations.">counterexamples_</a> from race-conditions. </p>
<p>Many worker-threads modify the <a class="el" href="classParallelLearner.html#a974943e3e2145b3407f689b64acdd33f" title="The counterexample-cubes together with their computed generalizations.">counterexamples_</a> (add new ones). This lock ensures that only one thread is modifying the <a class="el" href="classParallelLearner.html#a974943e3e2145b3407f689b64acdd33f" title="The counterexample-cubes together with their computed generalizations.">counterexamples_</a> at one time. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00247">247</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00370">notifyNewCounterexample()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9293a4afd3c52690bcac2ad03884121"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParallelLearner::current_state_is_initial_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A literal that is true if the current state is initial and false otherwise. </p>
<p>The clauses assigning the literal are part of <a class="el" href="classParallelLearner.html#ac73d9338262855f61f23a65d1df0647c" title="Says: the current state is initial or the previous transition relation holds.">prev_trans_or_initial_</a>. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00361">361</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00407">computePreviousTrans()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f8dfda6aa8640345057023ed85882b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; ParallelLearner::current_to_previous_map_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A map from present-state variables to their previous-state copy. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00354">354</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00407">computePreviousTrans()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00444">presentToPrevious()</a>.</p>

</div>
</div>
<a class="anchor" id="a614707a21f36d75a9fd06be57ee421d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classIFM13Explorer.html">IFM13Explorer</a>*&gt; ParallelLearner::ifm_explorers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The IFM13Explorer-instances to execute in a separate thread. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00323">323</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00328">notifyNewWinRegClause()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00226">~ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="a58b6113b54eb7c91bbf15546d575f5e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNFImplExtractor.html">CNFImplExtractor</a>* ParallelLearner::impl_extractor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The engine to use for circuit extraction. </p>
<p>It will be deleted by this class (in the destructor). </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00368">368</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00226">~ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="a170a0abad017845877039684507e7a66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ParallelLearner::nr_of_threads_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of threads to instantiate and execute. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00313">313</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>.</p>

</div>
</div>
<a class="anchor" id="ac73d9338262855f61f23a65d1df0647c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> ParallelLearner::prev_trans_or_initial_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Says: the current state is initial or the previous transition relation holds. </p>
<p>This <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> expresses that the current state is initial or the previous-state copy of the transition relation holds. This is an important building block for the <a class="el" href="classCNF.html" title="Represents a propositional formula in Conjunctive Normal Form.">CNF</a> to generalize counterexamples if optimization RG is enabled. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00349">349</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00407">computePreviousTrans()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="a5bc71a2c35fa976d792bf0e80de31a39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutex ParallelLearner::print_lock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A lock used to synchronize the printing of debugging messages. </p>
<p>Debugging race conditions or other bugs in this implementation is tough. In order to prevent debugging messages from being interleaved strangely, this lock is used. It makes debug messages printed with the PLOG macro appear one after the other. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00256">256</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

</div>
</div>
<a class="anchor" id="a757f8817809cce5c0408cdc41d6db1b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ParallelLearner::result_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integer number containing the realizability verdict. </p>
<p>There are three possible value. </p>
<ul>
<li>
UNKNOWN = 0: used as long as no thread has found a solution. </li>
<li>
REALIZABLE = 1: used if some thread concludes that the spec must be realizable. </li>
<li>
UNREALIZABLE = 2: used if some thread concludes that the spec must be unrealizable. </li>
</ul>
<p>All worker-threads poll this flag from time to time. If the value is still UNKNOWN they continue to work. If they see that the values is not UNKNOWN anymore they stop assuming that some other thread has already found the solution. If one thread finds an answer to the realizability question it sets the flag (the <a class="el" href="classParallelLearner.html#a7c8383543ff98d7a0356a237756dcdd6" title="The current version of the winning region.">winning_region_</a> must be precise enough then already). </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00192">192</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01123">CounterGenSAT::bored()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01152">CounterGenSAT::compressBored()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00580">ClauseExplorerSAT::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01423">IFM13Explorer::exploreClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00921">CounterGenSAT::generalizeCounterexamples()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01295">ClauseMinimizerQBF::minimizeClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01474">IFM13Explorer::propagateBlockedStates()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l01531">IFM13Explorer::recBlockCube()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>.</p>

</div>
</div>
<a class="anchor" id="abfb2e28ec1a0f8775d3f14f75415a8bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLearnStatisticsSAT.html">LearnStatisticsSAT</a> ParallelLearner::statistics_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores and maintains statistics and performance measures. </p>
<p>Basically, this is a merge of the statistics from all worker-threads. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00340">340</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>.</p>

</div>
</div>
<a class="anchor" id="aba6b363071d9a39d7b368cec5b629c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> ParallelLearner::unminimized_clauses_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All clauses of the winning region that have not yet been minimized. </p>
<p>Whenever a clause is added to <a class="el" href="classParallelLearner.html#a7c8383543ff98d7a0356a237756dcdd6" title="The current version of the winning region.">winning_region_</a>, it is also added to this field. ClauseMinimizerQBF-instances then take clauses from <a class="el" href="classParallelLearner.html#aba6b363071d9a39d7b368cec5b629c25" title="All clauses of the winning region that have not yet been minimized.">unminimized_clauses_</a> and try to minimize them further. This is done to prevent that clauses are minimized twice or multiple times. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00218">218</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01295">ClauseMinimizerQBF::minimizeClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00328">notifyNewWinRegClause()</a>.</p>

</div>
</div>
<a class="anchor" id="aa16d364d9fdd0c2fe5180ee1b023a4ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mutex ParallelLearner::unminimized_clauses_lock_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A lock that protects the <a class="el" href="classParallelLearner.html#aba6b363071d9a39d7b368cec5b629c25" title="All clauses of the winning region that have not yet been minimized.">unminimized_clauses_</a> from race-conditions. </p>
<p>Many worker-threads refine the <a class="el" href="classParallelLearner.html#aba6b363071d9a39d7b368cec5b629c25" title="All clauses of the winning region that have not yet been minimized.">unminimized_clauses_</a> (add new clauses). This lock ensures that only one thread is modifying the <a class="el" href="classParallelLearner.html#aba6b363071d9a39d7b368cec5b629c25" title="All clauses of the winning region that have not yet been minimized.">unminimized_clauses_</a> at one time. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00226">226</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01295">ClauseMinimizerQBF::minimizeClauses()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00328">notifyNewWinRegClause()</a>.</p>

</div>
</div>
<a class="anchor" id="aebaf891aada574da650732795f041dbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParallelLearner::use_ind_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A flag indicating if optimization RG should be used. </p>
<p>See <a class="el" href="classLearnSynthQBFInd.html" title="Implements a learning-based synthesis with inductive reachability reasoning.">LearnSynthQBFInd</a> for an explanation. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00308">308</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00116">ParallelLearner()</a>.</p>

</div>
</div>
<a class="anchor" id="abdd409a5ef29bd4ba6b7213e9d4a067b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mutex ParallelLearner::var_man_lock_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A lock that must be hold when the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created.">VarManager</a> is modified. </p>
<p>Sometimes (at the moment only when doing restarts in <a class="el" href="classParallelLearner.html#a2b8e4330afb7e99c19d2d7da15c30cc3" title="Computes a new restart point and notifies it to all ClauseExplorerSAT-instances.">triggerExplorerRestart()</a>) we need to modify the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created.">VarManager</a>, e.g., if we create new variables. This lock is used to prevent race-conditions in these operations. It must be held whenever the <a class="el" href="classVarManager.html" title="Stores and maintains all Boolean variables that have (ever) been created.">VarManager</a> is modified. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00265">265</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l00381">triggerExplorerRestart()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00829">ClauseExplorerSAT::waitUntilOngoingRestartDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c8383543ff98d7a0356a237756dcdd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCNF.html">CNF</a> ParallelLearner::winning_region_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current version of the winning region. </p>
<p>All worker-threads discover or minimize clauses of the winning region. This is the current version of the winning region. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00200">200</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01295">ClauseMinimizerQBF::minimizeClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00328">notifyNewWinRegClause()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00249">run()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00381">triggerExplorerRestart()</a>.</p>

</div>
</div>
<a class="anchor" id="a196a4500dfd66a4b9110659b4a10dead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mutex ParallelLearner::winning_region_lock_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A lock that protects the <a class="el" href="classParallelLearner.html#a7c8383543ff98d7a0356a237756dcdd6" title="The current version of the winning region.">winning_region_</a> from race-conditions. </p>
<p>Many worker-threads refine the <a class="el" href="classParallelLearner.html#a7c8383543ff98d7a0356a237756dcdd6" title="The current version of the winning region.">winning_region_</a> (add new clauses). This lock ensures that only one thread is modifying the <a class="el" href="classParallelLearner.html#a7c8383543ff98d7a0356a237756dcdd6" title="The current version of the winning region.">winning_region_</a> at one time. </p>

<p>Definition at line <a class="el" href="ParallelLearner_8h_source.html#l00208">208</a> of file <a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a>.</p>

<p>Referenced by <a class="el" href="ParallelLearner_8cpp_source.html#l01295">ClauseMinimizerQBF::minimizeClauses()</a>, <a class="el" href="ParallelLearner_8cpp_source.html#l00328">notifyNewWinRegClause()</a>, and <a class="el" href="ParallelLearner_8cpp_source.html#l00381">triggerExplorerRestart()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="ParallelLearner_8h_source.html">ParallelLearner.h</a></li>
<li>src/<a class="el" href="ParallelLearner_8cpp_source.html">ParallelLearner.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 15 2014 12:30:22 for demiurge by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
