\hypertarget{classUtils}{\section{Utils Class Reference}
\label{classUtils}\index{Utils@{Utils}}
}


Contains utility functions that can be usful in various back-\/ends.  




{\ttfamily \#include $<$Utils.\-h$>$}

\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classUtils_adef5db58221c7a04397de10ec0b13fb6}{contains\-Init} (const vector$<$ int $>$ \&cube)
\begin{DoxyCompactList}\small\item\em Checks if a cube (in form of a vector of literals) contains the initial state. \end{DoxyCompactList}\item 
static bool \hyperlink{classUtils_a02ae74e9866b8ca0863c9507e46df007}{contains\-Init} (const set$<$ int $>$ \&cube)
\begin{DoxyCompactList}\small\item\em Checks if a cube (in form of a set of literals) contains the initial state. \end{DoxyCompactList}\item 
static vector$<$ int $>$ \hyperlink{classUtils_a9eb9e182ca1da6a1050338928083f632}{extract} (const vector$<$ int $>$ \&cube\-\_\-or\-\_\-clause, \hyperlink{classVarInfo_a64d1da76cf84fe674e5fef9764ef11cf}{Var\-Info\-::\-Var\-Kind} kind)
\begin{DoxyCompactList}\small\item\em Extracts literals that are of a given type from a cube or clause. \end{DoxyCompactList}\item 
static vector$<$ int $>$ \hyperlink{classUtils_a9c060a97bf0e9e5e08bf33b512633ac3}{extract\-Pres\-In} (const vector$<$ int $>$ \&cube\-\_\-or\-\_\-clause)
\begin{DoxyCompactList}\small\item\em Extracts present-\/state literals and input literals from a cube or clause. \end{DoxyCompactList}\item 
static vector$<$ int $>$ \hyperlink{classUtils_a9251f04947864aaaac7e459987913429}{extract\-Next\-As\-Present} (const vector$<$ int $>$ \&cube\-\_\-or\-\_\-clause)
\begin{DoxyCompactList}\small\item\em Extracts next-\/state literals and returns the present-\/state copy. \end{DoxyCompactList}\item 
static vector$<$ int $>$ \hyperlink{classUtils_a21f2b014ac53ca027864c57e24a60195}{extract} (const vector$<$ int $>$ \&cube\-\_\-or\-\_\-clause, const vector$<$ int $>$ \&vars)
\begin{DoxyCompactList}\small\item\em Extracts certain literals from a cube or clause. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_a71efa1aa570b356a328e95008fb65ad8}{randomize} (vector$<$ int $>$ \&vec)
\begin{DoxyCompactList}\small\item\em Randomizes the order (not the value) of a given vector of integers. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_a2843ae3d849c66ebd72baea26fbd7580}{sort} (vector$<$ int $>$ \&vec)
\begin{DoxyCompactList}\small\item\em Sorts a vector of integers in ascending order. \end{DoxyCompactList}\item 
static bool \hyperlink{classUtils_a15b142132eb40445f51b1f1bb89b85f3}{remove} (vector$<$ int $>$ \&vec, int elem)
\begin{DoxyCompactList}\small\item\em Removes a certain element from a vector. \end{DoxyCompactList}\item 
static bool \hyperlink{classUtils_a84611c8a027ac12426219cb4d59765aa}{contains} (const vector$<$ int $>$ \&vec, int elem)
\begin{DoxyCompactList}\small\item\em Checks if a vector contains a certain element. \end{DoxyCompactList}\item 
static bool \hyperlink{classUtils_a5dc062d4cf872c0d69924116879715ab}{eq} (const vector$<$ int $>$ \&v1, const vector$<$ int $>$ \&v2, int start\-\_\-idx=0)
\begin{DoxyCompactList}\small\item\em Checks if two vectors contain the same set of elements. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_ae7584589e0d06005fe893fdb9244483a}{negate\-Literals} (vector$<$ int $>$ \&cube\-\_\-or\-\_\-clause)
\begin{DoxyCompactList}\small\item\em Negates all literals in a cube or clause. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_a8e0d236cf00a61a34ef5c48bcb08a1ec}{swap\-Present\-To\-Next} (vector$<$ int $>$ \&vec)
\begin{DoxyCompactList}\small\item\em Replaces all current-\/state literals by their next-\/state copy. \end{DoxyCompactList}\item 
static bool \hyperlink{classUtils_aa6a513b0ad3b22b3b857060219c222d6}{intersection\-Empty} (const vector$<$ int $>$ \&x, const set$<$ int $>$ \&y)
\begin{DoxyCompactList}\small\item\em Checks if a vector and a set have an empty intersection. \end{DoxyCompactList}\item 
static bool \hyperlink{classUtils_ae957d76f82e729f9d127cf05cb61320d}{intersection\-Empty} (const set$<$ int $>$ \&x, const set$<$ int $>$ \&y)
\begin{DoxyCompactList}\small\item\em Checks if the intersection of two sets is empty. \end{DoxyCompactList}\item 
static bool \hyperlink{classUtils_ab5dca8125b6addaa1f0331664ab6142e}{is\-Subset} (const vector$<$ int $>$ \&subset, const vector$<$ int $>$ \&superset)
\begin{DoxyCompactList}\small\item\em Checks if one vector forms a subset of another one. \end{DoxyCompactList}\item 
static bool \hyperlink{classUtils_ac4e713aa386834b587e2695855fbc27a}{compress\-State\-C\-N\-F} (\hyperlink{classCNF}{C\-N\-F} \&cnf, bool hardcore=false)
\begin{DoxyCompactList}\small\item\em Compresses a state-\/\-C\-N\-F by removing clauses that are implied by others. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_ad6bc8cf6342b8f182597aa53cf72d9d3}{negate\-State\-C\-N\-F} (\hyperlink{classCNF}{C\-N\-F} \&cnf)
\begin{DoxyCompactList}\small\item\em Negates a \hyperlink{classCNF}{C\-N\-F} over the state-\/variables without introducing temporary variables. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_acd64e5ea20bd4579427734a9ede171d8}{negate\-Via\-Aig} (\hyperlink{classCNF}{C\-N\-F} \&cnf)
\begin{DoxyCompactList}\small\item\em Negates a \hyperlink{classCNF}{C\-N\-F} by transforming into A\-I\-G\-E\-R and back. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_a5ddf6a703833a37aae073e12d114a6c8}{compress\-Next\-State\-C\-N\-F} (\hyperlink{classCNF}{C\-N\-F} \&ps\-\_\-cnf, \hyperlink{classCNF}{C\-N\-F} \&ns\-\_\-cnf, bool hardcore=false)
\begin{DoxyCompactList}\small\item\em Compresses a state-\/\-C\-N\-F by removing implied clauses and computes the next-\/state \hyperlink{classCNF}{C\-N\-F}. \end{DoxyCompactList}\item 
static size\-\_\-t \hyperlink{classUtils_ae48658c2b3c7f71261146210c7861b60}{get\-Current\-Mem\-Usage} ()
\begin{DoxyCompactList}\small\item\em Returns the current memory usage as debug message in k\-B. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_adeaccd2a53073b17e3409eab8e98db0c}{debug\-Print} (const vector$<$ int $>$ \&vec, string prefix=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Prints a vector of literals (mainly for debugging purposes). \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_acc29602987b73022546a6d752a7e093f}{debug\-Check\-Win\-Reg} (const \hyperlink{classCNF}{C\-N\-F} \&winning\-\_\-region)
\begin{DoxyCompactList}\small\item\em Checks a winning region for correctness. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_a448f5356530d2e88fa9928f4ed857238}{debug\-Check\-Win\-Reg} (const \hyperlink{classCNF}{C\-N\-F} \&winning\-\_\-region, const \hyperlink{classCNF}{C\-N\-F} \&neg\-\_\-winning\-\_\-region)
\begin{DoxyCompactList}\small\item\em Checks a winning region and its negation for correctness. \end{DoxyCompactList}\item 
static void \hyperlink{classUtils_af69b7f70358d1c1616aab1560c7363cd}{debug\-Print\-Current\-Mem\-Usage} ()
\begin{DoxyCompactList}\small\item\em Prints the current memory usage as debug message. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classUtils_a452e78692c87ed5c7c993b6c6ac4981a}{Utils} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classUtils_a0d842a927296003dd7088fc1e4e2a367}{$\sim$\-Utils} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\hyperlink{classUtils_a80726f8ec2ed2707a8bfd4fd355ef27a}{Utils} (const \hyperlink{classUtils}{Utils} \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classUtils}{Utils} \& \hyperlink{classUtils_a0ed61b802f94ec15000c458e9aae4f19}{operator=} (const \hyperlink{classUtils}{Utils} \&other)
\begin{DoxyCompactList}\small\item\em Assignment operator. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Contains utility functions that can be usful in various back-\/ends. 

\begin{DoxyAuthor}{Author}
Robert Koenighofer (\href{mailto:robert.koenighofer@iaik.tugraz.at}{\tt robert.\-koenighofer@iaik.\-tugraz.\-at}) 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\-2.\-0 
\end{DoxyVersion}


Definition at line 45 of file Utils.\-h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classUtils_a452e78692c87ed5c7c993b6c6ac4981a}{\index{Utils@{Utils}!Utils@{Utils}}
\index{Utils@{Utils}!Utils@{Utils}}
\subsubsection[{Utils}]{\setlength{\rightskip}{0pt plus 5cm}Utils\-::\-Utils (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{classUtils_a452e78692c87ed5c7c993b6c6ac4981a}


Constructor. 

The constructor is private and not implemented. Use the static methods. \hypertarget{classUtils_a0d842a927296003dd7088fc1e4e2a367}{\index{Utils@{Utils}!$\sim$\-Utils@{$\sim$\-Utils}}
\index{$\sim$\-Utils@{$\sim$\-Utils}!Utils@{Utils}}
\subsubsection[{$\sim$\-Utils}]{\setlength{\rightskip}{0pt plus 5cm}virtual Utils\-::$\sim$\-Utils (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}}\label{classUtils_a0d842a927296003dd7088fc1e4e2a367}


Constructor. 

The constructor is private and not implemented. Use the static methods. \hypertarget{classUtils_a80726f8ec2ed2707a8bfd4fd355ef27a}{\index{Utils@{Utils}!Utils@{Utils}}
\index{Utils@{Utils}!Utils@{Utils}}
\subsubsection[{Utils}]{\setlength{\rightskip}{0pt plus 5cm}Utils\-::\-Utils (
\begin{DoxyParamCaption}
\item[{const {\bf Utils} \&}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{classUtils_a80726f8ec2ed2707a8bfd4fd355ef27a}


Copy constructor. 

The copy constructor is disabled (set private) and not implemented.


\begin{DoxyParams}{Parameters}
{\em other} & The source for creating the copy. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{classUtils_a5ddf6a703833a37aae073e12d114a6c8}{\index{Utils@{Utils}!compress\-Next\-State\-C\-N\-F@{compress\-Next\-State\-C\-N\-F}}
\index{compress\-Next\-State\-C\-N\-F@{compress\-Next\-State\-C\-N\-F}!Utils@{Utils}}
\subsubsection[{compress\-Next\-State\-C\-N\-F}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::compress\-Next\-State\-C\-N\-F (
\begin{DoxyParamCaption}
\item[{{\bf C\-N\-F} \&}]{ps\-\_\-cnf, }
\item[{{\bf C\-N\-F} \&}]{ns\-\_\-cnf, }
\item[{bool}]{hardcore = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a5ddf6a703833a37aae073e12d114a6c8}


Compresses a state-\/\-C\-N\-F by removing implied clauses and computes the next-\/state \hyperlink{classCNF}{C\-N\-F}. 

This method is similar to \hyperlink{classUtils_ac4e713aa386834b587e2695855fbc27a}{compress\-State\-C\-N\-F()}. The difference is that this method also computes a compact representation of the next-\/state copy of passed state-\/\-C\-N\-F. When compressing the next-\/state copy, clauses are removed if they are already implied by existing clauses or the present-\/state copy of the \hyperlink{classCNF}{C\-N\-F}. That is, the compression of the next-\/state copy is only valid if the current-\/state copy is going to be asserted in the solver. 
\begin{DoxyParams}{Parameters}
{\em ps\-\_\-cnf} & The \hyperlink{classCNF}{C\-N\-F} formula to compress. We assume that this \hyperlink{classCNF}{C\-N\-F} only talks about the present-\/state variables. This \hyperlink{classCNF}{C\-N\-F} is compressed, similar as done by \hyperlink{classUtils_ac4e713aa386834b587e2695855fbc27a}{compress\-State\-C\-N\-F()}. \\
\hline
{\em ns\-\_\-cnf} & An empty \hyperlink{classCNF}{C\-N\-F}. This \hyperlink{classCNF}{C\-N\-F} is filled with the compression of the next-\/state copy of ps\-\_\-cnf. The resulting ns\-\_\-cnf is only valid under the assumption that ps\-\_\-cnf is asserted. \\
\hline
{\em hardcore} & Set this parameter to true if you do not only want to remove clauses but also literals from clauses. This is more expensive, but can produce smaller \hyperlink{classCNF}{C\-N\-F} representations. \\
\hline
\end{DoxyParams}


Definition at line 502 of file Utils.\-cpp.



References C\-N\-F\-::add\-Clause(), C\-N\-F\-::add\-Neg\-Cube\-As\-Clause(), C\-N\-F\-::clear(), Var\-Manager\-::get\-All\-Non\-Temp\-Vars(), C\-N\-F\-::get\-Nr\-Of\-Clauses(), Options\-::get\-S\-A\-T\-Solver(), Sat\-Solver\-::inc\-Add\-Clause(), Sat\-Solver\-::inc\-Add\-C\-N\-F(), Sat\-Solver\-::inc\-Is\-Sat(), Sat\-Solver\-::inc\-Is\-Sat\-Model\-Or\-Core(), Var\-Manager\-::instance(), Options\-::instance(), A\-I\-G2\-C\-N\-F\-::instance(), M\-A\-S\-S\-E\-R\-T, negate\-Literals(), C\-N\-F\-::remove\-Smallest(), Sat\-Solver\-::start\-Incremental\-Session(), C\-N\-F\-::swap\-Present\-To\-Next(), and C\-N\-F\-::swap\-With().



Referenced by Univ\-Expander\-::reset\-Solver\-I\-Exp(), and Learning\-Impl\-Extractor\-::run\-Learning\-Exp().

\hypertarget{classUtils_ac4e713aa386834b587e2695855fbc27a}{\index{Utils@{Utils}!compress\-State\-C\-N\-F@{compress\-State\-C\-N\-F}}
\index{compress\-State\-C\-N\-F@{compress\-State\-C\-N\-F}!Utils@{Utils}}
\subsubsection[{compress\-State\-C\-N\-F}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::compress\-State\-C\-N\-F (
\begin{DoxyParamCaption}
\item[{{\bf C\-N\-F} \&}]{cnf, }
\item[{bool}]{hardcore = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_ac4e713aa386834b587e2695855fbc27a}


Compresses a state-\/\-C\-N\-F by removing clauses that are implied by others. 

This is done by incremental S\-A\-T-\/solving and is usually quite fast (at least compared to Q\-B\-F solving).


\begin{DoxyParams}{Parameters}
{\em cnf} & The \hyperlink{classCNF}{C\-N\-F} formula to compress. \\
\hline
{\em hardcore} & Set this parameter to true if you do not only want to remove clauses but also literals from clauses. This is more expensive, but can produce smaller \hyperlink{classCNF}{C\-N\-F} representations. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the \hyperlink{classCNF}{C\-N\-F} was modified, false otherwise. 
\end{DoxyReturn}


Definition at line 305 of file Utils.\-cpp.



References C\-N\-F\-::add\-Clause(), C\-N\-F\-::add\-Neg\-Cube\-As\-Clause(), C\-N\-F\-::clear(), C\-N\-F\-::get\-Clauses(), C\-N\-F\-::get\-Nr\-Of\-Clauses(), Options\-::get\-S\-A\-T\-Solver(), Sat\-Solver\-::inc\-Add\-Clause(), Sat\-Solver\-::inc\-Add\-C\-N\-F(), Sat\-Solver\-::inc\-Is\-Sat(), Sat\-Solver\-::inc\-Is\-Sat\-Model\-Or\-Core(), Var\-Manager\-::instance(), Options\-::instance(), M\-A\-S\-S\-E\-R\-T, negate\-Literals(), Var\-Info\-::\-P\-R\-E\-S\-\_\-\-S\-T\-A\-T\-E, C\-N\-F\-::remove\-Smallest(), and Sat\-Solver\-::start\-Incremental\-Session().



Referenced by Learn\-Synth\-Q\-B\-F\-::compute\-Counterexample\-S\-A\-T(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-All(), Learn\-Synth\-Q\-B\-F\-::compute\-Winning\-Region\-All(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Winning\-Region\-All(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-All\-Pool(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-One\-Pool(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Dep(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Dep2(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Recy(), Clause\-Explorer\-S\-A\-T\-::consider\-New\-Info\-From\-Others(), C\-N\-F\-Impl\-Extractor\-::extract\-Circuit(), Templ\-Explorer\-::find\-Win\-Reg\-C\-N\-F\-Templ(), and Parallel\-Learner\-::trigger\-Explorer\-Restart().

\hypertarget{classUtils_a84611c8a027ac12426219cb4d59765aa}{\index{Utils@{Utils}!contains@{contains}}
\index{contains@{contains}!Utils@{Utils}}
\subsubsection[{contains}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::contains (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{vec, }
\item[{int}]{elem}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a84611c8a027ac12426219cb4d59765aa}


Checks if a vector contains a certain element. 


\begin{DoxyParams}{Parameters}
{\em vec} & The vector in which the element should be searched. \\
\hline
{\em elem} & The element to search. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the vector contains the element, false otherwise. 
\end{DoxyReturn}


Definition at line 195 of file Utils.\-cpp.



Referenced by I\-F\-M13\-Explorer\-::add\-Blocked\-State(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Exp(), Templ\-Explorer\-::exclude(), Clause\-Explorer\-S\-A\-T\-::explore\-Clauses(), extract(), Counter\-Gen\-S\-A\-T\-::generalize\-Ce\-Futher(), Dep\-Q\-B\-F\-Ext\-::parse\-Model(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp\-Ctrl(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp\-Ctrl\-Inc2(), and Par\-Extractor\-Worker\-::run\-S\-A\-T\-Dep().

\hypertarget{classUtils_adef5db58221c7a04397de10ec0b13fb6}{\index{Utils@{Utils}!contains\-Init@{contains\-Init}}
\index{contains\-Init@{contains\-Init}!Utils@{Utils}}
\subsubsection[{contains\-Init}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::contains\-Init (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{cube}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_adef5db58221c7a04397de10ec0b13fb6}


Checks if a cube (in form of a vector of literals) contains the initial state. 

In our synthesis problems, there is exactly one initial state of the system (this is a restriction imposed by the A\-I\-G\-E\-R format which serves as input for our tool). Furthermore, the initial state is always characterized by having all state bits set to F\-A\-L\-S\-E. However, this may change with future A\-I\-G\-E\-R versions.


\begin{DoxyParams}{Parameters}
{\em cube} & The cube (a conjuction of literals) in form of a vector of literals over the current-\/state variables. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the cube contains the initial state (i.\-e., the initial state satisfies the cube, i.\-e., the cube contains only negated literals). False otherwise. 
\end{DoxyReturn}


Definition at line 45 of file Utils.\-cpp.



Referenced by Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Blocking\-Clause(), Learn\-Synth\-Q\-B\-F\-::compute\-Blocking\-Clause(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Blocking\-Clause(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Dep(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Recy(), Clause\-Explorer\-S\-A\-T\-::explore\-Clauses(), Counter\-Gen\-S\-A\-T\-::generalize\-Counterexamples(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-Inc(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-No\-Inc(), I\-F\-M13\-Synth\-::rec\-Block\-Cube(), and I\-F\-M13\-Explorer\-::rec\-Block\-Cube().

\hypertarget{classUtils_a02ae74e9866b8ca0863c9507e46df007}{\index{Utils@{Utils}!contains\-Init@{contains\-Init}}
\index{contains\-Init@{contains\-Init}!Utils@{Utils}}
\subsubsection[{contains\-Init}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::contains\-Init (
\begin{DoxyParamCaption}
\item[{const set$<$ int $>$ \&}]{cube}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a02ae74e9866b8ca0863c9507e46df007}


Checks if a cube (in form of a set of literals) contains the initial state. 

In our synthesis problems, there is exactly one initial state of the system (this is a restriction imposed by the A\-I\-G\-E\-R format which serves as input for our tool). Furthermore, the initial state is always characterized by having all state bits set to F\-A\-L\-S\-E. However, this may change with future A\-I\-G\-E\-R versions.


\begin{DoxyParams}{Parameters}
{\em cube} & The cube (a conjuction of literals) in form of a set of literals over the current-\/state variables. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the cube contains the initial state (i.\-e., the initial state satisfies the cube, i.\-e., the cube contains only negated literals). False otherwise. 
\end{DoxyReturn}


Definition at line 56 of file Utils.\-cpp.

\hypertarget{classUtils_acc29602987b73022546a6d752a7e093f}{\index{Utils@{Utils}!debug\-Check\-Win\-Reg@{debug\-Check\-Win\-Reg}}
\index{debug\-Check\-Win\-Reg@{debug\-Check\-Win\-Reg}!Utils@{Utils}}
\subsubsection[{debug\-Check\-Win\-Reg}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::debug\-Check\-Win\-Reg (
\begin{DoxyParamCaption}
\item[{const {\bf C\-N\-F} \&}]{winning\-\_\-region}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_acc29602987b73022546a6d752a7e093f}


Checks a winning region for correctness. 

The check is only done in debug-\/mode. In release-\/mode this method does nothing. In debug-\/mode this method checks three properties of a winning region W. 
\begin{DoxyEnumerate}
\item I(x) =$>$ W(x)\-: every initial state must be contained in the winning region 
\item W(x) =$>$ P(x)\-: every state of the winning region must be safe 
\item forall x,i\-: exists c,x'\-: W(x) =$>$ (T(x,i,c,x') \& W(x'))\-: from every state in the winning region it must be possible to stay in the winning region by setting the c-\/signals appropriately. 
\end{DoxyEnumerate}These three properties are sufficient for turning the winning region into a circuit. However, thise conditions are not necessary. E.\-g., if optimization R\-C is used by \hyperlink{classLearnSynthQBFInd}{Learn\-Synth\-Q\-B\-F\-Ind} or \hyperlink{classLearnSynthSAT}{Learn\-Synth\-S\-A\-T}, the third property does not hold. Hence, these classes have special methods to check such winning regions.


\begin{DoxyParams}{Parameters}
{\em winning\-\_\-region} & The winning region to check. \\
\hline
\end{DoxyParams}


Definition at line 645 of file Utils.\-cpp.



References C\-N\-F\-::negate().



Referenced by Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Winning\-Region(), Learn\-Synth\-Q\-B\-F\-Inc\-::run(), Template\-Synth\-::run(), I\-F\-M13\-Synth\-::run(), Learn\-Synth\-Q\-B\-F\-::run(), and Parallel\-Learner\-::run().

\hypertarget{classUtils_a448f5356530d2e88fa9928f4ed857238}{\index{Utils@{Utils}!debug\-Check\-Win\-Reg@{debug\-Check\-Win\-Reg}}
\index{debug\-Check\-Win\-Reg@{debug\-Check\-Win\-Reg}!Utils@{Utils}}
\subsubsection[{debug\-Check\-Win\-Reg}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::debug\-Check\-Win\-Reg (
\begin{DoxyParamCaption}
\item[{const {\bf C\-N\-F} \&}]{winning\-\_\-region, }
\item[{const {\bf C\-N\-F} \&}]{neg\-\_\-winning\-\_\-region}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a448f5356530d2e88fa9928f4ed857238}


Checks a winning region and its negation for correctness. 

Use this method if you have the negation of the winning region available. Otherwise, we would end up with a double-\/negation, which is inefficient.

The check is only done in debug-\/mode. In release-\/mode this method does nothing. In debug-\/mode this method checks three properties of a winning region W. 
\begin{DoxyEnumerate}
\item I(x) =$>$ W(x)\-: every initial state must be contained in the winning region 
\item W(x) =$>$ P(x)\-: every state of the winning region must be safe 
\item forall x,i\-: exists c,x'\-: W(x) =$>$ (T(x,i,c,x') \& W(x'))\-: from every state in the winning region it must be possible to stay in the winning region by setting the c-\/signals appropriately. 
\end{DoxyEnumerate}These three properties are sufficient for turning the winning region into a circuit. However, thise conditions are not necessary. E.\-g., if optimization R\-C is used by \hyperlink{classLearnSynthQBFInd}{Learn\-Synth\-Q\-B\-F\-Ind} or \hyperlink{classLearnSynthSAT}{Learn\-Synth\-S\-A\-T}, the third property does not hold. Hence, these classes have special methods to check such winning regions.


\begin{DoxyParams}{Parameters}
{\em winning\-\_\-region} & The winning region to check. \\
\hline
{\em neg\-\_\-winning\-\_\-region} & The negation of the winning region to check. \\
\hline
\end{DoxyParams}


Definition at line 655 of file Utils.\-cpp.



References Q\-B\-F\-Solver\-::\-A, C\-N\-F\-::add\-C\-N\-F(), C\-N\-F\-::clear(), Var\-Info\-::\-C\-T\-R\-L, Q\-B\-F\-Solver\-::\-E, extract(), Options\-::get\-Q\-B\-F\-Solver(), Options\-::get\-S\-A\-T\-Solver(), Var\-Manager\-::get\-Vars\-Of\-Type(), Sat\-Solver\-::inc\-Add\-C\-N\-F(), Sat\-Solver\-::inc\-Add\-Neg\-Cube\-As\-Clause(), Sat\-Solver\-::inc\-Is\-Sat\-Model\-Or\-Core(), Var\-Info\-::\-I\-N\-P\-U\-T, Var\-Manager\-::instance(), Options\-::instance(), A\-I\-G2\-C\-N\-F\-::instance(), Q\-B\-F\-Solver\-::is\-Sat(), Sat\-Solver\-::is\-Sat(), L\-\_\-\-D\-B\-G, M\-A\-S\-S\-E\-R\-T, Var\-Info\-::\-N\-E\-X\-T\-\_\-\-S\-T\-A\-T\-E, Var\-Info\-::\-P\-R\-E\-S\-\_\-\-S\-T\-A\-T\-E, C\-N\-F\-::rename\-Tmps(), Sat\-Solver\-::start\-Incremental\-Session(), C\-N\-F\-::swap\-Present\-To\-Next(), and Var\-Info\-::\-T\-M\-P.

\hypertarget{classUtils_adeaccd2a53073b17e3409eab8e98db0c}{\index{Utils@{Utils}!debug\-Print@{debug\-Print}}
\index{debug\-Print@{debug\-Print}!Utils@{Utils}}
\subsubsection[{debug\-Print}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::debug\-Print (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{vec, }
\item[{string}]{prefix = {\ttfamily \char`\"{}\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_adeaccd2a53073b17e3409eab8e98db0c}


Prints a vector of literals (mainly for debugging purposes). 


\begin{DoxyParams}{Parameters}
{\em vec} & The vector of literals to print. \\
\hline
{\em prefix} & An optional prefix for the debug message. \\
\hline
\end{DoxyParams}


Definition at line 630 of file Utils.\-cpp.



References L\-\_\-\-D\-B\-G.



Referenced by Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-All(), Learn\-Synth\-Q\-B\-F\-::compute\-Winning\-Region\-All(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Winning\-Region\-All(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-All\-Pool(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-All\-Push(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-One\-Pool(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-One\-Push(), Learn\-Synth\-Q\-B\-F\-::compute\-Winning\-Region\-One\-S\-A\-T(), and Dep\-Q\-B\-F\-Api\-::debug\-Check\-Bloqqer\-Model().

\hypertarget{classUtils_af69b7f70358d1c1616aab1560c7363cd}{\index{Utils@{Utils}!debug\-Print\-Current\-Mem\-Usage@{debug\-Print\-Current\-Mem\-Usage}}
\index{debug\-Print\-Current\-Mem\-Usage@{debug\-Print\-Current\-Mem\-Usage}!Utils@{Utils}}
\subsubsection[{debug\-Print\-Current\-Mem\-Usage}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::debug\-Print\-Current\-Mem\-Usage (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_af69b7f70358d1c1616aab1560c7363cd}


Prints the current memory usage as debug message. 



Definition at line 756 of file Utils.\-cpp.



References L\-\_\-\-D\-B\-G.



Referenced by main().

\hypertarget{classUtils_a5dc062d4cf872c0d69924116879715ab}{\index{Utils@{Utils}!eq@{eq}}
\index{eq@{eq}!Utils@{Utils}}
\subsubsection[{eq}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::eq (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{v1, }
\item[{const vector$<$ int $>$ \&}]{v2, }
\item[{int}]{start\-\_\-idx = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a5dc062d4cf872c0d69924116879715ab}


Checks if two vectors contain the same set of elements. 


\begin{DoxyParams}{Parameters}
{\em v1} & The first vector for the comparison. \\
\hline
{\em v2} & The first vector for the comparison. \\
\hline
{\em start\-\_\-idx} & The start index for the comparison. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the two vectors contain the same set of elements. 
\end{DoxyReturn}


Definition at line 206 of file Utils.\-cpp.

\hypertarget{classUtils_a9eb9e182ca1da6a1050338928083f632}{\index{Utils@{Utils}!extract@{extract}}
\index{extract@{extract}!Utils@{Utils}}
\subsubsection[{extract}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ int $>$ Utils\-::extract (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{cube\-\_\-or\-\_\-clause, }
\item[{{\bf Var\-Info\-::\-Var\-Kind}}]{kind}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a9eb9e182ca1da6a1050338928083f632}


Extracts literals that are of a given type from a cube or clause. 

This method takes as argument a cube or a clause (a set of literals), and a kind of variables. It returns the same set of literals with all variables of other kind removed.


\begin{DoxyParams}{Parameters}
{\em cube\-\_\-or\-\_\-clause} & The cube or clause from which only the desired literals should be extracted. \\
\hline
{\em kind} & The kind of literals that should be extracted. Literals of other kinds will be discarded. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The literals of cube\-\_\-or\-\_\-clause that are of a given type. That is, the returned vector is a subset of cube\-\_\-or\-\_\-clause, where all elements are of the desired kind. 
\end{DoxyReturn}


Definition at line 67 of file Utils.\-cpp.



References Var\-Manager\-::get\-Vars\-Of\-Type(), and Var\-Manager\-::instance().



Referenced by Learn\-Synth\-Q\-B\-F\-::compute\-Counterexample\-S\-A\-T(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Dep(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Dep2(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Recy(), debug\-Check\-Win\-Reg(), Clause\-Explorer\-S\-A\-T\-::explore\-Clauses(), Counter\-Gen\-S\-A\-T\-::generalize\-Counterexamples(), I\-F\-M13\-Synth\-::rec\-Block\-Cube(), and I\-F\-M13\-Explorer\-::rec\-Block\-Cube().

\hypertarget{classUtils_a21f2b014ac53ca027864c57e24a60195}{\index{Utils@{Utils}!extract@{extract}}
\index{extract@{extract}!Utils@{Utils}}
\subsubsection[{extract}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ int $>$ Utils\-::extract (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{cube\-\_\-or\-\_\-clause, }
\item[{const vector$<$ int $>$ \&}]{vars}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a21f2b014ac53ca027864c57e24a60195}


Extracts certain literals from a cube or clause. 


\begin{DoxyParams}{Parameters}
{\em cube\-\_\-or\-\_\-clause} & The cube or clause to analyze. \\
\hline
{\em vars} & The variables to extract from cube\-\_\-or\-\_\-clause. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
All literals of cube\-\_\-or\-\_\-clause where the corresponding variable occurs in vars. 
\end{DoxyReturn}


Definition at line 153 of file Utils.\-cpp.



References contains().

\hypertarget{classUtils_a9251f04947864aaaac7e459987913429}{\index{Utils@{Utils}!extract\-Next\-As\-Present@{extract\-Next\-As\-Present}}
\index{extract\-Next\-As\-Present@{extract\-Next\-As\-Present}!Utils@{Utils}}
\subsubsection[{extract\-Next\-As\-Present}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ int $>$ Utils\-::extract\-Next\-As\-Present (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{cube\-\_\-or\-\_\-clause}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a9251f04947864aaaac7e459987913429}


Extracts next-\/state literals and returns the present-\/state copy. 

This method takes as argument a cube or a clause (a set of literals). It returns the present-\/state copy of all the next-\/state literals in the cube or clause.


\begin{DoxyParams}{Parameters}
{\em cube\-\_\-or\-\_\-clause} & The cube or clause from which the current-\/state copy of the next-\/state literals should be extracted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
current-\/state copy of the next-\/state literals in cube\-\_\-or\-\_\-clause. 
\end{DoxyReturn}


Definition at line 128 of file Utils.\-cpp.



References Var\-Manager\-::get\-Vars\-Of\-Type(), Var\-Manager\-::instance(), Var\-Info\-::\-N\-E\-X\-T\-\_\-\-S\-T\-A\-T\-E, and Var\-Info\-::\-P\-R\-E\-S\-\_\-\-S\-T\-A\-T\-E.



Referenced by I\-F\-M13\-Synth\-::rec\-Block\-Cube(), and I\-F\-M13\-Explorer\-::rec\-Block\-Cube().

\hypertarget{classUtils_a9c060a97bf0e9e5e08bf33b512633ac3}{\index{Utils@{Utils}!extract\-Pres\-In@{extract\-Pres\-In}}
\index{extract\-Pres\-In@{extract\-Pres\-In}!Utils@{Utils}}
\subsubsection[{extract\-Pres\-In}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ int $>$ Utils\-::extract\-Pres\-In (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{cube\-\_\-or\-\_\-clause}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a9c060a97bf0e9e5e08bf33b512633ac3}


Extracts present-\/state literals and input literals from a cube or clause. 

This method takes as argument a cube or a clause (a set of literals). It returns the all literals from this set which are either present-\/state literals or (uncontrollable) input literals.


\begin{DoxyParams}{Parameters}
{\em cube\-\_\-or\-\_\-clause} & The cube or clause from which only current-\/state and input literals should be extracted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The literals of cube\-\_\-or\-\_\-clause that are either current-\/state literals or inputs. 
\end{DoxyReturn}


Definition at line 90 of file Utils.\-cpp.



References Var\-Manager\-::get\-Vars\-Of\-Type(), Var\-Info\-::\-I\-N\-P\-U\-T, Var\-Manager\-::instance(), and Var\-Info\-::\-P\-R\-E\-S\-\_\-\-S\-T\-A\-T\-E.



Referenced by I\-F\-M13\-Synth\-::rec\-Block\-Cube(), and I\-F\-M13\-Explorer\-::rec\-Block\-Cube().

\hypertarget{classUtils_ae48658c2b3c7f71261146210c7861b60}{\index{Utils@{Utils}!get\-Current\-Mem\-Usage@{get\-Current\-Mem\-Usage}}
\index{get\-Current\-Mem\-Usage@{get\-Current\-Mem\-Usage}!Utils@{Utils}}
\subsubsection[{get\-Current\-Mem\-Usage}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t Utils\-::get\-Current\-Mem\-Usage (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_ae48658c2b3c7f71261146210c7861b60}


Returns the current memory usage as debug message in k\-B. 

\begin{DoxyReturn}{Returns}
The current memory usage as debug message in k\-B. 
\end{DoxyReturn}


Definition at line 597 of file Utils.\-cpp.



Referenced by Univ\-Expander\-::init\-Solver\-I\-Data(), and Univ\-Expander\-::reset\-Solver\-I\-Exp().

\hypertarget{classUtils_aa6a513b0ad3b22b3b857060219c222d6}{\index{Utils@{Utils}!intersection\-Empty@{intersection\-Empty}}
\index{intersection\-Empty@{intersection\-Empty}!Utils@{Utils}}
\subsubsection[{intersection\-Empty}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::intersection\-Empty (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{x, }
\item[{const set$<$ int $>$ \&}]{y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_aa6a513b0ad3b22b3b857060219c222d6}


Checks if a vector and a set have an empty intersection. 


\begin{DoxyParams}{Parameters}
{\em x} & The vector to check. \\
\hline
{\em y} & The set to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the intersection of the vector and the set is empty, false otherwise. 
\end{DoxyReturn}


Definition at line 248 of file Utils.\-cpp.



Referenced by Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-All\-Blocking\-Clauses(), and Counter\-Gen\-S\-A\-T\-::generalize\-Counterexamples().

\hypertarget{classUtils_ae957d76f82e729f9d127cf05cb61320d}{\index{Utils@{Utils}!intersection\-Empty@{intersection\-Empty}}
\index{intersection\-Empty@{intersection\-Empty}!Utils@{Utils}}
\subsubsection[{intersection\-Empty}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::intersection\-Empty (
\begin{DoxyParamCaption}
\item[{const set$<$ int $>$ \&}]{x, }
\item[{const set$<$ int $>$ \&}]{y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_ae957d76f82e729f9d127cf05cb61320d}


Checks if the intersection of two sets is empty. 


\begin{DoxyParams}{Parameters}
{\em x} & The first set for the check. \\
\hline
{\em y} & The second set for the check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the intersection is empty, false otherwise. 
\end{DoxyReturn}


Definition at line 265 of file Utils.\-cpp.

\hypertarget{classUtils_ab5dca8125b6addaa1f0331664ab6142e}{\index{Utils@{Utils}!is\-Subset@{is\-Subset}}
\index{is\-Subset@{is\-Subset}!Utils@{Utils}}
\subsubsection[{is\-Subset}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::is\-Subset (
\begin{DoxyParamCaption}
\item[{const vector$<$ int $>$ \&}]{subset, }
\item[{const vector$<$ int $>$ \&}]{superset}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_ab5dca8125b6addaa1f0331664ab6142e}


Checks if one vector forms a subset of another one. 


\begin{DoxyParams}{Parameters}
{\em subset} & The potential subset in the check. \\
\hline
{\em superset} & The potential superset in the check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if 'subset' is really a subset of 'superset', false otherwise. 
\end{DoxyReturn}


Definition at line 282 of file Utils.\-cpp.



Referenced by C\-N\-F\-::add\-Clause\-And\-Simplify(), and C\-N\-F\-::simplify().

\hypertarget{classUtils_ae7584589e0d06005fe893fdb9244483a}{\index{Utils@{Utils}!negate\-Literals@{negate\-Literals}}
\index{negate\-Literals@{negate\-Literals}!Utils@{Utils}}
\subsubsection[{negate\-Literals}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::negate\-Literals (
\begin{DoxyParamCaption}
\item[{vector$<$ int $>$ \&}]{cube\-\_\-or\-\_\-clause}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_ae7584589e0d06005fe893fdb9244483a}


Negates all literals in a cube or clause. 


\begin{DoxyParams}{Parameters}
{\em cube\-\_\-or\-\_\-clause} & The cube or clause in which all literals should be negated. \\
\hline
\end{DoxyParams}


Definition at line 220 of file Utils.\-cpp.



Referenced by Counter\-Gen\-S\-A\-T\-::bored(), compress\-Next\-State\-C\-N\-F(), compress\-State\-C\-N\-F(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Blocking\-Clause(), Learn\-Synth\-Q\-B\-F\-::compute\-Blocking\-Clause(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Blocking\-Clause(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C\-Exp(), Clause\-Explorer\-S\-A\-T\-::explore\-Clauses(), Template\-Synth\-::find\-Win\-Reg\-A\-N\-D\-Network(), Counter\-Gen\-S\-A\-T\-::generalize\-Ce\-Futher(), Counter\-Gen\-S\-A\-T\-::generalize\-Counterexamples(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-Inc(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-No\-Inc(), Learn\-Synth\-Q\-B\-F\-Inc\-::reduce\-Existing\-Clauses(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Inc1(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Inc2(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp\-Ctrl(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp\-Ctrl\-Inc2(), Par\-Extractor\-Worker\-::run\-S\-A\-T(), Par\-Extractor\-Worker\-::run\-S\-A\-T\-Dep(), Template\-Synth\-::synt\-S\-A\-T(), and Templ\-Explorer\-::synt\-S\-A\-T().

\hypertarget{classUtils_ad6bc8cf6342b8f182597aa53cf72d9d3}{\index{Utils@{Utils}!negate\-State\-C\-N\-F@{negate\-State\-C\-N\-F}}
\index{negate\-State\-C\-N\-F@{negate\-State\-C\-N\-F}!Utils@{Utils}}
\subsubsection[{negate\-State\-C\-N\-F}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::negate\-State\-C\-N\-F (
\begin{DoxyParamCaption}
\item[{{\bf C\-N\-F} \&}]{cnf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_ad6bc8cf6342b8f182597aa53cf72d9d3}


Negates a \hyperlink{classCNF}{C\-N\-F} over the state-\/variables without introducing temporary variables. 

The negation of the passed \hyperlink{classCNF}{C\-N\-F} is computed via computational learning. It uses a S\-A\-T solver in an incremental fashion. This is more expensive than simply calling cnf.\-negate(), but it does not introduce temporary variables, and hence may lead to a smaller \hyperlink{classCNF}{C\-N\-F}.


\begin{DoxyParams}{Parameters}
{\em cnf} & The \hyperlink{classCNF}{C\-N\-F} formula to negate. \\
\hline
\end{DoxyParams}


Definition at line 371 of file Utils.\-cpp.



References C\-N\-F\-::add\-Neg\-Cube\-As\-Clause(), C\-N\-F\-::clear(), Options\-::get\-S\-A\-T\-Solver(), Var\-Manager\-::get\-Vars\-Of\-Type(), Sat\-Solver\-::inc\-Add\-C\-N\-F(), Sat\-Solver\-::inc\-Add\-Neg\-Cube\-As\-Clause(), Sat\-Solver\-::inc\-Is\-Sat\-Model\-Or\-Core(), Var\-Manager\-::instance(), Options\-::instance(), M\-A\-S\-S\-E\-R\-T, C\-N\-F\-::negate(), Var\-Manager\-::pop(), Var\-Info\-::\-P\-R\-E\-S\-\_\-\-S\-T\-A\-T\-E, Var\-Manager\-::push(), and Sat\-Solver\-::start\-Incremental\-Session().



Referenced by I\-F\-M13\-Explorer\-::explore\-Clauses().

\hypertarget{classUtils_acd64e5ea20bd4579427734a9ede171d8}{\index{Utils@{Utils}!negate\-Via\-Aig@{negate\-Via\-Aig}}
\index{negate\-Via\-Aig@{negate\-Via\-Aig}!Utils@{Utils}}
\subsubsection[{negate\-Via\-Aig}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::negate\-Via\-Aig (
\begin{DoxyParamCaption}
\item[{{\bf C\-N\-F} \&}]{cnf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_acd64e5ea20bd4579427734a9ede171d8}


Negates a \hyperlink{classCNF}{C\-N\-F} by transforming into A\-I\-G\-E\-R and back. 

This method performs the following 3 steps to negate a \hyperlink{classCNF}{C\-N\-F}\-: (1) the \hyperlink{classCNF}{C\-N\-F} is transformed into A\-I\-G\-E\-R format, (2) optimized with A\-B\-C, and (3) transformed back into \hyperlink{classCNF}{C\-N\-F}. The new \hyperlink{classCNF}{C\-N\-F} has one (fresh) temporary variable per A\-I\-G\-E\-R gate.


\begin{DoxyParams}{Parameters}
{\em cnf} & The \hyperlink{classCNF}{C\-N\-F} formula to negate. \\
\hline
\end{DoxyParams}


Definition at line 410 of file Utils.\-cpp.



References C\-N\-F\-::add1\-Lit\-Clause(), C\-N\-F\-::add2\-Lit\-Clause(), C\-N\-F\-::add3\-Lit\-Clause(), C\-N\-F\-::append\-Vars\-To(), C\-N\-F\-::clear(), Var\-Manager\-::create\-Fresh\-Tmp\-Var(), C\-N\-F\-::get\-Clauses(), Options\-::get\-T\-P\-Dir\-Name(), Options\-::get\-Unique\-Tmp\-File\-Name(), Var\-Manager\-::instance(), Options\-::instance(), and M\-A\-S\-S\-E\-R\-T.

\hypertarget{classUtils_a0ed61b802f94ec15000c458e9aae4f19}{\index{Utils@{Utils}!operator=@{operator=}}
\index{operator=@{operator=}!Utils@{Utils}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Utils}\& Utils\-::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Utils} \&}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}}\label{classUtils_a0ed61b802f94ec15000c458e9aae4f19}


Assignment operator. 

The assignment operator is disabled (set private) and not implemented.


\begin{DoxyParams}{Parameters}
{\em other} & The source for creating the copy. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the assignment, i.\-e, $\ast$this. 
\end{DoxyReturn}
\hypertarget{classUtils_a71efa1aa570b356a328e95008fb65ad8}{\index{Utils@{Utils}!randomize@{randomize}}
\index{randomize@{randomize}!Utils@{Utils}}
\subsubsection[{randomize}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::randomize (
\begin{DoxyParamCaption}
\item[{vector$<$ int $>$ \&}]{vec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a71efa1aa570b356a328e95008fb65ad8}


Randomizes the order (not the value) of a given vector of integers. 


\begin{DoxyParams}{Parameters}
{\em vec} & The vector to randomize. This vector is modified in-\/place, i.\-e., after calling this method, the order of the elements in the passed vector will be randomized. \\
\hline
\end{DoxyParams}


Definition at line 168 of file Utils.\-cpp.



Referenced by Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Blocking\-Clause(), Learn\-Synth\-Q\-B\-F\-::compute\-Blocking\-Clause(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Blocking\-Clause(), Clause\-Explorer\-S\-A\-T\-::explore\-Clauses(), Dep\-Q\-B\-F\-Api\-::extract\-Core(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-Inc(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-No\-Inc(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp\-Ctrl(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp\-Ctrl\-Inc2(), and Par\-Extractor\-Worker\-::run\-S\-A\-T\-Dep().

\hypertarget{classUtils_a15b142132eb40445f51b1f1bb89b85f3}{\index{Utils@{Utils}!remove@{remove}}
\index{remove@{remove}!Utils@{Utils}}
\subsubsection[{remove}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\-::remove (
\begin{DoxyParamCaption}
\item[{vector$<$ int $>$ \&}]{vec, }
\item[{int}]{elem}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a15b142132eb40445f51b1f1bb89b85f3}


Removes a certain element from a vector. 

This method may change the order of the elements arbitrarily.


\begin{DoxyParams}{Parameters}
{\em vec} & The vector from which the element should be removed. \\
\hline
{\em elem} & The element to remove. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the element was removed, false otherwise. 
\end{DoxyReturn}


Definition at line 180 of file Utils.\-cpp.



Referenced by Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Exp(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Recy(), Clause\-Explorer\-S\-A\-T\-::explore\-Clauses(), Dep\-Q\-B\-F\-Api\-::extract\-Core(), Counter\-Gen\-S\-A\-T\-::generalize\-Ce\-Futher(), Learn\-Synth\-Q\-B\-F\-::generalize\-Counterexample(), Learn\-Synth\-Q\-B\-F\-Ind\-::generalize\-Counterexample(), Learn\-Synth\-Q\-B\-F\-Inc\-::generalize\-Counterexample\-Further(), Counter\-Gen\-S\-A\-T\-::generalize\-Counterexamples(), Lingeling\-Api\-::inc\-Is\-Sat\-Model\-Or\-Core(), Pico\-Sat\-Api\-::inc\-Is\-Sat\-Model\-Or\-Core(), Mini\-Sat\-Api\-::inc\-Is\-Sat\-Model\-Or\-Core(), Pico\-Sat\-Api\-::is\-Sat\-Model\-Or\-Core(), Lingeling\-Api\-::is\-Sat\-Model\-Or\-Core(), Mini\-Sat\-Api\-::is\-Sat\-Model\-Or\-Core(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-Inc(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-No\-Inc(), Learn\-Synth\-Q\-B\-F\-::reduce\-Existing\-Clauses(), Learn\-Synth\-Q\-B\-F\-Ind\-::reduce\-Existing\-Clauses(), Learning\-Impl\-Extractor\-::run\-Learning\-Exp(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Inc1(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Inc2(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp\-Ctrl(), Learning\-Impl\-Extractor\-::run\-Learning\-Jiang\-S\-A\-T\-Tmp\-Ctrl\-Inc2(), Learning\-Impl\-Extractor\-::run\-Learning\-Q\-B\-F(), Learning\-Impl\-Extractor\-::run\-Learning\-Q\-B\-F\-Inc(), Par\-Extractor\-Q\-B\-F\-Worker\-::run\-Q\-B\-F(), Par\-Extractor\-Worker\-::run\-S\-A\-T(), and Par\-Extractor\-Worker\-::run\-S\-A\-T\-Dep().

\hypertarget{classUtils_a2843ae3d849c66ebd72baea26fbd7580}{\index{Utils@{Utils}!sort@{sort}}
\index{sort@{sort}!Utils@{Utils}}
\subsubsection[{sort}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::sort (
\begin{DoxyParamCaption}
\item[{vector$<$ int $>$ \&}]{vec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a2843ae3d849c66ebd72baea26fbd7580}


Sorts a vector of integers in ascending order. 


\begin{DoxyParams}{Parameters}
{\em vec} & The vector to sort. This vector is modified in-\/place, i.\-e., after calling this method, this vector will be sorted. \\
\hline
\end{DoxyParams}


Definition at line 174 of file Utils.\-cpp.



Referenced by Learn\-Synth\-Q\-B\-F\-Inc\-::generalize\-Counterexample(), Learn\-Synth\-Q\-B\-F\-::generalize\-Counterexample(), Learn\-Synth\-Q\-B\-F\-Ind\-::generalize\-Counterexample(), and Learn\-Synth\-Q\-B\-F\-Inc\-::generalize\-Counterexample\-Further().

\hypertarget{classUtils_a8e0d236cf00a61a34ef5c48bcb08a1ec}{\index{Utils@{Utils}!swap\-Present\-To\-Next@{swap\-Present\-To\-Next}}
\index{swap\-Present\-To\-Next@{swap\-Present\-To\-Next}!Utils@{Utils}}
\subsubsection[{swap\-Present\-To\-Next}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\-::swap\-Present\-To\-Next (
\begin{DoxyParamCaption}
\item[{vector$<$ int $>$ \&}]{vec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{classUtils_a8e0d236cf00a61a34ef5c48bcb08a1ec}


Replaces all current-\/state literals by their next-\/state copy. 

\begin{DoxyNote}{Note}
The passed vector of literals must only contain current-\/state literals. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em vec} & The vector of literals in which all current-\/state literals (it must only talk about current-\/state literals) should be replaced by their next-\/state copy. \\
\hline
\end{DoxyParams}


Definition at line 227 of file Utils.\-cpp.



References Var\-Manager\-::get\-Max\-C\-N\-F\-Var(), Var\-Manager\-::get\-Vars\-Of\-Type(), Var\-Manager\-::instance(), M\-A\-S\-S\-E\-R\-T, Var\-Info\-::\-N\-E\-X\-T\-\_\-\-S\-T\-A\-T\-E, and Var\-Info\-::\-P\-R\-E\-S\-\_\-\-S\-T\-A\-T\-E.



Referenced by I\-F\-M13\-Synth\-::add\-Blocked\-State(), I\-F\-M13\-Explorer\-::add\-Blocked\-State(), I\-F\-M13\-Synth\-::add\-Lose(), I\-F\-M13\-Explorer\-::add\-Lose(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-All\-Blocking\-Clauses(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Blocking\-Clause(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-All(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-All\-Pool(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-All\-Push(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-Ind\-::compute\-Winning\-Region\-One(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-One\-Pool(), Learn\-Synth\-Q\-B\-F\-Inc\-::compute\-Winning\-Region\-One\-Push(), Learn\-Synth\-Q\-B\-F\-::compute\-Winning\-Region\-One\-S\-A\-T(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-Plain\-Dep(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-R\-C(), Learn\-Synth\-S\-A\-T\-::compute\-Winning\-Region\-R\-G\-Recy(), Clause\-Explorer\-S\-A\-T\-::explore\-Clauses(), Counter\-Gen\-S\-A\-T\-::generalize\-Ce\-Futher(), Learn\-Synth\-Q\-B\-F\-::generalize\-Counterexample(), Learn\-Synth\-Q\-B\-F\-Ind\-::generalize\-Counterexample(), Clause\-Minimizer\-Q\-B\-F\-::minimize\-Clauses\-No\-Inc(), I\-F\-M13\-Synth\-::propagate\-Blocked\-States(), I\-F\-M13\-Explorer\-::propagate\-Blocked\-States(), and Learn\-Synth\-Q\-B\-F\-Inc\-::reduce\-Existing\-Clauses().



The documentation for this class was generated from the following files\-:\begin{DoxyCompactItemize}
\item 
src/\hyperlink{Utils_8h}{Utils.\-h}\item 
src/\hyperlink{Utils_8cpp}{Utils.\-cpp}\end{DoxyCompactItemize}
