\hypertarget{index_intro_sec}{}\section{Introduction}\label{index_intro_sec}
Demiurge is a tool to synthesize a correct-\/by-\/construction implementation of a reactive system from a declarative safety specification fully automatically. The specification that serves as input can only contain properties expressing that 'something bad never happens'. However, many other specification formats can be reduced to pure safety specifications (e.\-g., by setting a bound on the reaction time as explained in the paper 'Ruediger Ehlers\-: Symbolic bounded synthesis, Formal Methods in System Design 40(2)\-: 232-\/262 (2012)').

Demiurge implements different synthesis methods in different back-\/ends. Most of these synthesis methods are based on S\-A\-T-\/ or Q\-B\-F-\/solving. A description of some of the implemented algorithms can be found in the paper\-: Roderick Bloem, Robert Koenighofer, Martina Seidl\-: \char`\"{}\-S\-A\-T-\/\-Based Synthesis 
  Methods for Safety Specs\char`\"{} in V\-M\-C\-A\-I'14. Different methods for synthesizing circuits from already computed strategies are discussed in the paper\-: Roderick Bloem, Uwe Egly, Patrick Klampfl, Robert Koenighofer, Florian Lonsing\-: \char`\"{}\-S\-A\-T-\/based methods for circuit synthesis\char`\"{} in F\-M\-C\-A\-D'14. Demiurge is not only a tool, but also a framework for implementing new synthesis algorithms. A lot of infrastructure can be re-\/used. This includes not only the parsing of input files but also classes to conveniently manipulate Boolean formulas in conjunctive normal form, interfaces to S\-A\-T-\/ and Q\-B\-F solvers (different solvers can be used via a unified interface), and so on. Most of the infrastructure currently available targets S\-A\-T-\/ and Q\-B\-F-\/based synthesis methods. But there is no reason not include B\-D\-D-\/based methods in new back-\/ends.

Demiurge is not only a tool, but also a framework for implementing new synthesis algorithms. A lot of infrastructure can be re-\/used. This includes not only the parsing of input files but also classes to conveniently manipulate Boolean formulas in conjunctive normal form, interfaces to S\-A\-T-\/ and Q\-B\-F solvers (different solvers can be used via a unified interface), and so on. Most of the infrastructure currently available targets S\-A\-T-\/ and Q\-B\-F-\/based synthesis methods. But there is no reason not include B\-D\-D-\/based methods in new back-\/ends.\hypertarget{index_input_sec}{}\subsection{Input of the Tool}\label{index_input_sec}
The input to this tool is a safety specification in \href{http://fmv.jku.at/aiger/}{\tt A\-I\-G\-E\-R} format. It is defined in the same way as for the safety track of the \href{http://fmv.jku.at/hwmcc13/}{\tt hardware model checking competition}\-: it has a certain number of state bits that are updated depending on the inputs of the system. There is exactly one output bit which signals an error. This output can depend on the current state and input. The tools of the hardware model checking competition answer the question\-: 'can this output ever become true?'. Our synthesis tool distinguishes two kinds of inputs\-: uncontrollable inputs and control signals. They are distinguished by their name. Control signals have a name that starts with 'controllable\-\_\-'. The question answered by demiurge is\-: 'can the control signals be implemented in such a way that the error output never becomes true?' If yes, then we compute such an implementation. This is compatible with the input format for the \href{http://www.syntcomp.org/}{\tt synthesis competition}.\hypertarget{index_output_sec}{}\subsection{Output of the Tool}\label{index_output_sec}
The output of the synthesis tool is a circuit in A\-I\-G\-E\-R format as well. It is a copy of the the input file with one important change\-: the control signals are no inputs to the circuit any more. Instead, they are computed inside the circuit based on the current state and the uncontrollable inputs. Hence, for a sanity check, the output of our tool can be passed on to a verification tool compatible with the requirements of the hardware model checking competition.\hypertarget{index_install_sec}{}\section{Installation and Usage}\label{index_install_sec}
At the moment, we support Unix-\/based operating systems only. In order to compile the tool, you need to\-: 
\begin{DoxyEnumerate}
\item Make sure that G\-N\-U make, the G\-N\-U C compiler gcc, and the G\-N\-U C++ compiler g++ is installed on your system. On Debian-\/based Linux systems (such as Ubuntu), you can do this by typing \begin{DoxyVerb}shell> sudo apt-get install build-essential \end{DoxyVerb}
 in a shell. 
\item Make sure that 'cmake' is installed on your system. On Debian-\/based Linux systems, you can do this by typing \begin{DoxyVerb}shell> sudo apt-get install cmake \end{DoxyVerb}
 
\item Create a new directory in which all third-\/party software should be installed. We will call this directory {\ttfamily $<$third\-\_\-party\-\_\-install$>$} in the following. It should be different to tool/ext\-\_\-tools/. 
\item Set the environment variable D\-E\-M\-I\-U\-R\-G\-E\-T\-P to point to this directory. In the 'bash' shell, this can be done with the command\-: \begin{DoxyVerb}bash> export DEMIURGETP=<third_party_install>  \end{DoxyVerb}
 In order to avoid setting this environment variable every time, you can also add the above line to the file {\ttfamily $\sim$/}.bashrc (when using the bash shell, for other shells, this works similar). 
\item Open a bash in the directory {\ttfamily tool/ext\-\_\-tools} and execute the script {\ttfamily install\-\_\-all.\-sh}. This script calls all other scripts in this directory. The scripts download and compile third-\/party software like S\-A\-T-\/ and Q\-B\-F-\/solvers. Make sure that you are connected to the Internet while executing this script. 
\item Open a shell in the directory {\ttfamily tool/} and type 'make'. This will compile our source code and link it against the third-\/party libraries. 
\item The executables {\ttfamily tool/build/src/demiurge-\/bin} and {\ttfamily tool/build/src/demiurge-\/debug} should have been created and you are done. {\ttfamily demiurge-\/debug} is like {\ttfamily demiurge-\/bin} but performs many debug-\/checks during operation. 
\item Execute the program ({\ttfamily tool/build/src/demiurge-\/bin}) with the option '--help' to get a list of command-\/line options and their meaning. 
\end{DoxyEnumerate}\hypertarget{index_archit_sec}{}\section{Architecture}\label{index_archit_sec}
You can easily extend demiurge with new synthesis methods. The architecture of the tool is simple\-: Different synthesis methods are implemented in different \hyperlink{classBackEnd}{Back\-Ends }. Simply create a new back-\/end and implement its \hyperlink{classBackEnd_a099e717dc71e9cc2d838b1ca86340590}{Back\-End\-::run()} method. The class \hyperlink{classOptions}{Options} is a singleton that gives you access to the command-\/line parameters. The class \hyperlink{classAIG2CNF}{A\-I\-G2\-C\-N\-F} provides you with \hyperlink{classCNF}{C\-N\-F} representations of the different parts of the specification (the transition relation, initial state, safe states). The \hyperlink{classVarManager}{Var\-Manager} contains all variables of the specification and allows you to create new (unique) variables. Other utility classes and methods that could be useful for implementing your new back-\/end are\-: 
\begin{DoxyItemize}
\item The \hyperlink{classLogger}{Logger} allows you to print messages (which can be enabled and disabled with command-\/line options). 
\item The \hyperlink{classOptions_aed3731b7c89433cd485cff35ca4bdcd7}{Options\-::get\-S\-A\-T\-Solver()} gives you an instance of the S\-A\-T-\/solver selected by the user. 
\item The \hyperlink{classOptions_af46f1ca66fde685e029391bda1452a9f}{Options\-::get\-Q\-B\-F\-Solver()} gives you an instance of the Q\-B\-F-\/solver selected by the user. 
\item The \hyperlink{classStopwatch}{Stopwatch} allows you to measure execution times of different parts of your algorithm. 
\item The \hyperlink{classFileUtils}{File\-Utils}, \hyperlink{classStringUtils}{String\-Utils}, and \hyperlink{classUtils}{Utils} provide other small utility functions that are potentially useful for all back-\/ends. 
\end{DoxyItemize}